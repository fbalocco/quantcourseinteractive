<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Session 3 - Experimental Studies and Comparing Means</title>
    <script>
      window.MathJax = {
        tex: { inlineMath: [["\\(", "\\)"]], displayMath: [["$$", "$$"]] }
      };
    </script>
    <script defer src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <style>
      :root {
        color-scheme: light;
        --bg: #f7f8fc;
        --card: #ffffff;
        --text: #1c1f24;
        --muted: #5d6473;
        --border: #e3e7f1;
        --accent: #2b6de9;
        --accent-2: #1f4fb1;
        --success: #1c7c54;
        --warning: #d97706;
      }

      * {
        box-sizing: border-box;
      }

      body {
        margin: 0;
        font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
        color: var(--text);
        background: var(--bg);
        line-height: 1.6;
        padding-top: 70px;
      }

      a {
        color: var(--accent);
        text-decoration: none;
      }

      a:hover {
        color: var(--accent-2);
        text-decoration: underline;
      }

      header {
        background: linear-gradient(135deg, #eaf0ff, #ffffff);
        border-bottom: 1px solid var(--border);
      }

      .container {
        max-width: min(1320px, 96vw);
        margin: 0 auto;
        padding: 24px 20px 60px;
      }

      .hero {
        display: grid;
        gap: 12px;
        padding: 28px 0 18px;
      }

      .breadcrumbs {
        font-size: 14px;
        color: var(--muted);
      }

      .hero h1 {
        margin: 0;
        font-size: 32px;
      }

      .hero p {
        margin: 0;
        color: var(--muted);
        max-width: 920px;
      }

      .section {
        margin-top: 28px;
        display: grid;
        gap: 16px;
      }

      .card {
        background: var(--card);
        border: 1px solid var(--border);
        border-radius: 14px;
        padding: 18px;
        box-shadow: 0 12px 24px rgba(24, 34, 72, 0.06);
      }

      .card h3 {
        margin-top: 0;
      }

      .grid-2 {
        display: grid;
        gap: 16px;
        grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
      }

      .tag {
        display: inline-block;
        font-size: 12px;
        letter-spacing: 0.08em;
        text-transform: uppercase;
        color: var(--muted);
      }

      .pill {
        display: inline-block;
        border: 1px solid var(--border);
        border-radius: 999px;
        padding: 4px 10px;
        font-size: 12px;
        color: var(--muted);
        background: #f2f4fa;
      }

      .topbar {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        height: 56px;
        background: #ffffff;
        border-bottom: 1px solid var(--border);
        display: flex;
        align-items: center;
        gap: 16px;
        padding: 0 16px;
        z-index: 1000;
      }

      .topbar-link {
        font-weight: 600;
        color: var(--accent);
      }

      .topbar-progress {
        flex: 1;
        display: grid;
        gap: 4px;
      }

      .progress-track {
        height: 6px;
        background: #e5e7eb;
        border-radius: 999px;
        overflow: hidden;
      }

      .progress-bar {
        height: 100%;
        width: 0%;
        background: var(--accent);
        transition: width 0.2s ease;
      }

      .progress-text {
        font-size: 12px;
        color: var(--muted);
      }

      .topbar-actions {
        display: flex;
        align-items: center;
        gap: 8px;
      }

      .settings-panel {
        position: fixed;
        top: 64px;
        right: 16px;
        background: #ffffff;
        border: 1px solid var(--border);
        border-radius: 12px;
        padding: 12px;
        box-shadow: 0 10px 24px rgba(24, 34, 72, 0.12);
        z-index: 1001;
        display: none;
      }

      .settings-panel.open {
        display: grid;
        gap: 8px;
      }

      .settings-title {
        font-weight: 600;
        font-size: 13px;
      }

      .controls {
        display: grid;
        gap: 10px;
        margin-top: 12px;
      }

      .control-row {
        display: grid;
        gap: 6px;
      }

      label {
        font-size: 13px;
        color: var(--muted);
      }

      input[type="range"],
      input[type="number"],
      select,
      textarea {
        width: 100%;
      }

      .btn {
        background: var(--accent);
        color: #fff;
        border: none;
        padding: 10px 14px;
        border-radius: 10px;
        cursor: pointer;
        font-weight: 600;
        font-size: 14px;
      }

      .btn.secondary {
        background: #e9eefc;
        color: var(--accent-2);
      }

      .btn:disabled {
        opacity: 0.6;
        cursor: not-allowed;
      }

      .stats {
        display: grid;
        gap: 8px;
        grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
        margin-top: 12px;
      }

      .stat {
        background: #f5f7ff;
        border-radius: 10px;
        padding: 10px;
        font-size: 13px;
      }

      .small {
        font-size: 12px;
        color: var(--muted);
      }

      canvas {
        width: 100%;
        border: 1px solid var(--border);
        border-radius: 12px;
        background: #fbfcff;
      }

      .quiz {
        display: grid;
        gap: 10px;
      }

      .quiz label {
        font-size: 14px;
        color: var(--text);
      }

      .feedback {
        font-size: 13px;
        padding: 8px 10px;
        border-radius: 8px;
        background: #f5f7ff;
        color: var(--muted);
      }

      .feedback.correct {
        background: #e7f6ee;
        color: var(--success);
      }

      .feedback.wrong {
        background: #fff4e5;
        color: var(--warning);
      }

      .bench {
        display: grid;
        gap: 12px;
      }

      .bench textarea {
        min-height: 180px;
        font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
        font-size: 12px;
        border: 1px solid var(--border);
        border-radius: 10px;
        padding: 10px;
      }

      .bench-output {
        display: grid;
        gap: 12px;
      }

      pre {
        margin: 0;
        background: #0f172a;
        color: #e2e8f0;
        padding: 12px;
        border-radius: 12px;
        min-height: 140px;
        overflow-x: auto;
        font-size: 12px;
      }

      ul {
        margin: 0 0 0 18px;
      }

      .callout {
        border-left: 4px solid #9bb8ff;
        padding-left: 12px;
        color: var(--muted);
      }

      .topic-list {
        list-style: none;
        margin: 0;
        padding: 0;
        display: grid;
        gap: 12px;
      }

      .topic-card {
        background: #fdfdff;
        border: 1px dashed #d8e1f6;
        border-radius: 12px;
        padding: 14px;
        display: grid;
        gap: 8px;
      }

      .topic-card h4 {
        margin: 0;
        font-size: 16px;
      }

      .card-grid {
        display: grid;
        gap: 16px;
        grid-template-columns: minmax(320px, 1.15fr) 2.15fr;
        align-items: start;
      }

      .card-left {
        display: grid;
        gap: 8px;
      }

      .card-right {
        display: grid;
        gap: 12px;
      }

      /* In single-card view, let theory and practice scroll independently. */
      .view-mode-single .card-left,
      .view-mode-single .card-right {
        max-height: var(--split-pane-height, 70vh);
        overflow-y: auto;
        overscroll-behavior: contain;
        scrollbar-gutter: stable;
        padding-right: 6px;
      }

      /* In all-cards view, keep theory visible while the page scrolls. */
      @media (min-width: 901px) {
        .view-mode-all .topic-card .card-left {
          position: sticky;
          top: 72px;
        }
      }

      .theory {
        font-size: 13px;
        color: var(--muted);
      }

      .exercise-intro {
        font-size: 12px;
        color: var(--muted);
      }

      footer {
        margin-top: 32px;
        font-size: 12px;
        color: var(--muted);
      }

      @media (max-width: 900px) {
        .card-grid {
          grid-template-columns: 1fr;
        }
      }

      .topic-card ul {
        margin: 0 0 0 18px;
      }

      .topic-figure {
        margin-top: 6px;
        background: #f5f7ff;
        border: 1px solid #e1e7f8;
        border-radius: 10px;
        padding: 8px;
        display: grid;
        justify-items: center;
      }

      .topic-figure svg {
        max-width: 100%;
        height: auto;
      }

      .topic-note {
        font-size: 12px;
        color: var(--muted);
      }

      .mini-check {
        display: grid;
        gap: 6px;
        margin-top: 8px;
        padding: 10px;
        border-radius: 10px;
        border: 1px solid #e1e7f8;
        background: #f6f8ff;
      }

      .mini-check label {
        font-size: 12px;
        color: var(--muted);
      }

      .mini-check select {
        padding: 6px 8px;
        border-radius: 8px;
        border: 1px solid var(--border);
        background: #fff;
        font-size: 13px;
      }
    </style>
  </head>
  <body>
    <div class="topbar">
      <a class="topbar-link" href="index.html">All modules</a>
      <div class="topbar-progress">
        <div class="progress-track"><div class="progress-bar" id="progress-bar"></div></div>
        <div class="progress-text" id="progress-text">Cards</div>
      </div>
      <div class="topbar-actions">
        <button class="btn secondary" id="prev-card" type="button">Prev</button>
        <button class="btn secondary" id="next-card" type="button">Next</button>
        <button class="btn" id="settings-btn" type="button">Settings</button>
      </div>
    </div>
    <div class="settings-panel" id="settings-panel">
      <div class="settings-title">View settings</div>
      <label><input type="radio" name="view-mode" value="all"> Show all cards</label>
      <label><input type="radio" name="view-mode" value="single"> Card-by-card</label>
    </div>
    <header>
      <div class="container hero">
        <div class="breadcrumbs"><a href="index.html">All modules</a> / Session 3</div>
        <span class="tag">RDM Quantitative Track</span>
        <h1>Experimental Studies and Comparing Means</h1>
        <p>
          Learn when experiments are appropriate, how to design them, and how to
          compare group means with t-tests and ANOVA.
        </p>
        <div class="pill">Session 3 - 20 Feb 2024</div>
      </div>
    </header>

    <main class="container">
      <section class="section card">
        <h3>Learning goals</h3>
        <ul>
          <li>Choose the right experiment type for a causal question.</li>
          <li>Use the experimental checklist to validate a design.</li>
          <li>Connect hypotheses to mean comparisons and t-tests.</li>
          <li>Use ANOVA for comparisons across three or more groups.</li>
          <li>Recognize assumptions and when to use transformations.</li>
        </ul>
      </section>

      <section class="section card">
        <h3>Syllabus walkthrough (slide order)</h3>
        <p class="small">Selected topics below follow the slide sequence.</p>
        <ol class="topic-list">
          <li class="topic-card">
            <h4>1. Hypothesis test workflow: simulation → p-values → CIs → interpretation</h4>
            <p class="small">
              This single test connects the simulation, the test statistic, the p-value, and confidence
              intervals. Resampling below updates every step in the same analysis.
            </p>
            <p class="small">
              <strong>Step 1: Simulate two groups.</strong> Adjust the group means, sizes, and variability,
              then resample to update the shared test.
            </p>
            <div class="controls grid-2">
              <div class="control-row">
                <label>Group A size</label>
                <input id="hypo-n1" type="number" min="10" max="300" step="5" value="40">
              </div>
              <div class="control-row">
                <label>Group B size</label>
                <input id="hypo-n2" type="number" min="10" max="300" step="5" value="60">
              </div>
              <div class="control-row">
                <label>Mean A</label>
                <input id="hypo-m1" type="number" min="-2" max="5" step="0.2" value="0">
              </div>
              <div class="control-row">
                <label>Mean B</label>
                <input id="hypo-m2" type="number" min="-2" max="5" step="0.2" value="0.8">
              </div>
              <div class="control-row">
                <label>Std dev (sigma)</label>
                <input id="hypo-sd" type="number" min="0.5" max="5" step="0.1" value="1.6">
              </div>
              <div class="control-row">
                <label>&nbsp;</label>
                <button class="btn" id="hypo-run" type="button">Resample</button>
              </div>
            </div>
            <canvas id="hypo-canvas" width="820" height="230" aria-label="Overlapping samples with means and CIs"></canvas>
            <div class="stats">
              <div class="stat">Mean A: <span id="hypo-mean-a">-</span></div>
              <div class="stat">Mean B: <span id="hypo-mean-b">-</span></div>
              <div class="stat">CI A: <span id="hypo-ci-a">-</span></div>
              <div class="stat">CI B: <span id="hypo-ci-b">-</span></div>
              <div class="stat">t-stat: <span id="hypo-t">-</span></div>
              <div class="stat">p-value: <span id="hypo-p">-</span></div>
              <div class="stat">Decision (alpha=0.05): <span id="hypo-decision">-</span></div>
            </div>
            <p class="small">
              <strong>Step 2: p-value visualization.</strong> The same t-statistic feeds the plot below.
              A p-value is the probability of observing data at least as extreme as ours if the null
              hypothesis were true.
            </p>
            <div class="controls">
              <div class="control-row">
                <label>Significance level (alpha): <strong id="ttest-alpha-label">0.05</strong></label>
                <input id="ttest-alpha" type="range" min="0.01" max="0.2" step="0.01" value="0.05">
              </div>
            </div>
            <canvas id="ttest-canvas" width="820" height="230" aria-label="t-test p-value plot"></canvas>
            <div class="stats">
              <div class="stat">t-stat: <span id="ttest-t">-</span></div>
              <div class="stat">p-value: <span id="ttest-p">-</span></div>
              <div class="stat">Critical value: <span id="ttest-crit">-</span></div>
              <div class="stat">Decision: <span id="ttest-decision">-</span></div>
            </div>
            <p class="small">
              <strong>Step 3: Confidence intervals and p-values.</strong> CIs summarize uncertainty
              around the means. When CIs overlap substantially, p-values tend to be larger.
            </p>
            <canvas id="ci-rel-canvas" width="820" height="200" aria-label="Confidence interval relationship"></canvas>
            <div class="stats">
              <div class="stat">CI overlap: <span id="ci-rel-overlap">-</span></div>
              <div class="stat">p-value: <span id="ci-rel-p">-</span></div>
              <div class="stat">Note: <span id="ci-rel-note">-</span></div>
            </div>
            <p class="small"><strong>Step 4: Interpretation.</strong> Translate the test output into words.</p>
            <p class="small" id="ttest-interpretation">
              Resample above to update this interpretation.
            </p>
            <div class="mini-check" data-answer="a">
              <label>Quick check: H0 typically states...</label>
              <select>
                <option value="">Choose an answer</option>
                <option value="a">No difference between groups</option>
                <option value="b">A strong effect exists</option>
                <option value="c">Groups are identical in every way</option>
                <option value="d">Randomization is unnecessary</option>
              </select>
              <button class="btn secondary check-btn" type="button">Check</button>
              <div class="feedback" aria-live="polite"></div>
            </div>
          </li>
          <li class="topic-card">
            <h4>2. When to use mean comparison vs t-test</h4>
            <ul>
              <li>Mean comparisons for descriptive checks.</li>
              <li>t-tests for formal inference.</li>
            </ul>
            <p class="small">
              Use the sandbox to connect descriptive mean differences to formal inference.
            </p>
            <div class="card" style="margin-top: 16px;">
              <h3>Mean comparison sandbox</h3>
              <p class="callout">
                Simulate two groups and inspect the difference in means and their confidence intervals.
                Larger samples and stronger effects make differences easier to detect.
              </p>
              <div class="controls grid-2">
                <div class="control-row">
                  <label>Sample size per group</label>
                  <input id="sim-n" type="range" min="10" max="200" step="5" value="40">
                  <span class="small">n = <strong id="sim-n-label">40</strong></span>
                </div>
                <div class="control-row">
                  <label>Effect size (mean difference)</label>
                  <input id="sim-diff" type="range" min="0" max="3" step="0.25" value="1">
                  <span class="small">difference = <strong id="sim-diff-label">1.00</strong></span>
                </div>
                <div class="control-row">
                  <label>Standard deviation (sigma)</label>
                  <input id="sim-sd" type="range" min="0.5" max="5" step="0.5" value="2">
                  <span class="small">sigma = <strong id="sim-sd-label">2.0</strong></span>
                </div>
                <div class="control-row">
                  <label>&nbsp;</label>
                  <button class="btn" id="sim-run">Simulate groups</button>
                </div>
              </div>
              <canvas id="sim-canvas" width="820" height="220"></canvas>
              <div class="stats">
                <div class="stat">Mean A: <span id="sim-mean-a">-</span></div>
                <div class="stat">Mean B: <span id="sim-mean-b">-</span></div>
                <div class="stat">CI overlap: <span id="sim-overlap">-</span></div>
              </div>
              <p class="small">
                CI overlap is an informal heuristic; formal inference comes from t-tests or ANOVA.
              </p>
            </div>
          </li>
          <li class="topic-card">
            <h4>3. One-way ANOVA and post-hoc tests</h4>
            <p class="small">
              Select group means and simulate samples (the dots are individual observations). The same
              analysis produces the one-way ANOVA F-test and the post-hoc comparisons below.
            </p>
            <div class="controls grid-2">
              <div class="control-row">
                <label>Group A mean</label>
                <input id="oneway-m1" type="range" min="-2" max="2" step="0.2" value="-0.6">
              </div>
              <div class="control-row">
                <label>Group B mean</label>
                <input id="oneway-m2" type="range" min="-2" max="2" step="0.2" value="0">
              </div>
              <div class="control-row">
                <label>Group C mean</label>
                <input id="oneway-m3" type="range" min="-2" max="2" step="0.2" value="0.7">
              </div>
              <div class="control-row">
                <label>Sample size per group</label>
                <input id="oneway-n" type="number" min="10" max="200" step="5" value="30">
              </div>
              <div class="control-row">
                <label>Within-group sd</label>
                <input id="oneway-sd" type="range" min="0.5" max="3" step="0.1" value="1.2">
              </div>
              <div class="control-row">
                <label>&nbsp;</label>
                <button class="btn" id="oneway-run" type="button">Resimulate</button>
              </div>
            </div>
            <canvas id="oneway-canvas" width="820" height="230" aria-label="One-way ANOVA samples"></canvas>
            <div class="stats">
              <div class="stat">F-stat: <span id="oneway-f">-</span></div>
              <div class="stat">p-value: <span id="oneway-p">-</span></div>
              <div class="stat">Comment: <span id="oneway-comment">-</span></div>
            </div>
            <p class="small">
              Tukey-style post-hoc comparisons help identify which groups differ after a significant ANOVA.
            </p>
            <div class="stats">
              <div class="stat">A vs B: <span id="tukey-ab">-</span></div>
              <div class="stat">A vs C: <span id="tukey-ac">-</span></div>
              <div class="stat">B vs C: <span id="tukey-bc">-</span></div>
              <div class="stat">Comment: <span id="tukey-comment">-</span></div>
            </div>
          </li>
          <li class="topic-card">
            <h4>4. Factorial ANOVA (two-way example)</h4>
            <p class="small">
              A 2x2 design (music: on/off, task difficulty: low/high). Explore main effects and interaction.
              Axes show difficulty (x) and mean outcome (y).
            </p>
            <div class="controls grid-2">
              <div class="control-row">
                <label>Main effect A (music)</label>
                <input id="fact-a" type="range" min="-2" max="2" step="0.2" value="0.5">
              </div>
              <div class="control-row">
                <label>Main effect B (difficulty)</label>
                <input id="fact-b" type="range" min="-2" max="2" step="0.2" value="-0.7">
              </div>
              <div class="control-row">
                <label>Interaction effect</label>
                <input id="fact-int" type="range" min="-2" max="2" step="0.2" value="0.4">
              </div>
              <div class="control-row">
                <label>Sample size per cell</label>
                <input id="fact-n" type="number" min="10" max="200" step="5" value="25">
              </div>
              <div class="control-row">
                <label>Within-cell sd</label>
                <input id="fact-sd" type="range" min="0.5" max="3" step="0.1" value="1.1">
              </div>
              <div class="control-row">
                <label>&nbsp;</label>
                <button class="btn" id="fact-run" type="button">Resimulate</button>
              </div>
            </div>
            <canvas id="fact-canvas" width="820" height="230" aria-label="Factorial ANOVA means"></canvas>
            <div class="stats">
              <div class="stat">F(A): <span id="fact-f-a">-</span> (p <span id="fact-p-a">-</span>)</div>
              <div class="stat">F(B): <span id="fact-f-b">-</span> (p <span id="fact-p-b">-</span>)</div>
              <div class="stat">F(A×B): <span id="fact-f-int">-</span> (p <span id="fact-p-int">-</span>)</div>
              <div class="stat">Comment: <span id="fact-comment">-</span></div>
            </div>
          </li>
          <li class="topic-card">
            <h4>5. Assumptions and transformations</h4>
            <p class="small">
              Compare the raw distribution with its log transform to see how skewness changes.
            </p>
            <div class="controls grid-2">
              <div class="control-row">
                <label>Distribution</label>
                <select id="log-dist">
                  <option value="lognormal">Lognormal</option>
                  <option value="exponential">Exponential</option>
                  <option value="normal">Normal</option>
                </select>
              </div>
              <div class="control-row">
                <label>Sample size</label>
                <input id="log-n" type="number" min="50" max="2000" step="50" value="400">
              </div>
              <div class="control-row">
                <label>&nbsp;</label>
                <button class="btn" id="log-run" type="button">Resimulate</button>
              </div>
            </div>
            <div class="grid-2">
              <canvas id="log-raw" width="400" height="220" aria-label="Raw distribution"></canvas>
              <canvas id="log-trans" width="400" height="220" aria-label="Log-transformed distribution"></canvas>
            </div>
            <div class="mini-check" data-answer="a">
              <label>Quick check: a log transform often reduces...</label>
              <select>
                <option value="">Choose an answer</option>
                <option value="a">Right skewness</option>
                <option value="b">Left skewness only</option>
                <option value="c">All variance</option>
                <option value="d">Sample size</option>
              </select>
              <button class="btn secondary check-btn" type="button">Check</button>
              <div class="feedback" aria-live="polite"></div>
            </div>
          </li>
        </ol>
      </section>

      <section class="section">
        <div class="card">
          <h3>Interactive 1: Pick an experimental design</h3>
          <p class="callout">
            Experiments differ in how subjects experience treatment and control.
            Select a design to see its strengths and risks.
          </p>
          <div class="controls">
            <div class="control-row">
              <label for="design-select">Design type</label>
              <select id="design-select">
                <option value="between">Between-subjects</option>
                <option value="within">Within-subjects</option>
                <option value="mixed">Mixed (difference-in-differences)</option>
              </select>
            </div>
          </div>
          <div class="stats">
            <div class="stat">
              <strong>When to use</strong>
              <div id="design-when" class="small"></div>
            </div>
            <div class="stat">
              <strong>Key risks</strong>
              <div id="design-risk" class="small"></div>
            </div>
            <div class="stat">
              <strong>Checklist focus</strong>
              <div id="design-check" class="small"></div>
            </div>
          </div>
        </div>

      </section>

      <section class="section" id="quick-check">
        <div class="card">
          <h3>Quick check</h3>
          <div class="quiz" data-answer="b">
            <strong>1) Which causality criterion ensures the cause comes first?</strong>
            <label><input type="radio" name="q1" value="a"> Covariance.</label>
            <label><input type="radio" name="q1" value="b"> Temporal precedence.</label>
            <label><input type="radio" name="q1" value="c"> Random assignment.</label>
            <label><input type="radio" name="q1" value="d"> Blinding.</label>
            <button class="btn secondary check-btn">Check</button>
            <div class="feedback" aria-live="polite"></div>
          </div>

          <div class="quiz" data-answer="a">
            <strong>2) Experiments are best suited for:</strong>
            <label><input type="radio" name="q2" value="a"> Causal questions with manipulable IVs.</label>
            <label><input type="radio" name="q2" value="b"> Purely descriptive summaries.</label>
            <label><input type="radio" name="q2" value="c"> Correlations only.</label>
            <label><input type="radio" name="q2" value="d"> Historical narratives.</label>
            <button class="btn secondary check-btn">Check</button>
            <div class="feedback" aria-live="polite"></div>
          </div>

          <div class="quiz" data-answer="a">
            <strong>3) The manipulation creates the:</strong>
            <label><input type="radio" name="q3" value="a"> Treatment state.</label>
            <label><input type="radio" name="q3" value="b"> Dependent variable.</label>
            <label><input type="radio" name="q3" value="c"> Sample frame.</label>
            <label><input type="radio" name="q3" value="d"> Random seed.</label>
            <button class="btn secondary check-btn">Check</button>
            <div class="feedback" aria-live="polite"></div>
          </div>

          <div class="quiz" data-answer="b">
            <strong>4) Which design uses the same participants in each condition?</strong>
            <label><input type="radio" name="q4" value="a"> Between-subjects.</label>
            <label><input type="radio" name="q4" value="b"> Within-subjects.</label>
            <label><input type="radio" name="q4" value="c"> Clustered.</label>
            <label><input type="radio" name="q4" value="d"> Cross-sectional.</label>
            <button class="btn secondary check-btn">Check</button>
            <div class="feedback" aria-live="polite"></div>
          </div>

          <div class="quiz" data-answer="a">
            <strong>5) In the music example, the dependent variable is:</strong>
            <label><input type="radio" name="q5" value="a"> Reaction time.</label>
            <label><input type="radio" name="q5" value="b"> Music genre preference.</label>
            <label><input type="radio" name="q5" value="c"> Age of participant.</label>
            <label><input type="radio" name="q5" value="d"> Sampling method.</label>
            <button class="btn secondary check-btn">Check</button>
            <div class="feedback" aria-live="polite"></div>
          </div>

          <div class="quiz" data-answer="c">
            <strong>6) Which step directly reduces confounds?</strong>
            <label><input type="radio" name="q6" value="a"> Convenience sampling.</label>
            <label><input type="radio" name="q6" value="b"> Manipulation check.</label>
            <label><input type="radio" name="q6" value="c"> Random assignment.</label>
            <label><input type="radio" name="q6" value="d"> Larger alpha.</label>
            <button class="btn secondary check-btn">Check</button>
            <div class="feedback" aria-live="polite"></div>
          </div>

          <div class="quiz" data-answer="a">
            <strong>7) DV checks focus on whether the task:</strong>
            <label><input type="radio" name="q7" value="a"> Measures the outcome properly.</label>
            <label><input type="radio" name="q7" value="b"> Is cheap to run.</label>
            <label><input type="radio" name="q7" value="c"> Has a large sample.</label>
            <label><input type="radio" name="q7" value="d"> Is blinded.</label>
            <button class="btn secondary check-btn">Check</button>
            <div class="feedback" aria-live="polite"></div>
          </div>

          <div class="quiz" data-answer="b">
            <strong>8) If deception is used, you must:</strong>
            <label><input type="radio" name="q8" value="a"> Skip debriefing.</label>
            <label><input type="radio" name="q8" value="b"> Debrief participants.</label>
            <label><input type="radio" name="q8" value="c"> Hide the consent form.</label>
            <label><input type="radio" name="q8" value="d"> Increase sample size.</label>
            <button class="btn secondary check-btn">Check</button>
            <div class="feedback" aria-live="polite"></div>
          </div>

          <div class="quiz" data-answer="a">
            <strong>9) A manipulation check tests whether:</strong>
            <label><input type="radio" name="q9" value="a"> The manipulation worked.</label>
            <label><input type="radio" name="q9" value="b"> The sample is random.</label>
            <label><input type="radio" name="q9" value="c"> The data are normal.</label>
            <label><input type="radio" name="q9" value="d"> The effect is causal.</label>
            <button class="btn secondary check-btn">Check</button>
            <div class="feedback" aria-live="polite"></div>
          </div>

          <div class="quiz" data-answer="b">
            <strong>10) A field experiment has:</strong>
            <label><input type="radio" name="q10" value="a"> Artificial setting and artificial manipulation.</label>
            <label><input type="radio" name="q10" value="b"> Natural setting with researcher manipulation.</label>
            <label><input type="radio" name="q10" value="c"> Natural setting with no manipulation.</label>
            <label><input type="radio" name="q10" value="d"> Artificial setting with no manipulation.</label>
            <button class="btn secondary check-btn">Check</button>
            <div class="feedback" aria-live="polite"></div>
          </div>

          <div class="quiz" data-answer="a">
            <strong>11) Analysis begins by comparing:</strong>
            <label><input type="radio" name="q11" value="a"> Treatment vs control outcomes.</label>
            <label><input type="radio" name="q11" value="b"> Only the treatment group.</label>
            <label><input type="radio" name="q11" value="c"> Only the control group.</label>
            <label><input type="radio" name="q11" value="d"> Only covariates.</label>
            <button class="btn secondary check-btn">Check</button>
            <div class="feedback" aria-live="polite"></div>
          </div>

          <div class="quiz" data-answer="c">
            <strong>12) ANOVA is used when you compare:</strong>
            <label><input type="radio" name="q12" value="a"> Two means only.</label>
            <label><input type="radio" name="q12" value="b"> A single mean to zero.</label>
            <label><input type="radio" name="q12" value="c"> Three or more group means.</label>
            <label><input type="radio" name="q12" value="d"> Only variances.</label>
            <button class="btn secondary check-btn">Check</button>
            <div class="feedback" aria-live="polite"></div>
          </div>

          <div class="quiz" data-answer="a">
            <strong>13) For formal inference of two means, use a:</strong>
            <label><input type="radio" name="q13" value="a"> t-test.</label>
            <label><input type="radio" name="q13" value="b"> Visual heuristic only.</label>
            <label><input type="radio" name="q13" value="c"> Correlation coefficient.</label>
            <label><input type="radio" name="q13" value="d"> Randomization check.</label>
            <button class="btn secondary check-btn">Check</button>
            <div class="feedback" aria-live="polite"></div>
          </div>

          <div class="quiz" data-answer="b">
            <strong>14) Which step directly reduces confounds between groups?</strong>
            <label><input type="radio" name="q14" value="a"> Blinding participants.</label>
            <label><input type="radio" name="q14" value="b"> Random assignment.</label>
            <label><input type="radio" name="q14" value="c"> Increasing sample size.</label>
            <label><input type="radio" name="q14" value="d"> Switching to correlational data.</label>
            <button class="btn secondary check-btn">Check</button>
            <div class="feedback" aria-live="polite"></div>
          </div>

          <div class="quiz" data-answer="c">
            <strong>15) ANOVA is used when you compare:</strong>
            <label><input type="radio" name="q15" value="a"> Two means only.</label>
            <label><input type="radio" name="q15" value="b"> A single mean to zero.</label>
            <label><input type="radio" name="q15" value="c"> Three or more group means.</label>
            <label><input type="radio" name="q15" value="d"> Only variances.</label>
            <button class="btn secondary check-btn">Check</button>
            <div class="feedback" aria-live="polite"></div>
          </div>

          <div class="quiz" data-answer="a">
            <strong>16) A p-value answers which question?</strong>
            <label><input type="radio" name="q16" value="a"> How likely our data are if the null hypothesis is true.</label>
            <label><input type="radio" name="q16" value="b"> The probability the null hypothesis is true.</label>
            <label><input type="radio" name="q16" value="c"> The size of the treatment effect.</label>
            <label><input type="radio" name="q16" value="d"> The sample size requirement.</label>
            <button class="btn secondary check-btn">Check</button>
            <div class="feedback" aria-live="polite"></div>
          </div>
        </div>
      </section>

      <section class="section card" id="case-study">
        <h3>Case study: Does music improve concentration?</h3>
        <p>
          You run a lab experiment where participants complete a reaction-time task under
          three conditions: no music, low volume, and high volume. You measure reaction
          times in milliseconds.
        </p>
        <ul>
          <li>Confirm random assignment and check for balance on covariates.</li>
          <li>Use ANOVA to test if any group differs from the others.</li>
          <li>If ANOVA is significant, run post-hoc tests to locate differences.</li>
          <li>Report effect sizes and confidence intervals, not just p-values.</li>
        </ul>
        <p class="small">
          This mirrors the experimental checklist and analysis flow from the slides.
        </p>
      </section>

      <section class="section card" id="r-section">
        <h3>Interactive R test bench: t-test and ANOVA</h3>
        <p class="callout">
          Simulate experimental data, then run a t-test or ANOVA depending on the number of groups.
          Use this to connect design choices with statistical output.
        </p>
        <ul>
          <li>Start with 3 groups to see ANOVA and Tukey post-hoc results.</li>
          <li>Switch to 2 groups to see how the output changes to a t-test.</li>
          <li>Increase the effect size or sample size and track p-values.</li>
          <li>Compare the boxplot and mean differences with the test output.</li>
        </ul>
        <div class="bench">
          <div class="grid-2">
            <div class="control-row">
              <label>Groups (2 or 3)</label>
              <input id="r-groups" type="number" min="2" max="3" step="1" value="3">
            </div>
            <div class="control-row">
              <label>Sample size per group</label>
              <input id="r-n" type="number" min="10" max="200" step="5" value="40">
            </div>
            <div class="control-row">
              <label>Baseline mean</label>
              <input id="r-mu" type="number" min="100" max="700" step="10" value="420">
            </div>
            <div class="control-row">
              <label>Effect increment per group</label>
              <input id="r-step" type="number" min="0" max="100" step="5" value="25">
            </div>
            <div class="control-row">
              <label>Standard deviation (sigma)</label>
              <input id="r-sd" type="number" min="10" max="200" step="10" value="60">
            </div>
          </div>
          <div class="controls">
            <button class="btn secondary" id="r-build">Update R code</button>
          </div>
          <textarea id="r-code" spellcheck="false"></textarea>
          <div class="controls">
            <button class="btn" id="r-run" disabled>Run R</button>
            <button class="btn secondary" id="r-reset">Reset</button>
          </div>
          <div class="bench-output">
            <pre id="r-output">Loading webR, please wait...</pre>
            <canvas id="r-plot" width="900" height="520"></canvas>
          </div>
        </div>
      </section>

    </main>
    <footer class="container">© 2026 Francesco Balocco.</footer>

    <script type="module">
      const byId = (id) => document.getElementById(id);

      function fmt(num, digits = 2) {
        return Number(num).toFixed(digits);
      }

      function typesetMath(el) {
        if (window.MathJax && window.MathJax.typesetPromise) {
          window.MathJax.typesetPromise(el ? [el] : undefined);
        }
      }

      function drawAxes(ctx, width, height, padding) {
        ctx.strokeStyle = "#cbd5f6";
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(padding, height - padding);
        ctx.lineTo(width - padding, height - padding);
        ctx.moveTo(padding, height - padding);
        ctx.lineTo(padding, padding);
        ctx.stroke();
      }

      function setupViewSettings() {
        const cards = Array.from(
          document.querySelectorAll(".topic-card, section.card, section#quick-check")
        );
        if (!cards.length) return;
        const crumbEl = document.querySelector(".breadcrumbs");
        const crumbText = crumbEl ? crumbEl.textContent : "";
        const hasSlash = crumbText.indexOf("/") !== -1;
        const sessionLabel = hasSlash ? crumbText.split("/").pop().trim() : crumbText.trim();
        const headingEl = document.querySelector("header h1");
        const sessionHeading = headingEl && headingEl.textContent ? headingEl.textContent.trim() : "";
        const sessionTitle = [sessionLabel, sessionHeading].filter(Boolean).join(" - ");
        const sessionPrefix = sessionTitle ? `${sessionTitle}. ` : "";
        const header = document.querySelector("header");
        const progressBar = byId("progress-bar");
        const progressText = byId("progress-text");
        const prevBtn = byId("prev-card");
        const nextBtn = byId("next-card");
        const settingsBtn = byId("settings-btn");
        const panel = byId("settings-panel");
        const modeInputs = Array.from(document.querySelectorAll("input[name='view-mode']"));
        let index = 0;
        const total = cards.length;

        function updateSplitPaneHeight() {
          if (!document.body.classList.contains("view-mode-single")) return;
          const topbar = document.querySelector(".topbar");
          const topbarH = topbar ? topbar.getBoundingClientRect().height : 0;
          // Leave room for margins/padding and a small amount of page chrome.
          const h = Math.max(320, window.innerHeight - topbarH - 140);
          document.documentElement.style.setProperty("--split-pane-height", `${h}px`);
        }

        function setMode(mode) {
          localStorage.setItem("viewMode", mode);
          modeInputs.forEach((input) => {
            input.checked = input.value === mode;
          });
          document.body.classList.toggle("view-mode-single", mode === "single");
          document.body.classList.toggle("view-mode-all", mode === "all");
          updateSplitPaneHeight();
          update();
        }

        function update() {
          const checkedInput = modeInputs.find((input) => input.checked);
          const mode = checkedInput ? checkedInput.value : "all";
          cards.forEach((card, i) => {
            const visible = mode === "all" || i === index;
            card.style.display = visible ? "" : "none";
          });
          prevBtn.disabled = mode === "all" || index === 0;
          nextBtn.disabled = mode === "all" || index === total - 1;
          const progress = mode === "all" ? 100 : ((index + 1) / total) * 100;
          progressBar.style.width = `${progress}%`;
          progressText.textContent =
            mode === "all"
              ? `${sessionPrefix}All cards (${total})`
              : `${sessionPrefix}Card ${index + 1} of ${total}`;
          if (header) {
            header.style.display = mode === "all" || index === 0 ? "" : "none";
          }
          updateSplitPaneHeight();
        }

        prevBtn.addEventListener("click", () => {
          index = Math.max(0, index - 1);
          update();
        });
        nextBtn.addEventListener("click", () => {
          index = Math.min(total - 1, index + 1);
          update();
        });
        settingsBtn.addEventListener("click", () => {
          panel.classList.toggle("open");
        });
        document.addEventListener("click", (event) => {
          if (!panel.contains(event.target) && event.target !== settingsBtn) {
            panel.classList.remove("open");
          }
        });
        modeInputs.forEach((input) => input.addEventListener("change", () => setMode(input.value)));
        window.addEventListener("resize", updateSplitPaneHeight);

        const savedMode = localStorage.getItem("viewMode") || "all";
        setMode(savedMode);
      }

      function reorderSections() {
        const main = document.querySelector("main");
        const quick = byId("quick-check");

        const designSelect = byId("design-select");
        const designSection = designSelect ? designSelect.closest("section") : null;
        if (designSection && quick) {
          const designCard = designSection.querySelector(".card");
          const quickCard = quick.querySelector(".card");
          if (designCard && quickCard) {
            const title = designCard.querySelector("h3");
            if (title) {
              const heading = document.createElement("h4");
              heading.textContent = title.textContent;
              quickCard.appendChild(heading);
              title.remove();
            }
            Array.from(designCard.children).forEach((child) => quickCard.appendChild(child));
            designSection.remove();
          }
        }

        const caseCard = buildCaseStudyCard();
        if (caseCard) main.appendChild(caseCard);
        if (quick) main.appendChild(quick);
      }

      function buildCaseStudyCard() {
        const caseSection = byId("case-study");
        const rSection = byId("r-section");
        if (!caseSection || !rSection) return null;
        const card = document.createElement("section");
        card.className = "section card";
        card.id = "case-study-card";
        const grid = document.createElement("div");
        grid.className = "card-grid";
        const left = document.createElement("div");
        left.className = "card-left";
        const right = document.createElement("div");
        right.className = "card-right";

        const title = caseSection.querySelector("h3");
        if (title) left.appendChild(title);
        Array.from(caseSection.children).forEach((child) => {
          if (child !== title) left.appendChild(child);
        });

        const intro = document.createElement("p");
        intro.className = "exercise-intro";
        intro.textContent = "How to use: adjust parameters, update the R code, then run it to see outputs.";
        right.appendChild(intro);
        Array.from(rSection.children).forEach((child) => {
          if (child.tagName !== "H3") right.appendChild(child);
        });

        grid.appendChild(left);
        grid.appendChild(right);
        card.appendChild(grid);
        caseSection.remove();
        rSection.remove();
        return card;
      }

      function setupTheoryCards() {
        const list = document.querySelector(".topic-list");
        if (!list) return;
        const section = list.closest("section");
        if (section) {
          const heading = section.querySelector("h3");
          const note = section.querySelector(":scope > p.small");
          if (heading) heading.remove();
          if (note) note.remove();
          section.classList.remove("card");
        }

        const theory = [
          "When comparing two groups, we test whether the <em>average</em> outcomes differ: \\(H_0: \\mu_A-\\mu_B=0\\). The test statistic is the estimated difference divided by its standard error, \\(t\\approx\\frac{\\bar{x}_A-\\bar{x}_B}{SE(\\bar{x}_A-\\bar{x}_B)}\\). The <strong>p-value</strong> is the probability (assuming \\(H_0\\) is true) of seeing a difference at least as extreme as the one observed. A two-sided confidence interval for \\(\\mu_A-\\mu_B\\) that excludes 0 corresponds to a small p-value (and vice versa).",
          "A mean difference is an <em>estimate</em>; inference adds uncertainty. Standard errors get smaller with larger \\(n\\) and larger with more variability. That is why you can have (i) a large-looking difference that is not statistically clear with noisy small samples, or (ii) a tiny difference that is statistically significant with huge samples. Always pair a p-value with an effect size and a confidence interval.",
          "With 3+ groups, one-way ANOVA tests \\(H_0:\\mu_1=\\mu_2=\\mu_3\\) using \\(F=MS_{between}/MS_{within}\\), i.e., “variation between group means” relative to “variation within groups”. A significant ANOVA says <em>at least one</em> mean differs; it does not say which. Post-hoc tests (e.g., Tukey) compare pairs while controlling the family-wise error rate.",
          "Factorial ANOVA studies <em>main effects</em> (average differences for each factor) and <em>interaction</em> (the effect of one factor depends on the level of the other). In a means plot, perfectly parallel lines suggest additivity (no interaction); non-parallel lines suggest an interaction, which you interpret via simple effects (differences within each level).",
          "Common assumptions for mean comparisons are independence, roughly normal errors (especially for small \\(n\\)), and similar variances across groups. Transformations like \\(\\log(1+y)\\) can reduce right-skew and stabilize variance, but they also change interpretation (differences become more “multiplicative” on the original scale). If variances differ strongly, consider robust alternatives (e.g., Welch’s t-test / Welch ANOVA) rather than forcing a transformation."
        ];
        const intros = [
          "How to use: simulate two groups, adjust sample sizes and variance, and watch the t-test output update.",
          "How to use: compare means visually, then use the test output to interpret statistical evidence.",
          "How to use: choose group means and sample size, then inspect F, p-values, and Tukey results.",
          "How to use: move factor means to see main effects and interaction patterns.",
          "How to use: sample from different distributions and compare raw vs log-transformed histograms."
        ];

        function stripInteractivePrefix(text) {
          const trimmed = text.trim();
          const lower = trimmed.toLowerCase();
          const prefix = "interactive";
          if (lower.indexOf(prefix) === 0) {
            return trimmed.slice(prefix.length).trim();
          }
          return trimmed;
        }

        function stripLeadingNumbering(text) {
          let s = text.trim();
          let changed = true;
          while (changed) {
            changed = false;
            let i = 0;
            while (i < s.length && s[i] >= "0" && s[i] <= "9") i += 1;
            if (i === 0) break;
            while (i < s.length && (s[i] === " " || s[i] === "\t")) i += 1;
            while (i < s.length && (s[i] === "." || s[i] === "-" || s[i] === ":")) {
              i += 1;
              while (i < s.length && (s[i] === " " || s[i] === "\t")) i += 1;
            }
            s = s.slice(i).trim();
            changed = true;
          }
          while (
            s.length &&
            (s[0] === "." || s[0] === "-" || s[0] === ":" || s[0] === " " || s[0] === "\t")
          ) {
            s = s.slice(1).trim();
          }
          return s;
        }

        const cards = Array.from(list.querySelectorAll(".topic-card"));
        cards.forEach((card, i) => {
          const title = card.querySelector("h4");
          if (!title) return;
          const originalTitle = title.textContent.trim();
          let displayNumber = "";
          for (let k = 0; k < originalTitle.length; k += 1) {
            const ch = originalTitle[k];
            if (ch >= "0" && ch <= "9") displayNumber += ch;
            else if (!displayNumber && (ch === " " || ch === "\\t")) continue;
            else break;
          }
          if (!displayNumber) displayNumber = String(i + 1);
          let cleanTitle = stripInteractivePrefix(originalTitle);
          cleanTitle = stripLeadingNumbering(cleanTitle);
          title.textContent = `${displayNumber}. ${cleanTitle}`;
          card.dataset.cardNumber = displayNumber;
          card.dataset.cardTitle = cleanTitle;

          let content = Array.from(card.children).filter((el) => el !== title);
          const grid = document.createElement("div");
          grid.className = "card-grid";
          const left = document.createElement("div");
          left.className = "card-left";
          const right = document.createElement("div");
          right.className = "card-right";
          const theoryEl = document.createElement("div");
          theoryEl.className = "theory";
          theoryEl.innerHTML = theory[i] || "";
          const introEl = document.createElement("p");
          introEl.className = "exercise-intro";
          introEl.innerHTML = intros[i] || "";

          left.appendChild(title);
          left.appendChild(theoryEl);
          const firstPracticeCard = content.find(
            (el) => el.classList && el.classList.contains("card")
          );
          let firstPracticeTitle = "";
          if (firstPracticeCard) {
            const h3 = firstPracticeCard.querySelector("h3");
            firstPracticeTitle = h3 && h3.textContent ? h3.textContent : "";
          }

          // Session 3 card 2: keep "How to use" + intro text inside the sandbox card.
          if (firstPracticeCard && /mean comparison sandbox/i.test(firstPracticeTitle)) {
            const callout = firstPracticeCard.querySelector(".callout");
            const moved = [introEl, ...content.filter((el) => el !== firstPracticeCard)];
            moved.forEach((el) => {
              if (callout) firstPracticeCard.insertBefore(el, callout);
              else firstPracticeCard.appendChild(el);
            });
            content = [firstPracticeCard];
          } else {
            right.appendChild(introEl);
          }

          content.forEach((el) => right.appendChild(el));
          grid.appendChild(left);
          grid.appendChild(right);
          card.innerHTML = "";
          card.appendChild(grid);
        });
        typesetMath(list);
      }

      function normalSample(mu, sigma) {
        const u1 = Math.random();
        const u2 = Math.random();
        const z = Math.sqrt(-2 * Math.log(u1)) * Math.cos(2 * Math.PI * u2);
        return mu + sigma * z;
      }

      function erf(x) {
        const sign = x >= 0 ? 1 : -1;
        const absX = Math.abs(x);
        const a1 = 0.254829592;
        const a2 = -0.284496736;
        const a3 = 1.421413741;
        const a4 = -1.453152027;
        const a5 = 1.061405429;
        const p = 0.3275911;
        const t = 1 / (1 + p * absX);
        const y =
          1 -
          (((((a5 * t + a4) * t + a3) * t + a2) * t + a1) * t) *
            Math.exp(-absX * absX);
        return sign * y;
      }

      function normalPDF(x, mu, sigma) {
        const z = (x - mu) / sigma;
        return (1 / (sigma * Math.sqrt(2 * Math.PI))) * Math.exp(-0.5 * z * z);
      }

      function normalCDF(x, mu, sigma) {
        const z = (x - mu) / (sigma * Math.sqrt(2));
        return 0.5 * (1 + erf(z));
      }

      function normalInv(p) {
        let low = -6;
        let high = 6;
        for (let i = 0; i < 60; i += 1) {
          const mid = (low + high) / 2;
          const cdf = normalCDF(mid, 0, 1);
          if (cdf < p) low = mid;
          else high = mid;
        }
        return (low + high) / 2;
      }

      let hypoState = null;
      let onewayState = null;

      function tTestStats(a, b) {
        const n1 = a.length;
        const n2 = b.length;
        const mean1 = a.reduce((s, v) => s + v, 0) / n1;
        const mean2 = b.reduce((s, v) => s + v, 0) / n2;
        const var1 = a.reduce((s, v) => s + (v - mean1) ** 2, 0) / (n1 - 1);
        const var2 = b.reduce((s, v) => s + (v - mean2) ** 2, 0) / (n2 - 1);
        const se = Math.sqrt(var1 / n1 + var2 / n2);
        const t = (mean1 - mean2) / se;
        const p = 2 * (1 - normalCDF(Math.abs(t), 0, 1));
        const z = 1.96;
        const ci1 = [mean1 - z * Math.sqrt(var1 / n1), mean1 + z * Math.sqrt(var1 / n1)];
        const ci2 = [mean2 - z * Math.sqrt(var2 / n2), mean2 + z * Math.sqrt(var2 / n2)];
        return { mean1, mean2, var1, var2, t, p, ci1, ci2 };
      }

      function anovaStats(groups) {
        const k = groups.length;
        const sizes = groups.map((g) => g.length);
        const means = groups.map((g) => g.reduce((s, v) => s + v, 0) / g.length);
        const totalN = sizes.reduce((s, v) => s + v, 0);
        const grandMean =
          groups.reduce((s, g) => s + g.reduce((ss, v) => ss + v, 0), 0) / totalN;
        let ssa = 0;
        let sse = 0;
        groups.forEach((g, i) => {
          ssa += sizes[i] * (means[i] - grandMean) ** 2;
          sse += g.reduce((s, v) => s + (v - means[i]) ** 2, 0);
        });
        const dfA = k - 1;
        const dfE = totalN - k;
        const msa = ssa / dfA;
        const mse = sse / dfE;
        const f = msa / mse;
        return { f, dfA, dfE, mse, means, sizes };
      }

      function approxFPvalue(f, df1, df2, sims = 400) {
        let count = 0;
        for (let i = 0; i < sims; i += 1) {
          let chi1 = 0;
          let chi2 = 0;
          for (let j = 0; j < df1; j += 1) {
            const z = normalSample(0, 1);
            chi1 += z * z;
          }
          for (let j = 0; j < df2; j += 1) {
            const z = normalSample(0, 1);
            chi2 += z * z;
          }
          const fSim = (chi1 / df1) / (chi2 / df2);
          if (fSim >= f) count += 1;
        }
        return count / sims;
      }

      function setupDesignPicker() {
        const select = byId("design-select");
        const whenOut = byId("design-when");
        const riskOut = byId("design-risk");
        const checkOut = byId("design-check");

        const info = {
          between: {
            when: "Different participants in treatment and control.",
            risk: "Group imbalance if randomization is weak.",
            check: "Random assignment and manipulation checks."
          },
          within: {
            when: "Same participants experience multiple conditions.",
            risk: "Carryover or fatigue effects across conditions.",
            check: "Counterbalancing order and washout periods."
          },
          mixed: {
            when: "Combine pre/post with treatment/control.",
            risk: "Assumptions about parallel trends.",
            check: "Baseline balance and timing of treatment."
          }
        };

        function update() {
          const key = select.value;
          whenOut.textContent = info[key].when;
          riskOut.textContent = info[key].risk;
          checkOut.textContent = info[key].check;
        }

        select.addEventListener("change", update);
        update();
      }

      function setupMeanSim() {
        const nInput = byId("sim-n");
        const diffInput = byId("sim-diff");
        const sdInput = byId("sim-sd");
        const nLabel = byId("sim-n-label");
        const diffLabel = byId("sim-diff-label");
        const sdLabel = byId("sim-sd-label");
        const runBtn = byId("sim-run");
        const meanAOut = byId("sim-mean-a");
        const meanBOut = byId("sim-mean-b");
        const overlapOut = byId("sim-overlap");
        const canvas = byId("sim-canvas");
        const ctx = canvas.getContext("2d");

        function updateLabels() {
          nLabel.textContent = nInput.value;
          diffLabel.textContent = fmt(diffInput.value, 2);
          sdLabel.textContent = fmt(sdInput.value, 1);
        }

        function drawBars(meanA, meanB, ciA, ciB) {
          ctx.clearRect(0, 0, canvas.width, canvas.height);
          const padding = 60;
          drawAxes(ctx, canvas.width, canvas.height, padding);
          const minX = Math.min(ciA[0], ciB[0]) - 1;
          const maxX = Math.max(ciA[1], ciB[1]) + 1;
          const scale = (x) =>
            padding + ((x - minX) / (maxX - minX)) * (canvas.width - 2 * padding);

          const yA = canvas.height / 2 - 40;
          const yB = canvas.height / 2 + 40;

          ctx.strokeStyle = "#cbd5f6";
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.moveTo(padding, canvas.height / 2);
          ctx.lineTo(canvas.width - padding, canvas.height / 2);
          ctx.stroke();

          const drawCI = (y, mean, ci, color) => {
            ctx.strokeStyle = color;
            ctx.lineWidth = 4;
            ctx.beginPath();
            ctx.moveTo(scale(ci[0]), y);
            ctx.lineTo(scale(ci[1]), y);
            ctx.stroke();
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.arc(scale(mean), y, 6, 0, Math.PI * 2);
            ctx.fill();
          };

          drawCI(yA, meanA, ciA, "#2563eb");
          drawCI(yB, meanB, ciB, "#f97316");
        }

        function simulate() {
          const n = Number(nInput.value);
          const diff = Number(diffInput.value);
          const sigma = Number(sdInput.value);
          const muA = 0;
          const muB = muA + diff;
          const dataA = Array.from({ length: n }, () => normalSample(muA, sigma));
          const dataB = Array.from({ length: n }, () => normalSample(muB, sigma));
          const meanA = dataA.reduce((s, v) => s + v, 0) / n;
          const meanB = dataB.reduce((s, v) => s + v, 0) / n;
          const varA = dataA.reduce((s, v) => s + (v - meanA) ** 2, 0) / (n - 1);
          const varB = dataB.reduce((s, v) => s + (v - meanB) ** 2, 0) / (n - 1);
          const z = 1.96;
          const ciA = [meanA - z * Math.sqrt(varA / n), meanA + z * Math.sqrt(varA / n)];
          const ciB = [meanB - z * Math.sqrt(varB / n), meanB + z * Math.sqrt(varB / n)];
          const overlap = !(ciA[1] < ciB[0] || ciB[1] < ciA[0]);

          meanAOut.textContent = fmt(meanA, 2);
          meanBOut.textContent = fmt(meanB, 2);
          overlapOut.textContent = overlap ? "Yes" : "No";
          drawBars(meanA, meanB, ciA, ciB);
        }

        nInput.addEventListener("input", updateLabels);
        diffInput.addEventListener("input", updateLabels);
        sdInput.addEventListener("input", updateLabels);
        runBtn.addEventListener("click", simulate);

        updateLabels();
        simulate();
      }

      function drawHypoCanvas(state) {
        const canvas = byId("hypo-canvas");
        const ctx = canvas.getContext("2d");
        const padding = 40;
        const w = canvas.width;
        const h = canvas.height;
        const sd1 = Math.sqrt(state.var1);
        const sd2 = Math.sqrt(state.var2);
        const minX = Math.min(state.mean1 - 4 * sd1, state.mean2 - 4 * sd2);
        const maxX = Math.max(state.mean1 + 4 * sd1, state.mean2 + 4 * sd2);
        const maxPdf = Math.max(normalPDF(state.mean1, state.mean1, sd1), normalPDF(state.mean2, state.mean2, sd2));

        const scaleX = (x) => padding + ((x - minX) / (maxX - minX)) * (w - 2 * padding);
        const scaleY = (y) => h - padding - (y / maxPdf) * (h - 2 * padding) * 0.9;

        ctx.clearRect(0, 0, w, h);
        drawAxes(ctx, w, h, padding);

        const drawCurve = (mu, sd, color) => {
          ctx.strokeStyle = color;
          ctx.lineWidth = 2.5;
          ctx.beginPath();
          for (let i = 0; i <= 120; i += 1) {
            const x = minX + (i / 120) * (maxX - minX);
            const y = normalPDF(x, mu, sd);
            if (i === 0) ctx.moveTo(scaleX(x), scaleY(y));
            else ctx.lineTo(scaleX(x), scaleY(y));
          }
          ctx.stroke();
        };

        drawCurve(state.mean1, sd1, "#2563eb");
        drawCurve(state.mean2, sd2, "#f97316");

        const drawCI = (ci, y, color) => {
          ctx.strokeStyle = color;
          ctx.lineWidth = 4;
          ctx.beginPath();
          ctx.moveTo(scaleX(ci[0]), y);
          ctx.lineTo(scaleX(ci[1]), y);
          ctx.stroke();
        };

        drawCI(state.ci1, h - padding + 10, "#2563eb");
        drawCI(state.ci2, h - padding + 24, "#f97316");

        ctx.strokeStyle = "#0f172a";
        ctx.lineWidth = 1.5;
        ctx.beginPath();
        ctx.moveTo(scaleX(state.mean1), padding);
        ctx.lineTo(scaleX(state.mean1), h - padding);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(scaleX(state.mean2), padding);
        ctx.lineTo(scaleX(state.mean2), h - padding);
        ctx.stroke();
      }

      function updateTTestPlot() {
        if (!hypoState) return;
        const alphaInput = byId("ttest-alpha");
        const alphaLabel = byId("ttest-alpha-label");
        const tOut = byId("ttest-t");
        const pOut = byId("ttest-p");
        const critOut = byId("ttest-crit");
        const decisionOut = byId("ttest-decision");
        const canvas = byId("ttest-canvas");
        const ctx = canvas.getContext("2d");

        const tVal = hypoState.t;
        const pVal = hypoState.p;
        const alpha = Number(alphaInput.value);
        const crit = normalInv(1 - alpha / 2);

        alphaLabel.textContent = fmt(alpha, 2);
        tOut.textContent = fmt(tVal, 2);
        pOut.textContent = fmt(pVal, 3);
        critOut.textContent = fmt(crit, 2);
        decisionOut.textContent = Math.abs(tVal) > crit ? "Reject H0" : "Fail to reject H0";

        const padding = 40;
        const w = canvas.width;
        const h = canvas.height;
        const minX = -4;
        const maxX = 4;
        const maxPdf = normalPDF(0, 0, 1);
        const scaleX = (x) => padding + ((x - minX) / (maxX - minX)) * (w - 2 * padding);
        const scaleY = (y) => h - padding - (y / maxPdf) * (h - 2 * padding) * 0.9;

        ctx.clearRect(0, 0, w, h);
        drawAxes(ctx, w, h, padding);

        ctx.strokeStyle = "#2563eb";
        ctx.lineWidth = 2.5;
        ctx.beginPath();
        for (let i = 0; i <= 120; i += 1) {
          const x = minX + (i / 120) * (maxX - minX);
          const y = normalPDF(x, 0, 1);
          if (i === 0) ctx.moveTo(scaleX(x), scaleY(y));
          else ctx.lineTo(scaleX(x), scaleY(y));
        }
        ctx.stroke();

        const tailFill = (startX, endX) => {
          ctx.fillStyle = "rgba(244, 63, 94, 0.25)";
          ctx.beginPath();
          ctx.moveTo(scaleX(startX), h - padding);
          const steps = 60;
          for (let i = 0; i <= steps; i += 1) {
            const x = startX + (i / steps) * (endX - startX);
            const y = normalPDF(x, 0, 1);
            ctx.lineTo(scaleX(x), scaleY(y));
          }
          ctx.lineTo(scaleX(endX), h - padding);
          ctx.closePath();
          ctx.fill();
        };

        tailFill(-maxX, -crit);
        tailFill(crit, maxX);

        ctx.setLineDash([5, 4]);
        ctx.strokeStyle = "#0f172a";
        ctx.beginPath();
        ctx.moveTo(scaleX(tVal), padding);
        ctx.lineTo(scaleX(tVal), h - padding);
        ctx.stroke();
        ctx.setLineDash([]);
      }

      function setupTTestPlot() {
        const alphaInput = byId("ttest-alpha");
        alphaInput.addEventListener("input", updateTTestPlot);
        updateTTestPlot();
      }

      function updateCIRelation() {
        if (!hypoState) return;
        const canvas = byId("ci-rel-canvas");
        const ctx = canvas.getContext("2d");
        const overlapOut = byId("ci-rel-overlap");
        const pOut = byId("ci-rel-p");
        const noteOut = byId("ci-rel-note");

        const padding = 50;
        const w = canvas.width;
        const h = canvas.height;
        const minX = Math.min(hypoState.ci1[0], hypoState.ci2[0]) - 0.5;
        const maxX = Math.max(hypoState.ci1[1], hypoState.ci2[1]) + 0.5;
        const scaleX = (x) => padding + ((x - minX) / (maxX - minX)) * (w - 2 * padding);
        const yA = h / 2 - 30;
        const yB = h / 2 + 30;

        ctx.clearRect(0, 0, w, h);
        drawAxes(ctx, w, h, padding);

        const drawCI = (ci, mean, y, color) => {
          ctx.strokeStyle = color;
          ctx.lineWidth = 4;
          ctx.beginPath();
          ctx.moveTo(scaleX(ci[0]), y);
          ctx.lineTo(scaleX(ci[1]), y);
          ctx.stroke();
          ctx.fillStyle = color;
          ctx.beginPath();
          ctx.arc(scaleX(mean), y, 5, 0, Math.PI * 2);
          ctx.fill();
        };

        drawCI(hypoState.ci1, hypoState.mean1, yA, "#2563eb");
        drawCI(hypoState.ci2, hypoState.mean2, yB, "#f97316");

        const overlap = Math.max(
          0,
          Math.min(hypoState.ci1[1], hypoState.ci2[1]) -
            Math.max(hypoState.ci1[0], hypoState.ci2[0])
        );
        overlapOut.textContent = overlap > 0 ? `Yes (${fmt(overlap, 2)})` : "No";
        pOut.textContent = fmt(hypoState.p, 3);
        noteOut.textContent = hypoState.p < 0.05 ? "Often small p-value" : "Often larger p-value";
      }

      function updateTTestInterpretation() {
        if (!hypoState) return;
        const target = byId("ttest-interpretation");
        const decision = hypoState.p < 0.05 ? "reject" : "fail to reject";
        target.textContent =
          `Based on the current sample, we ${decision} the null hypothesis that the two group means are equal.`;
      }

      function setupHypothesisSim() {
        const n1Input = byId("hypo-n1");
        const n2Input = byId("hypo-n2");
        const m1Input = byId("hypo-m1");
        const m2Input = byId("hypo-m2");
        const sdInput = byId("hypo-sd");
        const runBtn = byId("hypo-run");
        const meanAOut = byId("hypo-mean-a");
        const meanBOut = byId("hypo-mean-b");
        const ciAOut = byId("hypo-ci-a");
        const ciBOut = byId("hypo-ci-b");
        const tOut = byId("hypo-t");
        const pOut = byId("hypo-p");
        const decisionOut = byId("hypo-decision");

        function simulate() {
          const n1 = Number(n1Input.value);
          const n2 = Number(n2Input.value);
          const m1 = Number(m1Input.value);
          const m2 = Number(m2Input.value);
          const sd = Number(sdInput.value);
          const groupA = Array.from({ length: n1 }, () => normalSample(m1, sd));
          const groupB = Array.from({ length: n2 }, () => normalSample(m2, sd));
          const stats = tTestStats(groupA, groupB);
          hypoState = stats;

          meanAOut.textContent = fmt(stats.mean1, 2);
          meanBOut.textContent = fmt(stats.mean2, 2);
          ciAOut.textContent = `${fmt(stats.ci1[0], 2)} to ${fmt(stats.ci1[1], 2)}`;
          ciBOut.textContent = `${fmt(stats.ci2[0], 2)} to ${fmt(stats.ci2[1], 2)}`;
          tOut.textContent = fmt(stats.t, 2);
          pOut.textContent = fmt(stats.p, 3);
          decisionOut.textContent = stats.p < 0.05 ? "Reject H0" : "Fail to reject H0";

          drawHypoCanvas(stats);
          updateTTestPlot();
          updateCIRelation();
          updateTTestInterpretation();
        }

        runBtn.addEventListener("click", simulate);
        simulate();
      }

      function setupOneWayAnova() {
        const m1Input = byId("oneway-m1");
        const m2Input = byId("oneway-m2");
        const m3Input = byId("oneway-m3");
        const nInput = byId("oneway-n");
        const sdInput = byId("oneway-sd");
        const runBtn = byId("oneway-run");
        const fOut = byId("oneway-f");
        const pOut = byId("oneway-p");
        const commentOut = byId("oneway-comment");
        const canvas = byId("oneway-canvas");
        const ctx = canvas.getContext("2d");

        function draw(groups, means) {
          const padding = 40;
          const w = canvas.width;
          const h = canvas.height;
          const all = groups.flat();
          const minX = Math.min(...all);
          const maxX = Math.max(...all);
          const scaleX = (x) => padding + ((x - minX) / (maxX - minX)) * (w - 2 * padding);
          ctx.clearRect(0, 0, w, h);
          drawAxes(ctx, w, h, padding);

          const colors = ["#60a5fa", "#fda4af", "#86efac"];
          groups.forEach((g, i) => {
            const y = padding + i * 60;
            ctx.fillStyle = colors[i];
            g.forEach((v) => {
              ctx.beginPath();
              ctx.arc(scaleX(v), y, 3, 0, Math.PI * 2);
              ctx.fill();
            });
            ctx.strokeStyle = "#0f172a";
            ctx.beginPath();
            ctx.moveTo(scaleX(means[i]), y - 8);
            ctx.lineTo(scaleX(means[i]), y + 8);
            ctx.stroke();
          });
        }

        function simulate() {
          const n = Number(nInput.value);
          const mu1 = Number(m1Input.value);
          const mu2 = Number(m2Input.value);
          const mu3 = Number(m3Input.value);
          const sd = Number(sdInput.value);
          const g1 = Array.from({ length: n }, () => normalSample(mu1, sd));
          const g2 = Array.from({ length: n }, () => normalSample(mu2, sd));
          const g3 = Array.from({ length: n }, () => normalSample(mu3, sd));
          const stats = anovaStats([g1, g2, g3]);
          const p = approxFPvalue(stats.f, stats.dfA, stats.dfE, 400);
          onewayState = { groups: [g1, g2, g3], stats, p };
          fOut.textContent = fmt(stats.f, 2);
          pOut.textContent = fmt(p, 3);
          commentOut.textContent = p < 0.05 ? "At least one mean differs." : "No clear evidence of differences.";
          draw([g1, g2, g3], stats.means);
          updateTukeySummary();
        }

        runBtn.addEventListener("click", simulate);
        simulate();
      }

      function updateTukeySummary() {
        if (!onewayState) return;
        const { stats, p } = onewayState;
        const { means, sizes, mse } = stats;
        const pairs = [
          [0, 1, "tukey-ab"],
          [0, 2, "tukey-ac"],
          [1, 2, "tukey-bc"]
        ];
        let anySig = false;
        pairs.forEach(([i, j, id]) => {
          const diff = means[i] - means[j];
          const se = Math.sqrt(mse * (1 / sizes[i] + 1 / sizes[j]));
          const t = diff / se;
          const pval = 2 * (1 - normalCDF(Math.abs(t), 0, 1));
          const el = byId(id);
          el.textContent = `${fmt(diff, 2)} (p=${fmt(pval, 3)})`;
          if (pval < 0.05) anySig = true;
        });
        const comment = byId("tukey-comment");
        comment.textContent = p < 0.05 && anySig ? "Some pairs differ significantly." : "No clear pairwise differences.";
      }

      function setupFactorialAnova() {
        const aInput = byId("fact-a");
        const bInput = byId("fact-b");
        const intInput = byId("fact-int");
        const nInput = byId("fact-n");
        const sdInput = byId("fact-sd");
        const runBtn = byId("fact-run");
        const canvas = byId("fact-canvas");
        const ctx = canvas.getContext("2d");

        function simulate() {
          const aEff = Number(aInput.value);
          const bEff = Number(bInput.value);
          const intEff = Number(intInput.value);
          const n = Number(nInput.value);
          const sd = Number(sdInput.value);
          const levels = [-0.5, 0.5];
          const cells = [];
          const means = [];
          levels.forEach((a) => {
            levels.forEach((b) => {
              const mu = 0 + aEff * a + bEff * b + intEff * a * b;
              const data = Array.from({ length: n }, () => normalSample(mu, sd));
              cells.push({ a, b, data, mean: data.reduce((s, v) => s + v, 0) / n });
              means.push(mu);
            });
          });

          const grandMean = cells.reduce((s, c) => s + c.mean, 0) / cells.length;
          const meanA = [
            (cells[0].mean + cells[1].mean) / 2,
            (cells[2].mean + cells[3].mean) / 2
          ];
          const meanB = [
            (cells[0].mean + cells[2].mean) / 2,
            (cells[1].mean + cells[3].mean) / 2
          ];
          const ssA = 2 * n * (meanA[0] - grandMean) ** 2 + 2 * n * (meanA[1] - grandMean) ** 2;
          const ssB = 2 * n * (meanB[0] - grandMean) ** 2 + 2 * n * (meanB[1] - grandMean) ** 2;
          let ssAB = 0;
          cells.forEach((c) => {
            const aIdx = c.a < 0 ? 0 : 1;
            const bIdx = c.b < 0 ? 0 : 1;
            const expected = meanA[aIdx] + meanB[bIdx] - grandMean;
            ssAB += n * (c.mean - expected) ** 2;
          });
          let sse = 0;
          cells.forEach((c) => {
            sse += c.data.reduce((s, v) => s + (v - c.mean) ** 2, 0);
          });
          const dfE = 4 * n - 4;
          const mse = sse / dfE;
          const fA = ssA / mse;
          const fB = ssB / mse;
          const fInt = ssAB / mse;
          const pA = approxFPvalue(fA, 1, dfE, 300);
          const pB = approxFPvalue(fB, 1, dfE, 300);
          const pInt = approxFPvalue(fInt, 1, dfE, 300);

          byId("fact-f-a").textContent = fmt(fA, 2);
          byId("fact-f-b").textContent = fmt(fB, 2);
          byId("fact-f-int").textContent = fmt(fInt, 2);
          byId("fact-p-a").textContent = fmt(pA, 3);
          byId("fact-p-b").textContent = fmt(pB, 3);
          byId("fact-p-int").textContent = fmt(pInt, 3);
          byId("fact-comment").textContent =
            pInt < 0.05 ? "Interaction detected." : "No strong interaction evidence.";

          const padding = 40;
          const w = canvas.width;
          const h = canvas.height;
          ctx.clearRect(0, 0, w, h);
          const x1 = padding + 80;
          const x2 = w - padding - 80;
          const yBase = h - padding;
          const scaleY = (v) => yBase - (v - Math.min(...means) + 0.5) * 40;
          const axisX = padding;
          ctx.strokeStyle = "#cbd5f6";
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.moveTo(axisX, padding);
          ctx.lineTo(axisX, yBase);
          ctx.stroke();
          ctx.beginPath();
          ctx.moveTo(axisX, yBase);
          ctx.lineTo(w - padding, yBase);
          ctx.stroke();
          const line = (aIdx, color) => {
            ctx.strokeStyle = color;
            ctx.lineWidth = 2;
            const mLow = cells[aIdx * 2].mean;
            const mHigh = cells[aIdx * 2 + 1].mean;
            ctx.beginPath();
            ctx.moveTo(x1, scaleY(mLow));
            ctx.lineTo(x2, scaleY(mHigh));
            ctx.stroke();
          };
          line(0, "#2563eb");
          line(1, "#f97316");
          ctx.fillStyle = "#0f172a";
          ctx.font = "12px system-ui, sans-serif";
          ctx.fillText("Difficulty low", x1 - 30, h - padding + 18);
          ctx.fillText("Difficulty high", x2 - 35, h - padding + 18);
          ctx.fillText("Music off", x1 - 80, scaleY(cells[0].mean));
          ctx.fillText("Music on", x1 - 80, scaleY(cells[2].mean));
          ctx.fillStyle = "#64748b";
          ctx.font = "11px system-ui, sans-serif";
          ctx.fillText("Mean outcome", axisX + 4, padding - 10);
        }

        runBtn.addEventListener("click", simulate);
        simulate();
      }

      function setupLogTransform() {
        const distInput = byId("log-dist");
        const nInput = byId("log-n");
        const runBtn = byId("log-run");
        const rawCanvas = byId("log-raw");
        const transCanvas = byId("log-trans");
        const ctxRaw = rawCanvas.getContext("2d");
        const ctxTrans = transCanvas.getContext("2d");

        function drawHist(ctx, data) {
          const padding = 30;
          const w = ctx.canvas.width;
          const h = ctx.canvas.height;
          const bins = 18;
          const minX = Math.min(...data);
          const maxX = Math.max(...data);
          const counts = Array.from({ length: bins }, () => 0);
          data.forEach((v) => {
            const idx = Math.min(
              bins - 1,
              Math.max(0, Math.floor(((v - minX) / (maxX - minX)) * bins))
            );
            counts[idx] += 1;
          });
          const maxCount = Math.max(...counts, 1);
          ctx.clearRect(0, 0, w, h);
          drawAxes(ctx, w, h, padding);
          const barWidth = (w - 2 * padding) / bins;
          counts.forEach((count, i) => {
            const barHeight = (count / maxCount) * (h - 2 * padding) * 0.9;
            const x = padding + i * barWidth;
            const y = h - padding - barHeight;
            ctx.fillStyle = "#60a5fa";
            ctx.fillRect(x + 2, y, barWidth - 4, barHeight);
          });
        }

        function simulate() {
          const n = Number(nInput.value);
          const dist = distInput.value;
          const data = [];
          for (let i = 0; i < n; i += 1) {
            if (dist === "lognormal") {
              data.push(Math.exp(normalSample(0, 0.6)));
            } else if (dist === "exponential") {
              const u = Math.random();
              data.push(-Math.log(1 - u));
            } else {
              data.push(normalSample(5, 1));
            }
          }
          const logData = data.map((v) => Math.log(1 + v));
          drawHist(ctxRaw, data);
          drawHist(ctxTrans, logData);
        }

        runBtn.addEventListener("click", simulate);
        distInput.addEventListener("change", simulate);
        simulate();
      }
      function setupQuizzes() {
        document.querySelectorAll(".quiz").forEach((quiz) => {
          const correct = quiz.dataset.answer;
          const button = quiz.querySelector(".check-btn");
          const feedback = quiz.querySelector(".feedback");

          button.addEventListener("click", () => {
            const selected = quiz.querySelector("input:checked");
            if (!selected) {
              feedback.textContent = "Select an answer first.";
              feedback.className = "feedback";
              return;
            }
            if (selected.value === correct) {
              feedback.textContent = "Correct. Nice work.";
              feedback.className = "feedback correct";
            } else {
              feedback.textContent = "Not quite. Review the concept and try again.";
              feedback.className = "feedback wrong";
            }
          });
        });
      }

      function setupMiniChecks() {
        document.querySelectorAll(".mini-check").forEach((check) => {
          const correct = check.dataset.answer;
          const button = check.querySelector(".check-btn");
          const select = check.querySelector("select");
          const feedback = check.querySelector(".feedback");

          button.addEventListener("click", () => {
            if (!select.value) {
              feedback.textContent = "Select an option first.";
              feedback.className = "feedback";
              return;
            }
            if (select.value === correct) {
              feedback.textContent = "Correct.";
              feedback.className = "feedback correct";
            } else {
              feedback.textContent = "Not quite. Try again.";
              feedback.className = "feedback wrong";
            }
          });
        });
      }

      async function setupWebRBench() {
        const output = byId("r-output");
        const runBtn = byId("r-run");
        const resetBtn = byId("r-reset");
        const buildBtn = byId("r-build");
        const codeArea = byId("r-code");
        const canvas = byId("r-plot");
        const ctx = canvas.getContext("2d");

        const groupsInput = byId("r-groups");
        const nInput = byId("r-n");
        const muInput = byId("r-mu");
        const stepInput = byId("r-step");
        const sdInput = byId("r-sd");

        const defaultParams = {
          groups: 3,
          n: 40,
          mu: 420,
          step: 25,
          sigma: 60
        };

        function buildCode() {
          const k = Number(groupsInput.value);
          const n = Number(nInput.value);
          const mu = Number(muInput.value);
          const step = Number(stepInput.value);
          const sigma = Number(sdInput.value);
          return `set.seed(123)
k <- ${k}
n <- ${n}
mu <- ${mu}
step <- ${step}
sigma <- ${sigma}

group <- factor(rep(1:k, each = n))
means <- mu + (0:(k - 1)) * step
y <- unlist(lapply(means, function(m) rnorm(n, m, sigma)))
df <- data.frame(group = group, y = y)

cat("Group means\\n")
print(aggregate(y ~ group, df, mean))

if (k == 2) {
  cat("\\nT-test\\n")
  print(t.test(y ~ group, df))
} else {
  cat("\\nANOVA\\n")
  fit <- aov(y ~ group, df)
  print(summary(fit))
  cat("\\nPost-hoc (Tukey)\\n")
  print(TukeyHSD(fit))
}

boxplot(y ~ group, df,
        main = "Reaction time by group",
        xlab = "Group", ylab = "Reaction time",
        col = c("#93c5fd", "#fda4af", "#86efac"))`;
        }

        function reset() {
          groupsInput.value = defaultParams.groups;
          nInput.value = defaultParams.n;
          muInput.value = defaultParams.mu;
          stepInput.value = defaultParams.step;
          sdInput.value = defaultParams.sigma;
          codeArea.value = buildCode();
        }

        function clearOutput() {
          output.textContent = "";
          ctx.clearRect(0, 0, canvas.width, canvas.height);
        }

        let webRConsole = null;
        try {
          const { Console } = await import("https://webr.r-wasm.org/latest/webr.mjs");
          webRConsole = new Console({
            stdout: (line) => {
              output.textContent += `${line}\n`;
            },
            stderr: (line) => {
              output.textContent += `${line}\n`;
            },
            prompt: (line) => {
              output.textContent += line;
            },
            canvasImage: (img) => {
              ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
            },
            canvasNewPage: () => {
              ctx.clearRect(0, 0, canvas.width, canvas.height);
            }
          });
          await webRConsole.run();
          await webRConsole.stdin("options(device=webr::canvas(450, 260))");
          output.textContent = "webR is ready. Update parameters and run the code.";
          runBtn.disabled = false;
        } catch (err) {
          output.textContent = `webR failed to load: ${err.message}`;
        }

        buildBtn.addEventListener("click", () => {
          codeArea.value = buildCode();
        });

        resetBtn.addEventListener("click", () => {
          reset();
          clearOutput();
          output.textContent = "Reset to defaults. Click Run R to execute.";
        });

        runBtn.addEventListener("click", async () => {
          if (!webRConsole) return;
          clearOutput();
          await webRConsole.stdin(codeArea.value);
        });

        reset();
      }

      reorderSections();
      setupTheoryCards();
      setupViewSettings();
      setupDesignPicker();
      setupMeanSim();
      setupQuizzes();
      setupMiniChecks();
      setupHypothesisSim();
      setupTTestPlot();
      setupOneWayAnova();
      setupFactorialAnova();
      setupLogTransform();
      setupWebRBench();
    </script>
  </body>
  </html>
