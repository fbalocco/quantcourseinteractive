<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Session 4A - Archival Data and OLS Regression</title>
    <script>
      window.MathJax = {
        tex: { inlineMath: [["\\(", "\\)"]], displayMath: [["$$", "$$"]] }
      };
    </script>
    <script defer src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <style>
      :root {
        color-scheme: light;
        --bg: #f7f8fc;
        --card: #ffffff;
        --text: #1c1f24;
        --muted: #5d6473;
        --border: #e3e7f1;
        --accent: #2b6de9;
        --accent-2: #1f4fb1;
        --success: #1c7c54;
        --warning: #d97706;
      }

      * {
        box-sizing: border-box;
      }

      body {
        margin: 0;
        font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
        color: var(--text);
        background: var(--bg);
        line-height: 1.6;
        padding-top: 70px;
      }

      a {
        color: var(--accent);
        text-decoration: none;
      }

      a:hover {
        color: var(--accent-2);
        text-decoration: underline;
      }

      header {
        background: linear-gradient(135deg, #eaf0ff, #ffffff);
        border-bottom: 1px solid var(--border);
      }

      .container {
        max-width: min(1320px, 96vw);
        margin: 0 auto;
        padding: 24px 20px 60px;
      }

      .hero {
        display: grid;
        gap: 12px;
        padding: 28px 0 18px;
      }

      .breadcrumbs {
        font-size: 14px;
        color: var(--muted);
      }

      .hero h1 {
        margin: 0;
        font-size: 32px;
      }

      .hero p {
        margin: 0;
        color: var(--muted);
        max-width: 920px;
      }

      .section {
        margin-top: 28px;
        display: grid;
        gap: 16px;
      }

      .card {
        background: var(--card);
        border: 1px solid var(--border);
        border-radius: 14px;
        padding: 18px;
        box-shadow: 0 12px 24px rgba(24, 34, 72, 0.06);
      }

      .card h3 {
        margin-top: 0;
      }

      .grid-2 {
        display: grid;
        gap: 16px;
        grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
      }

      .grid-2.asym {
        grid-template-columns: minmax(280px, 2fr) minmax(200px, 1fr);
        align-items: start;
      }

      .tag {
        display: inline-block;
        font-size: 12px;
        letter-spacing: 0.08em;
        text-transform: uppercase;
        color: var(--muted);
      }

      .pill {
        display: inline-block;
        border: 1px solid var(--border);
        border-radius: 999px;
        padding: 4px 10px;
        font-size: 12px;
        color: var(--muted);
        background: #f2f4fa;
      }

      .topbar {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        height: 56px;
        background: #ffffff;
        border-bottom: 1px solid var(--border);
        display: flex;
        align-items: center;
        gap: 16px;
        padding: 0 16px;
        z-index: 1000;
      }

      .topbar-link {
        font-weight: 600;
        color: var(--accent);
      }

      .topbar-progress {
        flex: 1;
        display: grid;
        gap: 4px;
      }

      .progress-track {
        height: 6px;
        background: #e5e7eb;
        border-radius: 999px;
        overflow: hidden;
      }

      .progress-bar {
        height: 100%;
        width: 0%;
        background: var(--accent);
        transition: width 0.2s ease;
      }

      .progress-text {
        font-size: 12px;
        color: var(--muted);
      }

      .topbar-actions {
        display: flex;
        align-items: center;
        gap: 8px;
      }

      .settings-panel {
        position: fixed;
        top: 64px;
        right: 16px;
        background: #ffffff;
        border: 1px solid var(--border);
        border-radius: 12px;
        padding: 12px;
        box-shadow: 0 10px 24px rgba(24, 34, 72, 0.12);
        z-index: 1001;
        display: none;
      }

      .settings-panel.open {
        display: grid;
        gap: 8px;
      }

      .settings-title {
        font-weight: 600;
        font-size: 13px;
      }

      .controls {
        display: grid;
        gap: 10px;
        margin-top: 12px;
      }

      .control-row {
        display: grid;
        gap: 6px;
      }

      label {
        font-size: 13px;
        color: var(--muted);
      }

      input[type="range"],
      input[type="number"],
      select,
      textarea {
        width: 100%;
      }

      .btn {
        background: var(--accent);
        color: #fff;
        border: none;
        padding: 10px 14px;
        border-radius: 10px;
        cursor: pointer;
        font-weight: 600;
        font-size: 14px;
      }

      .btn.secondary {
        background: #e9eefc;
        color: var(--accent-2);
      }

      .btn:disabled {
        opacity: 0.6;
        cursor: not-allowed;
      }

      .stats {
        display: grid;
        gap: 8px;
        grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
        margin-top: 12px;
      }

      .stat {
        background: #f5f7ff;
        border-radius: 10px;
        padding: 10px;
        font-size: 13px;
      }

      .small {
        font-size: 12px;
        color: var(--muted);
      }

      .center {
        text-align: center;
      }

      .equation {
        font-size: 13px;
        background: #f5f7ff;
        border: 1px dashed #d7deef;
        border-radius: 10px;
        padding: 8px 10px;
        margin: 8px 0 12px;
        font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
      }

      .small-canvas {
        width: 240px;
        max-width: 100%;
        height: auto;
        justify-self: center;
      }

      .small-panel {
        display: grid;
        gap: 6px;
        justify-items: center;
      }

      .btn-row {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
      }

      .output-table {
        width: 100%;
        border-collapse: collapse;
        font-size: 13px;
        margin-top: 12px;
      }

      .output-table th,
      .output-table td {
        padding: 6px 8px;
        border-bottom: 1px solid var(--border);
        text-align: left;
      }

      .output-table th {
        color: var(--muted);
        font-weight: 600;
      }

      canvas {
        width: 100%;
        border: 1px solid var(--border);
        border-radius: 12px;
        background: #fbfcff;
      }

      .quiz {
        display: grid;
        gap: 10px;
      }

      .quiz label {
        font-size: 14px;
        color: var(--text);
      }

      .feedback {
        font-size: 13px;
        padding: 8px 10px;
        border-radius: 8px;
        background: #f5f7ff;
        color: var(--muted);
      }

      .feedback.correct {
        background: #e7f6ee;
        color: var(--success);
      }

      .feedback.wrong {
        background: #fff4e5;
        color: var(--warning);
      }

      .bench {
        display: grid;
        gap: 12px;
      }

      .bench textarea {
        min-height: 180px;
        font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
        font-size: 12px;
        border: 1px solid var(--border);
        border-radius: 10px;
        padding: 10px;
      }

      .bench-output {
        display: grid;
        gap: 12px;
      }

      pre {
        margin: 0;
        background: #0f172a;
        color: #e2e8f0;
        padding: 12px;
        border-radius: 12px;
        min-height: 140px;
        overflow-x: auto;
        font-size: 12px;
      }

      ul {
        margin: 0 0 0 18px;
      }

      .callout {
        border-left: 4px solid #9bb8ff;
        padding-left: 12px;
        color: var(--muted);
      }

      .topic-list {
        list-style: none;
        margin: 0;
        padding: 0;
        display: grid;
        gap: 12px;
      }

      .topic-card {
        background: #fdfdff;
        border: 1px dashed #d8e1f6;
        border-radius: 12px;
        padding: 14px;
        display: grid;
        gap: 8px;
      }

      .topic-card h4 {
        margin: 0;
        font-size: 16px;
      }

      .card-grid {
        display: grid;
        gap: 16px;
        grid-template-columns: minmax(320px, 1.15fr) 2.15fr;
        align-items: start;
      }

      .card-left {
        display: grid;
        gap: 8px;
      }

      .card-right {
        display: grid;
        gap: 12px;
      }

      /* In single-card view, let theory and practice scroll independently. */
      .view-mode-single .card-left,
      .view-mode-single .card-right {
        max-height: var(--split-pane-height, 70vh);
        overflow-y: auto;
        overscroll-behavior: contain;
        scrollbar-gutter: stable;
        padding-right: 6px;
      }

      /* In all-cards view, keep theory visible while the page scrolls. */
      @media (min-width: 901px) {
        .view-mode-all .topic-card .card-left {
          position: sticky;
          top: 72px;
        }
      }

      .theory {
        font-size: 13px;
        color: var(--muted);
      }

      .exercise-intro {
        font-size: 12px;
        color: var(--muted);
      }

      footer {
        margin-top: 32px;
        font-size: 12px;
        color: var(--muted);
      }

      @media (max-width: 900px) {
        .card-grid {
          grid-template-columns: 1fr;
        }
      }

      .topic-card ul {
        margin: 0 0 0 18px;
      }

      .topic-figure {
        margin-top: 6px;
        background: #f5f7ff;
        border: 1px solid #e1e7f8;
        border-radius: 10px;
        padding: 8px;
        display: grid;
        justify-items: center;
      }

      .topic-figure svg {
        max-width: 100%;
        height: auto;
      }

      .topic-note {
        font-size: 12px;
        color: var(--muted);
      }

      .mini-check {
        display: grid;
        gap: 6px;
        margin-top: 8px;
        padding: 10px;
        border-radius: 10px;
        border: 1px solid #e1e7f8;
        background: #f6f8ff;
      }

      .mini-check label {
        font-size: 12px;
        color: var(--muted);
      }

      .mini-check select {
        padding: 6px 8px;
        border-radius: 8px;
        border: 1px solid var(--border);
        background: #fff;
        font-size: 13px;
      }
    </style>
  </head>
  <body>
    <div class="topbar">
      <a class="topbar-link" href="index.html">All modules</a>
      <div class="topbar-progress">
        <div class="progress-track"><div class="progress-bar" id="progress-bar"></div></div>
        <div class="progress-text" id="progress-text">Cards</div>
      </div>
      <div class="topbar-actions">
        <button class="btn secondary" id="prev-card" type="button">Prev</button>
        <button class="btn secondary" id="next-card" type="button">Next</button>
        <button class="btn" id="settings-btn" type="button">Settings</button>
      </div>
    </div>
    <div class="settings-panel" id="settings-panel">
      <div class="settings-title">View settings</div>
      <label><input type="radio" name="view-mode" value="all"> Show all cards</label>
      <label><input type="radio" name="view-mode" value="single"> Card-by-card</label>
    </div>
    <header>
      <div class="container hero">
        <div class="breadcrumbs"><a href="index.html">All modules</a> / Session 4A</div>
        <span class="tag">RDM Quantitative Track</span>
        <h1>Archival Data Analysis and OLS Regression</h1>
        <p>
          Learn how to interpret correlations, estimate linear regression models,
          and diagnose common issues like multicollinearity.
        </p>
        <div class="pill">Session 4A - 27 Feb 2024</div>
      </div>
    </header>

    <main class="container">
      <section class="section card">
        <h3>Learning goals</h3>
        <ul>
          <li>Recognize the strengths and limits of archival data.</li>
          <li>Differentiate correlation from causation.</li>
          <li>Interpret OLS coefficients, confidence intervals, and R-squared.</li>
          <li>Understand regression assumptions and diagnostics.</li>
          <li>Detect multicollinearity and interpret dummy variables.</li>
        </ul>
      </section>

      <section class="section card">
        <h3>Syllabus walkthrough (slide order)</h3>
        <p class="small">Selected topics below follow the slide sequence.</p>
        <ol class="topic-list">
          <li class="topic-card">
            <h4>1. Correlation basics</h4>
            <p class="small">
              Explore how correlation changes with direction and noise. This is a scatter-only view:
              no fitted line is drawn.
            </p>
            <div class="controls grid-2">
              <div class="control-row">
                <label>Sample size</label>
                <input id="corr6-n" type="range" min="30" max="300" step="10" value="120">
                <span class="small">n = <strong id="corr6-n-label">120</strong></span>
              </div>
              <div class="control-row">
                <label>Direction (slope)</label>
                <input id="corr6-beta" type="range" min="-2" max="2" step="0.2" value="0.8">
                <span class="small">beta = <strong id="corr6-beta-label">0.8</strong></span>
              </div>
              <div class="control-row">
                <label>Noise (sigma)</label>
                <input id="corr6-sd" type="range" min="0.5" max="4" step="0.5" value="1.5">
                <span class="small">sigma = <strong id="corr6-sd-label">1.5</strong></span>
              </div>
              <div class="control-row">
                <label>&nbsp;</label>
                <button class="btn" id="corr6-run">Regenerate sample</button>
              </div>
            </div>
            <canvas id="corr6-canvas" width="820" height="260" aria-label="Correlation scatter"></canvas>
            <div class="stats">
              <div class="stat">Correlation (r): <span id="corr6-r">-</span></div>
            </div>
            <div class="mini-check" data-answer="a">
              <label>Quick check: correlation provides...</label>
              <select>
                <option value="">Choose an answer</option>
                <option value="a">Direction and strength</option>
                <option value="b">Causal proof</option>
              </select>
              <button class="btn secondary check-btn" type="button">Check</button>
              <div class="feedback" aria-live="polite"></div>
            </div>
          </li>
          <li class="topic-card">
            <h4>2. Pearson correlation coefficient</h4>
            <p class="small">Pearson r scales covariance by the standard deviations.</p>
            <div class="equation">
              \(r = \frac{\sum (x-\bar{x})(y-\bar{y})}{\sqrt{\sum (x-\bar{x})^2 \sum (y-\bar{y})^2}}\)
            </div>
            <div class="controls grid-2">
              <div class="control-row">
                <label>Sample size</label>
                <input id="corr8-n" type="range" min="30" max="300" step="10" value="120">
                <span class="small">n = <strong id="corr8-n-label">120</strong></span>
              </div>
              <div class="control-row">
                <label>Direction (slope)</label>
                <input id="corr8-beta" type="range" min="-2" max="2" step="0.2" value="-0.6">
                <span class="small">beta = <strong id="corr8-beta-label">-0.6</strong></span>
              </div>
              <div class="control-row">
                <label>Noise (sigma)</label>
                <input id="corr8-sd" type="range" min="0.5" max="4" step="0.5" value="1.8">
                <span class="small">sigma = <strong id="corr8-sd-label">1.8</strong></span>
              </div>
              <div class="control-row">
                <label>&nbsp;</label>
                <button class="btn" id="corr8-run">Regenerate sample</button>
              </div>
            </div>
            <canvas id="corr8-canvas" width="820" height="260" aria-label="Pearson correlation scatter"></canvas>
            <div class="stats">
              <div class="stat">Correlation (r): <span id="corr8-r">-</span></div>
            </div>
            <div class="mini-check" data-answer="b">
              <label>Quick check: Pearson r ranges between...</label>
              <select>
                <option value="">Choose an answer</option>
                <option value="a">0 and 1</option>
                <option value="b">-1 and 1</option>
              </select>
              <button class="btn secondary check-btn" type="button">Check</button>
              <div class="feedback" aria-live="polite"></div>
            </div>
          </li>
          <li class="topic-card">
            <h4>3. Slope and intercept intuition</h4>
            <p class="small">
              Adjust rise over run and the intercept to see the line move. You can also type the
              coefficients directly.
            </p>
            <div class="controls grid-2">
              <div class="control-row">
                <label>Slope (rise over run)</label>
                <input id="line-slope" type="range" min="-2" max="2" step="0.1" value="0.8">
                <input id="line-slope-num" type="number" min="-2" max="2" step="0.1" value="0.8">
              </div>
              <div class="control-row">
                <label>Intercept</label>
                <input id="line-intercept" type="range" min="-4" max="4" step="0.2" value="0">
                <input id="line-intercept-num" type="number" min="-4" max="4" step="0.2" value="0">
              </div>
            </div>
            <div class="equation" id="line-eq"></div>
            <canvas id="line-canvas" width="820" height="260" aria-label="Line equation explorer"></canvas>
            <div class="mini-check" data-answer="b">
              <label>Quick check: the intercept is Y when X equals...</label>
              <select>
                <option value="">Choose an answer</option>
                <option value="a">1</option>
                <option value="b">0</option>
              </select>
              <button class="btn secondary check-btn" type="button">Check</button>
              <div class="feedback" aria-live="polite"></div>
            </div>
          </li>
          <li class="topic-card">
            <h4>4. Fitting a line and minimizing error</h4>
            <p class="small">
              Use rise over run to align the line with the scatter. When your line matches the OLS
              solution, it turns green. The error curve shows SSE over possible slopes, while RMSE
              summarizes fit quality.
            </p>
            <div class="controls grid-2">
              <div class="control-row">
                <label>Line slope</label>
                <input id="fit-slope" type="range" min="-2" max="2" step="0.1" value="0.6">
                <span class="small">slope = <strong id="fit-slope-label">0.6</strong></span>
              </div>
              <div class="control-row">
                <label>Line intercept</label>
                <input id="fit-intercept" type="range" min="-3" max="3" step="0.2" value="0.2">
                <span class="small">intercept = <strong id="fit-intercept-label">0.2</strong></span>
              </div>
              <div class="control-row">
                <label>&nbsp;</label>
                <button class="btn" id="fit-run">Resample scatter</button>
              </div>
            </div>
            <div class="grid-2 asym">
              <canvas id="fit-canvas" width="520" height="260" aria-label="Fit line to scatter"></canvas>
              <div class="small-panel">
                <canvas id="fit-error" class="small-canvas" width="240" height="200" aria-label="Error curve"></canvas>
                <div class="small center">SSE</div>
              </div>
            </div>
            <div class="stats">
              <div class="stat">RMSE: <span id="fit-rmse">-</span></div>
              <div class="stat">Status: <span id="fit-status">-</span></div>
            </div>
            <div class="mini-check" data-answer="b">
              <label>Quick check: the error term captures...</label>
              <select>
                <option value="">Choose an answer</option>
                <option value="a">The intercept</option>
                <option value="b">Unexplained variation</option>
              </select>
              <button class="btn secondary check-btn" type="button">Check</button>
              <div class="feedback" aria-live="polite"></div>
            </div>
            <div class="mini-check" data-answer="a">
              <label>Quick check: residuals measure...</label>
              <select>
                <option value="">Choose an answer</option>
                <option value="a">Fit errors</option>
                <option value="b">Predictor values</option>
              </select>
              <button class="btn secondary check-btn" type="button">Check</button>
              <div class="feedback" aria-live="polite"></div>
            </div>
            <div class="mini-check" data-answer="a">
              <label>Quick check: OLS minimizes the sum of...</label>
              <select>
                <option value="">Choose an answer</option>
                <option value="a">Squared residuals</option>
                <option value="b">Absolute means</option>
              </select>
              <button class="btn secondary check-btn" type="button">Check</button>
              <div class="feedback" aria-live="polite"></div>
            </div>
            <div class="mini-check" data-answer="b">
              <label>Quick check: FOCs are set to...</label>
              <select>
                <option value="">Choose an answer</option>
                <option value="a">One</option>
                <option value="b">Zero</option>
              </select>
              <button class="btn secondary check-btn" type="button">Check</button>
              <div class="feedback" aria-live="polite"></div>
            </div>
          </li>
          <li class="topic-card">
            <h4>5. Interpreting regression output</h4>
            <p class="small">
              Generate data, fit the regression line, and inspect coefficients, p-values, and confidence
              intervals. The zero-slope line (intercept only) is shown in red.
            </p>
            <div class="controls grid-2">
              <div class="control-row">
                <label>Sample size</label>
                <input id="reg-n" type="number" min="30" max="300" step="10" value="120">
              </div>
              <div class="control-row">
                <label>True slope</label>
                <input id="reg-slope" type="number" min="-2" max="2" step="0.1" value="0.9">
              </div>
              <div class="control-row">
                <label>True intercept</label>
                <input id="reg-intercept" type="number" min="-3" max="3" step="0.2" value="0.2">
              </div>
              <div class="control-row">
                <label>Noise (sigma)</label>
                <input id="reg-sd" type="number" min="0.5" max="4" step="0.2" value="1.5">
              </div>
              <div class="control-row">
                <label>&nbsp;</label>
                <button class="btn" id="reg-run">Resample data</button>
              </div>
            </div>
            <canvas id="reg-canvas" width="820" height="260" aria-label="Regression output plot"></canvas>
            <table class="output-table">
              <thead>
                <tr>
                  <th>Term</th>
                  <th>Coef</th>
                  <th>SE</th>
                  <th>t</th>
                  <th>p</th>
                  <th>95% CI</th>
                  <th>Sig?</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td>Intercept</td>
                  <td id="reg-b0">-</td>
                  <td id="reg-se0">-</td>
                  <td id="reg-t0">-</td>
                  <td id="reg-p0">-</td>
                  <td id="reg-ci0">-</td>
                  <td id="reg-sig0">-</td>
                </tr>
                <tr>
                  <td>Slope</td>
                  <td id="reg-b1">-</td>
                  <td id="reg-se1">-</td>
                  <td id="reg-t1">-</td>
                  <td id="reg-p1">-</td>
                  <td id="reg-ci1">-</td>
                  <td id="reg-sig1">-</td>
                </tr>
              </tbody>
            </table>
            <div class="mini-check" data-answer="a">
              <label>Quick check: a small p-value suggests...</label>
              <select>
                <option value="">Choose an answer</option>
                <option value="a">Evidence against H0</option>
                <option value="b">Guaranteed causality</option>
              </select>
              <button class="btn secondary check-btn" type="button">Check</button>
              <div class="feedback" aria-live="polite"></div>
            </div>
          </li>
          <li class="topic-card">
            <h4>6. Confidence intervals in regression</h4>
            <p class="small">
              The CI panel shows whether each coefficient’s interval crosses zero.
            </p>
            <canvas id="ci-canvas" width="820" height="180" aria-label="Confidence intervals vs zero"></canvas>
            <div class="mini-check" data-answer="b">
              <label>Quick check: if CI includes 0, you...</label>
              <select>
                <option value="">Choose an answer</option>
                <option value="a">Reject H0</option>
                <option value="b">Fail to reject H0</option>
              </select>
              <button class="btn secondary check-btn" type="button">Check</button>
              <div class="feedback" aria-live="polite"></div>
            </div>
          </li>
          <li class="topic-card">
            <h4>7. Goodness of fit and sums of squares</h4>
            <p class="small">
              Click SSE, SSR, or SST to see each component on the scatter plot.
            </p>
            <p class="small">
              SSE = unexplained variation, SSR = explained variation, SST = total variation.
              R^2 = SSR / SST.
            </p>
            <div class="controls">
              <div class="control-row">
                <label>&nbsp;</label>
                <div class="btn-row">
                  <button class="btn secondary" id="ss-sse">Show SSE</button>
                  <button class="btn secondary" id="ss-ssr">Show SSR</button>
                  <button class="btn secondary" id="ss-sst">Show SST</button>
                  <button class="btn" id="ss-run">Resample data</button>
                </div>
              </div>
            </div>
            <canvas id="ss-canvas" width="820" height="260" aria-label="Sums of squares decomposition"></canvas>
            <div class="stats">
              <div class="stat">SSE: <span id="ss-sse-val">-</span></div>
              <div class="stat">SSR: <span id="ss-ssr-val">-</span></div>
              <div class="stat">SST: <span id="ss-sst-val">-</span></div>
              <div class="stat">R^2: <span id="ss-r2">-</span></div>
            </div>
            <div class="mini-check" data-answer="a">
              <label>Quick check: SST equals...</label>
              <select>
                <option value="">Choose an answer</option>
                <option value="a">SSE + SSR</option>
                <option value="b">SSE - SSR</option>
              </select>
              <button class="btn secondary check-btn" type="button">Check</button>
              <div class="feedback" aria-live="polite"></div>
            </div>
          </li>
          <li class="topic-card">
            <h4>8. R-squared</h4>
            <p class="small">R^2 = SSR / SST, the share of variance explained by the model.</p>
            <div class="mini-check" data-answer="a">
              <label>Quick check: R-squared measures...</label>
              <select>
                <option value="">Choose an answer</option>
                <option value="a">Variance explained by the model</option>
                <option value="b">The p-value of the model</option>
              </select>
              <button class="btn secondary check-btn" type="button">Check</button>
              <div class="feedback" aria-live="polite"></div>
            </div>
          </li>
          <li class="topic-card">
            <h4>9. Regression assumptions and diagnostics</h4>
            <ul>
              <li>Linearity</li>
              <li>Independence</li>
              <li>Homoskedasticity</li>
              <li>Normally distributed errors</li>
            </ul>
            <div class="controls grid-2">
              <div class="control-row">
                <label>Failure case</label>
                <select id="assump-case">
                  <option value="nonlinear">Nonlinear pattern</option>
                  <option value="hetero">Heteroskedasticity</option>
                  <option value="nonnormal">Non-normal errors</option>
                  <option value="outliers">Outliers</option>
                </select>
              </div>
              <div class="control-row">
                <label>&nbsp;</label>
                <button class="btn" id="assump-run">Resample data</button>
              </div>
            </div>
            <canvas id="assump-scatter" width="820" height="260" aria-label="Assumption failure scatter"></canvas>
            <p class="small">
              Residual vs fitted plots and Q-Q plots show the same failure case in different ways.
            </p>
            <div class="grid-2">
              <canvas id="assump-resid" width="400" height="240" aria-label="Residuals vs fitted"></canvas>
              <canvas id="assump-qq" width="400" height="240" aria-label="Q-Q plot"></canvas>
            </div>
            <div class="mini-check" data-answer="a">
              <label>Quick check: homoskedasticity means...</label>
              <select>
                <option value="">Choose an answer</option>
                <option value="a">Constant variance of errors</option>
                <option value="b">Perfect correlation</option>
              </select>
              <button class="btn secondary check-btn" type="button">Check</button>
              <div class="feedback" aria-live="polite"></div>
            </div>
            <div class="mini-check" data-answer="a">
              <label>Quick check: strong patterns in residual plots indicate...</label>
              <select>
                <option value="">Choose an answer</option>
                <option value="a">Potential assumption violations</option>
                <option value="b">Perfect model fit</option>
              </select>
              <button class="btn secondary check-btn" type="button">Check</button>
              <div class="feedback" aria-live="polite"></div>
            </div>
          </li>
          <li class="topic-card">
            <h4>10. Multivariate regression</h4>
            <p class="small">
              Example: Sales = b0 + b1 * Marketing + b2 * Price. Changing coefficients shifts the plane.
            </p>
            <div class="equation">\( \text{Sales} = b_0 + b_1 \cdot \text{Marketing} + b_2 \cdot \text{Price} \)</div>
            <div class="controls grid-2">
              <div class="control-row">
                <label>Intercept (b0)</label>
                <input id="plane-b0" type="range" min="-1" max="2" step="0.1" value="0.5">
              </div>
              <div class="control-row">
                <label>Slope for X1 (b1)</label>
                <input id="plane-b1" type="range" min="-1.5" max="1.5" step="0.1" value="0.8">
              </div>
              <div class="control-row">
                <label>Slope for X2 (b2)</label>
                <input id="plane-b2" type="range" min="-1.5" max="1.5" step="0.1" value="-0.6">
              </div>
              <div class="control-row">
                <label>View</label>
                <select id="plane-view">
                  <option value="cube">3D cube view</option>
                  <option value="x1y">Marketing vs Sales</option>
                  <option value="x2y">Price vs Sales</option>
                  <option value="x1x2">Marketing vs Price</option>
                </select>
              </div>
              <div class="control-row">
                <label>Rotate (azimuth): <strong id="plane-az-label">35 deg</strong></label>
                <input id="plane-az" type="range" min="0" max="180" step="5" value="35">
              </div>
              <div class="control-row">
                <label>Rotate (elevation): <strong id="plane-el-label">20 deg</strong></label>
                <input id="plane-el" type="range" min="-30" max="60" step="5" value="20">
              </div>
              <div class="control-row">
                <label>&nbsp;</label>
                <button class="btn" id="plane-run">Resample data</button>
              </div>
            </div>
            <canvas id="plane-canvas" width="820" height="260" aria-label="3D regression plane"></canvas>
            <div class="mini-check" data-answer="b">
              <label>Quick check: a coefficient in multivariate regression is the effect of X...</label>
              <select>
                <option value="">Choose an answer</option>
                <option value="a">Ignoring other variables</option>
                <option value="b">Holding other variables constant</option>
              </select>
              <button class="btn secondary check-btn" type="button">Check</button>
              <div class="feedback" aria-live="polite"></div>
            </div>
          </li>
          <li class="topic-card">
            <h4>11. Dummy and categorical variables</h4>
            <p class="small">
              Toggle dummy mode to see two parallel regression lines. Increase categories to see how
              multiple dummies shift intercepts.
            </p>
            <div class="controls grid-2">
              <div class="control-row">
                <label>Baseline intercept</label>
                <input id="dummy-base" type="range" min="-2" max="6" step="0.2" value="1.2">
              </div>
              <div class="control-row">
                <label>Common slope</label>
                <input id="dummy-slope" type="range" min="-1" max="2" step="0.1" value="0.6">
              </div>
              <div class="control-row">
                <label>Category gap</label>
                <input id="dummy-gap" type="range" min="0" max="3" step="0.2" value="1">
              </div>
              <div class="control-row">
                <label>Number of categories</label>
                <input id="dummy-k" type="range" min="2" max="4" step="1" value="2">
              </div>
              <div class="control-row">
                <label><input id="dummy-toggle" type="checkbox" checked> Dummy mode (binary)</label>
              </div>
              <div class="control-row">
                <label>&nbsp;</label>
                <button class="btn" id="dummy-run">Resample data</button>
              </div>
            </div>
            <canvas id="dummy-canvas" width="820" height="260" aria-label="Dummy and categorical lines"></canvas>
            <div class="stats">
              <div class="stat">Note: <span id="dummy-note">-</span></div>
            </div>
            <div class="mini-check" data-answer="a">
              <label>Quick check: a dummy variable usually takes values...</label>
              <select>
                <option value="">Choose an answer</option>
                <option value="a">0 or 1</option>
                <option value="b">1 to 10</option>
              </select>
              <button class="btn secondary check-btn" type="button">Check</button>
              <div class="feedback" aria-live="polite"></div>
            </div>
            <div class="mini-check" data-answer="a">
              <label>Quick check: if there are m categories, you include...</label>
              <select>
                <option value="">Choose an answer</option>
                <option value="a">m - 1 dummies</option>
                <option value="b">m + 1 dummies</option>
              </select>
              <button class="btn secondary check-btn" type="button">Check</button>
              <div class="feedback" aria-live="polite"></div>
            </div>
          </li>
          <li class="topic-card">
            <h4>12. Diagnostics explorers</h4>
            <div class="grid-2">
              <div class="card">
                <h3>Heteroskedasticity explorer</h3>
                <p class="callout">
                  Increase heteroskedasticity to see how residual spread grows with X.
                </p>
                <div class="controls grid-2">
                  <div class="control-row">
                    <label>Sample size: <strong id="hetero-n-label">120</strong></label>
                    <input id="hetero-n" type="range" min="50" max="300" step="10" value="120">
                  </div>
                  <div class="control-row">
                    <label>Heteroskedasticity: <strong id="hetero-level-label">0.6</strong></label>
                    <input id="hetero-level" type="range" min="0" max="2" step="0.1" value="0.6">
                  </div>
                  <div class="control-row">
                    <label>&nbsp;</label>
                    <button class="btn" id="hetero-run">Resimulate</button>
                  </div>
                </div>
                <div class="grid-2">
                  <canvas id="hetero-canvas" width="400" height="240" aria-label="Scatter with heteroskedasticity"></canvas>
                  <canvas id="resid-canvas" width="400" height="240" aria-label="Residuals vs fitted"></canvas>
                </div>
                <div class="stats">
                  <div class="stat">Estimated slope: <span id="hetero-slope">-</span></div>
                  <div class="stat">Note: <span id="hetero-note">-</span></div>
                </div>
              </div>

              <div class="card">
                <h3>Multicollinearity explorer</h3>
                <p class="callout">
                  Increase correlation between predictors to see VIF inflate.
                </p>
                <div class="controls">
                  <div class="control-row">
                    <label>Correlation (r): <strong id="collin-r-label">0.5</strong></label>
                    <input id="collin-r" type="range" min="0" max="0.95" step="0.05" value="0.5">
                  </div>
                </div>
                <canvas id="collin-canvas" width="820" height="240" aria-label="Predictor correlation"></canvas>
                <div class="stats">
                  <div class="stat">Approx VIF: <span id="collin-vif">-</span></div>
                  <div class="stat">Interpretation: <span id="collin-int">-</span></div>
                </div>
              </div>
            </div>
          </li>
          <li class="topic-card">
            <h4>13. Interactions and moderations</h4>
            <p class="small">
              Interactions fit multiple lines with the same intercept but different slopes.
            </p>
            <div class="controls grid-2">
              <div class="control-row">
                <label>Intercept</label>
                <input id="intercept-base" type="range" min="-2" max="4" step="0.2" value="0.5">
              </div>
              <div class="control-row">
                <label>Base slope</label>
                <input id="intercept-slope" type="range" min="-1" max="2" step="0.1" value="0.5">
              </div>
              <div class="control-row">
                <label>Interaction effect (Δ slope)</label>
                <input id="intercept-delta" type="range" min="-1" max="1" step="0.1" value="0.6">
              </div>
              <div class="control-row">
                <label>&nbsp;</label>
                <button class="btn" id="intercept-run">Resample data</button>
              </div>
            </div>
            <canvas id="interact-canvas" width="820" height="260" aria-label="Interaction lines"></canvas>
            <div class="mini-check" data-answer="a">
              <label>Quick check: an interaction term tests whether...</label>
              <select>
                <option value="">Choose an answer</option>
                <option value="a">The effect of X1 depends on X2</option>
                <option value="b">X1 has no effect at all</option>
              </select>
              <button class="btn secondary check-btn" type="button">Check</button>
              <div class="feedback" aria-live="polite"></div>
            </div>
          </li>
        </ol>
      </section>

      <section class="section card" id="case-study">
        <h3>Case study: App updates and sales</h3>
        <p>
          You collect archival data for 400 mobile apps. Your dependent variable is
          monthly sales. You measure update frequency, marketing spend, and app age.
          You want to understand which predictors are associated with higher sales.
        </p>
        <ul>
          <li>Start with pairwise correlations to check direction and strength.</li>
          <li>Estimate a multivariate regression with controls.</li>
          <li>Check diagnostics and multicollinearity before interpreting coefficients.</li>
          <li>Report effect sizes and uncertainty, not only significance.</li>
        </ul>
      </section>

      <section class="section" id="quick-check">
        <div class="card">
          <h3>Quick check</h3>
          <div class="quiz" data-answer="a">
            <strong>1) Archival data is often:</strong>
            <label><input type="radio" name="q1" value="a"> Large and messy.</label>
            <label><input type="radio" name="q1" value="b"> Small and controlled.</label>
            <label><input type="radio" name="q1" value="c"> Always experimental.</label>
            <label><input type="radio" name="q1" value="d"> Collected under random assignment.</label>
            <button class="btn secondary check-btn">Check</button>
            <div class="feedback" aria-live="polite"></div>
          </div>

          <div class="quiz" data-answer="b">
            <strong>2) Archival data is usually strongest for:</strong>
            <label><input type="radio" name="q2" value="a"> Causal identification.</label>
            <label><input type="radio" name="q2" value="b"> Correlational evidence.</label>
            <label><input type="radio" name="q2" value="c"> Laboratory control.</label>
            <label><input type="radio" name="q2" value="d"> Random assignment.</label>
            <button class="btn secondary check-btn">Check</button>
            <div class="feedback" aria-live="polite"></div>
          </div>

          <div class="quiz" data-answer="a">
            <strong>3) Temporal precedence means:</strong>
            <label><input type="radio" name="q3" value="a"> Cause happens before effect.</label>
            <label><input type="radio" name="q3" value="b"> Effect happens before cause.</label>
            <label><input type="radio" name="q3" value="c"> Cause and effect are identical.</label>
            <label><input type="radio" name="q3" value="d"> Causes are random.</label>
            <button class="btn secondary check-btn">Check</button>
            <div class="feedback" aria-live="polite"></div>
          </div>

          <div class="quiz" data-answer="a">
            <strong>4) A negative correlation means when X increases, Y:</strong>
            <label><input type="radio" name="q4" value="a"> Tends to decrease.</label>
            <label><input type="radio" name="q4" value="b"> Always increases.</label>
            <label><input type="radio" name="q4" value="c"> Never changes.</label>
            <label><input type="radio" name="q4" value="d"> Becomes causal.</label>
            <button class="btn secondary check-btn">Check</button>
            <div class="feedback" aria-live="polite"></div>
          </div>

          <div class="quiz" data-answer="a">
            <strong>5) Correlation alone cannot:</strong>
            <label><input type="radio" name="q5" value="a"> Control for other variables.</label>
            <label><input type="radio" name="q5" value="b"> Show direction.</label>
            <label><input type="radio" name="q5" value="c"> Indicate association.</label>
            <label><input type="radio" name="q5" value="d"> Be negative.</label>
            <button class="btn secondary check-btn">Check</button>
            <div class="feedback" aria-live="polite"></div>
          </div>

          <div class="quiz" data-answer="a">
            <strong>6) Regression can be used for:</strong>
            <label><input type="radio" name="q6" value="a"> Prediction and hypothesis testing.</label>
            <label><input type="radio" name="q6" value="b"> Only descriptive charts.</label>
            <label><input type="radio" name="q6" value="c"> Random assignment.</label>
            <label><input type="radio" name="q6" value="d"> Removing noise entirely.</label>
            <button class="btn secondary check-btn">Check</button>
            <div class="feedback" aria-live="polite"></div>
          </div>

          <div class="quiz" data-answer="b">
            <strong>7) The dummy trap occurs when you:</strong>
            <label><input type="radio" name="q7" value="a"> Use too few categories.</label>
            <label><input type="radio" name="q7" value="b"> Include all categories at once.</label>
            <label><input type="radio" name="q7" value="c"> Center the variables.</label>
            <label><input type="radio" name="q7" value="d"> Use interaction terms.</label>
            <button class="btn secondary check-btn">Check</button>
            <div class="feedback" aria-live="polite"></div>
          </div>

          <div class="quiz" data-answer="a">
            <strong>8) A high VIF indicates:</strong>
            <label><input type="radio" name="q8" value="a"> Multicollinearity.</label>
            <label><input type="radio" name="q8" value="b"> Heteroskedasticity.</label>
            <label><input type="radio" name="q8" value="c"> Perfect model fit.</label>
            <label><input type="radio" name="q8" value="d"> Zero variance.</label>
            <button class="btn secondary check-btn">Check</button>
            <div class="feedback" aria-live="polite"></div>
          </div>

          <div class="quiz" data-answer="a">
            <strong>9) Control variables should be chosen based on:</strong>
            <label><input type="radio" name="q9" value="a"> Theory.</label>
            <label><input type="radio" name="q9" value="b"> Convenience only.</label>
            <label><input type="radio" name="q9" value="c"> Data availability only.</label>
            <label><input type="radio" name="q9" value="d"> Random selection.</label>
            <button class="btn secondary check-btn">Check</button>
            <div class="feedback" aria-live="polite"></div>
          </div>

          <div class="quiz" data-answer="c">
            <strong>10) Correlation alone can tell you:</strong>
            <label><input type="radio" name="q10" value="a"> Whether X causes Y.</label>
            <label><input type="radio" name="q10" value="b"> The slope of Y on X.</label>
            <label><input type="radio" name="q10" value="c"> Direction and strength of linear association.</label>
            <label><input type="radio" name="q10" value="d"> Whether the line is optimal.</label>
            <button class="btn secondary check-btn">Check</button>
            <div class="feedback" aria-live="polite"></div>
          </div>

          <div class="quiz" data-answer="b">
            <strong>11) If a 95% CI for a coefficient includes 0, you should:</strong>
            <label><input type="radio" name="q11" value="a"> Reject the null.</label>
            <label><input type="radio" name="q11" value="b"> Fail to reject the null at 5%.</label>
            <label><input type="radio" name="q11" value="c"> Remove the variable immediately.</label>
            <label><input type="radio" name="q11" value="d"> Double the sample size.</label>
            <button class="btn secondary check-btn">Check</button>
            <div class="feedback" aria-live="polite"></div>
          </div>
        </div>
      </section>

      <section class="section card" id="r-section">
        <h3>Interactive R test bench: multivariate OLS</h3>
        <p class="callout">
          Simulate a dataset with three predictors, then inspect coefficients,
          diagnostics, and VIF values.
        </p>
        <ul>
          <li>Increase rho to see VIF values rise with multicollinearity.</li>
          <li>Change slope signs to understand coefficient interpretation.</li>
          <li>Check residual plots for patterns or heteroskedasticity.</li>
          <li>Compare coefficient sizes with the data generation process.</li>
        </ul>
        <div class="bench">
          <div class="grid-2">
            <div class="control-row">
              <label>Sample size</label>
              <input id="r-n" type="number" min="50" max="800" step="25" value="250">
            </div>
            <div class="control-row">
              <label>Correlation between X1 and X2 (rho)</label>
              <input id="r-rho" type="number" min="0" max="0.95" step="0.05" value="0.6">
            </div>
            <div class="control-row">
              <label>Slope for X1</label>
              <input id="r-b1" type="number" min="-3" max="3" step="0.2" value="1.5">
            </div>
            <div class="control-row">
              <label>Slope for X2</label>
              <input id="r-b2" type="number" min="-3" max="3" step="0.2" value="0.8">
            </div>
            <div class="control-row">
              <label>Slope for X3</label>
              <input id="r-b3" type="number" min="-3" max="3" step="0.2" value="-0.5">
            </div>
            <div class="control-row">
              <label>Noise (sigma)</label>
              <input id="r-sd" type="number" min="0.5" max="5" step="0.5" value="1.5">
            </div>
          </div>
          <div class="controls">
            <button class="btn secondary" id="r-build">Update R code</button>
          </div>
          <textarea id="r-code" spellcheck="false"></textarea>
          <div class="controls">
            <button class="btn" id="r-run" disabled>Run R</button>
            <button class="btn secondary" id="r-reset">Reset</button>
          </div>
          <div class="bench-output">
            <pre id="r-output">Loading webR, please wait...</pre>
            <canvas id="r-plot" width="900" height="520"></canvas>
          </div>
        </div>
      </section>

    </main>
    <footer class="container">© 2026 Francesco Balocco.</footer>

    <script type="module">
      const byId = (id) => document.getElementById(id);

      function fmt(num, digits = 2) {
        return Number(num).toFixed(digits);
      }

      function typesetMath(el) {
        if (window.MathJax && window.MathJax.typesetPromise) {
          window.MathJax.typesetPromise(el ? [el] : undefined);
        }
      }

      function setupViewSettings() {
        const cards = Array.from(
          document.querySelectorAll(".topic-card, section.card, section#quick-check")
        );
        if (!cards.length) return;
        const crumbEl = document.querySelector(".breadcrumbs");
        const crumbText = crumbEl ? crumbEl.textContent : "";
        const hasSlash = crumbText.indexOf("/") !== -1;
        const sessionLabel = hasSlash ? crumbText.split("/").pop().trim() : crumbText.trim();
        const headingEl = document.querySelector("header h1");
        const sessionHeading = headingEl && headingEl.textContent ? headingEl.textContent.trim() : "";
        const sessionTitle = [sessionLabel, sessionHeading].filter(Boolean).join(" - ");
        const sessionPrefix = sessionTitle ? `${sessionTitle}. ` : "";
        const header = document.querySelector("header");
        const progressBar = byId("progress-bar");
        const progressText = byId("progress-text");
        const prevBtn = byId("prev-card");
        const nextBtn = byId("next-card");
        const settingsBtn = byId("settings-btn");
        const panel = byId("settings-panel");
        const modeInputs = Array.from(document.querySelectorAll("input[name='view-mode']"));
        let index = 0;
        const total = cards.length;

        function updateSplitPaneHeight() {
          if (!document.body.classList.contains("view-mode-single")) return;
          const topbar = document.querySelector(".topbar");
          const topbarH = topbar ? topbar.getBoundingClientRect().height : 0;
          const h = Math.max(320, window.innerHeight - topbarH - 140);
          document.documentElement.style.setProperty("--split-pane-height", `${h}px`);
        }

        function setMode(mode) {
          localStorage.setItem("viewMode", mode);
          modeInputs.forEach((input) => {
            input.checked = input.value === mode;
          });
          document.body.classList.toggle("view-mode-single", mode === "single");
          document.body.classList.toggle("view-mode-all", mode === "all");
          updateSplitPaneHeight();
          update();
        }

        function update() {
          const checkedInput = modeInputs.find((input) => input.checked);
          const mode = checkedInput ? checkedInput.value : "all";
          cards.forEach((card, i) => {
            const visible = mode === "all" || i === index;
            card.style.display = visible ? "" : "none";
          });
          prevBtn.disabled = mode === "all" || index === 0;
          nextBtn.disabled = mode === "all" || index === total - 1;
          const progress = mode === "all" ? 100 : ((index + 1) / total) * 100;
          progressBar.style.width = `${progress}%`;
          progressText.textContent =
            mode === "all"
              ? `${sessionPrefix}All cards (${total})`
              : `${sessionPrefix}Card ${index + 1} of ${total}`;
          if (header) {
            header.style.display = mode === "all" || index === 0 ? "" : "none";
          }
          updateSplitPaneHeight();
        }

        prevBtn.addEventListener("click", () => {
          index = Math.max(0, index - 1);
          update();
        });
        nextBtn.addEventListener("click", () => {
          index = Math.min(total - 1, index + 1);
          update();
        });
        settingsBtn.addEventListener("click", () => {
          panel.classList.toggle("open");
        });
        document.addEventListener("click", (event) => {
          if (!panel.contains(event.target) && event.target !== settingsBtn) {
            panel.classList.remove("open");
          }
        });
        modeInputs.forEach((input) => input.addEventListener("change", () => setMode(input.value)));
        window.addEventListener("resize", updateSplitPaneHeight);

        const savedMode = localStorage.getItem("viewMode") || "all";
        setMode(savedMode);
      }

      function reorderSections() {
        const main = document.querySelector("main");
        const quick = byId("quick-check");
        const caseCard = buildCaseStudyCard();
        if (caseCard) main.appendChild(caseCard);
        if (quick) main.appendChild(quick);
      }

      function buildCaseStudyCard() {
        const caseSection = byId("case-study");
        const rSection = byId("r-section");
        if (!caseSection || !rSection) return null;
        const card = document.createElement("section");
        card.className = "section card";
        card.id = "case-study-card";
        const grid = document.createElement("div");
        grid.className = "card-grid";
        const left = document.createElement("div");
        left.className = "card-left";
        const right = document.createElement("div");
        right.className = "card-right";

        const title = caseSection.querySelector("h3");
        if (title) left.appendChild(title);
        Array.from(caseSection.children).forEach((child) => {
          if (child !== title) left.appendChild(child);
        });

        const intro = document.createElement("p");
        intro.className = "exercise-intro";
        intro.textContent = "How to use: adjust parameters, update the R code, then run it to see outputs.";
        right.appendChild(intro);
        Array.from(rSection.children).forEach((child) => {
          if (child.tagName !== "H3") right.appendChild(child);
        });

        grid.appendChild(left);
        grid.appendChild(right);
        card.appendChild(grid);
        caseSection.remove();
        rSection.remove();
        return card;
      }

      function setupTheoryCards() {
        const list = document.querySelector(".topic-list");
        if (!list) return;
        const section = list.closest("section");
        if (section) {
          const heading = section.querySelector("h3");
          const note = section.querySelector(":scope > p.small");
          if (heading) heading.remove();
          if (note) note.remove();
          section.classList.remove("card");
        }

        const theory = [
          "Correlation measures <em>linear</em> association: \\(r\\in[-1,1]\\). It tells you direction and strength, but it does not identify causality—and it can be distorted by outliers or non-linear patterns.",
          "Pearson’s \\(r\\) is a standardized covariance: \\(r=\\frac{\\sum (x-\\bar{x})(y-\\bar{y})}{\\sqrt{\\sum (x-\\bar{x})^2\\sum (y-\\bar{y})^2}}\\). Intuition: it is large (in absolute value) when points fall tightly around a straight line.",
          "Simple linear regression models \\(y=b_0+b_1x\\). The slope \\(b_1\\) is the expected change in \\(y\\) for a 1-unit change in \\(x\\). The intercept \\(b_0\\) is the expected \\(y\\) when \\(x=0\\) (sometimes not meaningful if \\(x=0\\) is outside your data).",
          "OLS chooses \\(b_0,b_1\\) to minimize squared residuals: \\(SSE=\\sum (y_i-\\hat{y}_i)^2\\). Residuals are \(y_i-\\hat{y}_i\); the fitted line is the one that makes the overall squared error as small as possible.",
          "Regression output separates <strong>estimate</strong> and <strong>uncertainty</strong>: coefficient estimates, standard errors, test statistics, and p-values. A p-value typically tests \\(H_0: \\beta_j=0\\) <em>given the model assumptions</em>. It is not an effect size and it is not the probability the null is true.",
          "A 95% confidence interval is \\(\\hat\\beta_j \\pm c\\cdot SE(\\hat\\beta_j)\\), where \\(c\\) is a critical value (often a \\(t\\) value; large-sample approximations use \\(z\\)). If 0 lies inside the 95% CI, the coefficient is not statistically significant at 5% (two-sided).",
          "Variation can be decomposed: \\(SST=SSR+SSE\\). Here, \\(SST\\) is total variation in \\(y\\), \\(SSR\\) is variation explained by the fitted values, and \\(SSE\\) is unexplained variation (residuals).",
          "\\(R^2=SSR/SST\\) is the proportion of variance in \\(y\\) explained by the model (in-sample). It can increase when you add predictors even if they are not useful—use adjusted \\(R^2\\) and out-of-sample checks when comparing models.",
          "Key assumptions differ by goal. For unbiased slopes you need (most importantly) exogeneity: \\(E[\\varepsilon\\mid X]=0\\). For correct standard errors you also need appropriate error structure (e.g., homoskedasticity/independence). Normality of residuals is mainly a small-sample inference convenience; with large samples, inference is often approximately normal. Diagnostics help you spot nonlinearity, heteroskedasticity, and outliers.",
          "With multiple predictors, \\(y=b_0+b_1x_1+b_2x_2+\\dots\\), coefficients are <em>partial</em> effects: the change in \(y\) for a change in \(x_j\) holding other included predictors fixed. Omitting a relevant predictor that is correlated with \(x_j\) can create omitted-variable bias.",
          "Dummy variables encode categories with 0/1 indicators. You include \\(m-1\\) dummies for \\(m\\) categories, leaving one category as the <em>reference</em>. Coefficients are interpreted as differences from that reference group.",
          "Heteroskedasticity does not bias OLS coefficients, but it can make the usual standard errors wrong—use robust SEs when needed. Multicollinearity inflates standard errors (unstable estimates) but does not by itself create bias; VIFs are one way to flag it.",
          "Interactions model moderation: \\(y=b_0+b_1x+b_2z+b_3xz\\). The marginal effect of \\(x\\) becomes \\(\\frac{\\partial y}{\\partial x}=b_1+b_3 z\\), so the slope of \\(x\\) changes as \\(z\\) changes."
        ];
        const intros = [
          "How to use: generate scatterplots and observe how r changes with noise.",
          "How to use: resample and compare the numeric r to the scatter pattern.",
          "How to use: move slope and intercept to see the line update in real time.",
          "How to use: adjust the line and watch SSE and RMSE respond.",
          "How to use: resample data and interpret the output table and CI panel.",
          "How to use: compare the CI to 0 and note the significance message.",
          "How to use: click SSE/SSR/SST to see each component on the scatter.",
          "How to use: compare R^2 across samples to see model fit change.",
          "How to use: inspect residual and QQ plots for each assumption.",
          "How to use: adjust coefficients and view the fitted plane and faces.",
          "How to use: toggle dummies and categories to see parallel lines.",
          "How to use: explore heteroskedasticity and multicollinearity diagnostics.",
          "How to use: adjust interaction strength and compare slopes."
        ];

        function stripInteractivePrefix(text) {
          const trimmed = text.trim();
          const lower = trimmed.toLowerCase();
          const prefix = "interactive";
          if (lower.indexOf(prefix) === 0) {
            return trimmed.slice(prefix.length).trim();
          }
          return trimmed;
        }

        function stripLeadingNumbering(text) {
          let s = text.trim();
          let changed = true;
          while (changed) {
            changed = false;
            let i = 0;
            while (i < s.length && s[i] >= "0" && s[i] <= "9") i += 1;
            if (i === 0) break;
            while (i < s.length && (s[i] === " " || s[i] === "\t")) i += 1;
            while (i < s.length && (s[i] === "." || s[i] === "-" || s[i] === ":")) {
              i += 1;
              while (i < s.length && (s[i] === " " || s[i] === "\t")) i += 1;
            }
            s = s.slice(i).trim();
            changed = true;
          }
          while (
            s.length &&
            (s[0] === "." || s[0] === "-" || s[0] === ":" || s[0] === " " || s[0] === "\t")
          ) {
            s = s.slice(1).trim();
          }
          return s;
        }

        const cards = Array.from(list.querySelectorAll(".topic-card"));
        cards.forEach((card, i) => {
          const title = card.querySelector("h4");
          if (!title) return;
          const originalTitle = title.textContent.trim();
          let displayNumber = "";
          for (let k = 0; k < originalTitle.length; k += 1) {
            const ch = originalTitle[k];
            if (ch >= "0" && ch <= "9") displayNumber += ch;
            else if (!displayNumber && (ch === " " || ch === "\t")) continue;
            else break;
          }
          if (!displayNumber) displayNumber = String(i + 1);
          let cleanTitle = stripInteractivePrefix(originalTitle);
          cleanTitle = stripLeadingNumbering(cleanTitle);
          title.textContent = `${displayNumber}. ${cleanTitle}`;
          card.dataset.cardNumber = displayNumber;
          card.dataset.cardTitle = cleanTitle;
          const content = Array.from(card.children).filter((el) => el !== title);
          const grid = document.createElement("div");
          grid.className = "card-grid";
          const left = document.createElement("div");
          left.className = "card-left";
          const right = document.createElement("div");
          right.className = "card-right";
          const theoryEl = document.createElement("div");
          theoryEl.className = "theory";
          theoryEl.innerHTML = theory[i] || "";
          const introEl = document.createElement("p");
          introEl.className = "exercise-intro";
          introEl.innerHTML = intros[i] || "";

          left.appendChild(title);
          left.appendChild(theoryEl);
          right.appendChild(introEl);
          content.forEach((el) => right.appendChild(el));
          grid.appendChild(left);
          grid.appendChild(right);
          card.innerHTML = "";
          card.appendChild(grid);
        });

        // Merge topics that share the same data source (requested pairing).
        const mergeByNumber = (keepNum, mergeNum) => {
          const keep = list.querySelector(`.topic-card[data-card-number="${keepNum}"]`);
          const merge = list.querySelector(`.topic-card[data-card-number="${mergeNum}"]`);
          if (!keep || !merge) return;

          const keepLeft = keep.querySelector(".card-left");
          const keepRight = keep.querySelector(".card-right");
          const mergeLeft = merge.querySelector(".card-left");
          const mergeRight = merge.querySelector(".card-right");
          if (!keepLeft || !keepRight || !mergeLeft || !mergeRight) return;

          const keepTitle = keep.dataset.cardTitle || "";
          const mergeTitle = merge.dataset.cardTitle || "";
          const titleEl = keepLeft.querySelector("h4");
          if (titleEl) {
            titleEl.textContent = "";
            titleEl.appendChild(document.createTextNode(`${keepNum}. `));
            const strongA = document.createElement("strong");
            strongA.textContent = keepTitle;
            titleEl.appendChild(strongA);
          }

          const mergeTheory = mergeLeft.querySelector(".theory");
          if (mergeTheory) {
            const theoryBlock = document.createElement("div");
            theoryBlock.className = "theory";
            const strong = document.createElement("strong");
            strong.textContent = mergeTitle;
            theoryBlock.appendChild(strong);
            theoryBlock.appendChild(document.createElement("br"));
            const tmp = document.createElement("div");
            tmp.innerHTML = mergeTheory.innerHTML;
            Array.from(tmp.childNodes).forEach((node) => theoryBlock.appendChild(node));
            keepLeft.appendChild(theoryBlock);
          }

          // Add a practice heading for the merged part, then move practice blocks over.
          const practiceHeading = document.createElement("p");
          practiceHeading.className = "exercise-intro";
          const practiceStrong = document.createElement("strong");
          practiceStrong.textContent = mergeTitle;
          practiceHeading.appendChild(practiceStrong);
          keepRight.appendChild(practiceHeading);
          Array.from(mergeRight.children).forEach((child) => keepRight.appendChild(child));

          // Move quizzes to the very end of the merged card.
          const quizzes = keepRight.querySelectorAll(".mini-check, .quiz");
          quizzes.forEach((q) => keepRight.appendChild(q));

          merge.remove();
        };

        mergeByNumber("5", "6");
        mergeByNumber("7", "8");

        typesetMath(list);
      }

      function normalSample(mu, sigma) {
        const u1 = Math.random();
        const u2 = Math.random();
        const z = Math.sqrt(-2 * Math.log(u1)) * Math.cos(2 * Math.PI * u2);
        return mu + sigma * z;
      }

      function drawAxes(ctx, width, height, padding) {
        ctx.strokeStyle = "#cbd5f6";
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(padding, height - padding);
        ctx.lineTo(width - padding, height - padding);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(padding, padding);
        ctx.lineTo(padding, height - padding);
        ctx.stroke();
      }

      function erf(x) {
        const sign = x >= 0 ? 1 : -1;
        const a1 = 0.254829592;
        const a2 = -0.284496736;
        const a3 = 1.421413741;
        const a4 = -1.453152027;
        const a5 = 1.061405429;
        const p = 0.3275911;
        const t = 1 / (1 + p * Math.abs(x));
        const y =
          1 - ((((a5 * t + a4) * t + a3) * t + a2) * t + a1) * t * Math.exp(-x * x);
        return sign * y;
      }

      function normalCDF(x, mu = 0, sigma = 1) {
        return 0.5 * (1 + erf((x - mu) / (Math.sqrt(2) * sigma)));
      }

      function normalInv(p) {
        let low = -6;
        let high = 6;
        for (let i = 0; i < 60; i += 1) {
          const mid = (low + high) / 2;
          const cdf = normalCDF(mid, 0, 1);
          if (cdf < p) low = mid;
          else high = mid;
        }
        return (low + high) / 2;
      }

      function mean(arr) {
        return arr.reduce((s, v) => s + v, 0) / arr.length;
      }

      function pearsonR(xs, ys) {
        const meanX = mean(xs);
        const meanY = mean(ys);
        let ssX = 0;
        let ssY = 0;
        let cov = 0;
        xs.forEach((x, i) => {
          const dx = x - meanX;
          const dy = ys[i] - meanY;
          ssX += dx * dx;
          ssY += dy * dy;
          cov += dx * dy;
        });
        return cov / Math.sqrt(ssX * ssY);
      }

      function olsFit(xs, ys) {
        const n = xs.length;
        const meanX = mean(xs);
        const meanY = mean(ys);
        let ssX = 0;
        let cov = 0;
        xs.forEach((x, i) => {
          ssX += (x - meanX) ** 2;
          cov += (x - meanX) * (ys[i] - meanY);
        });
        const slope = cov / ssX;
        const intercept = meanY - slope * meanX;
        const fitted = xs.map((x) => intercept + slope * x);
        const residuals = ys.map((y, i) => y - fitted[i]);
        const sse = residuals.reduce((s, v) => s + v * v, 0);
        const mse = sse / (n - 2);
        const seSlope = Math.sqrt(mse / ssX);
        const seIntercept = Math.sqrt(mse * (1 / n + (meanX ** 2) / ssX));
        const tSlope = slope / seSlope;
        const tIntercept = intercept / seIntercept;
        const pSlope = 2 * (1 - normalCDF(Math.abs(tSlope), 0, 1));
        const pIntercept = 2 * (1 - normalCDF(Math.abs(tIntercept), 0, 1));
        const z = 1.96;
        const ciSlope = [slope - z * seSlope, slope + z * seSlope];
        const ciIntercept = [intercept - z * seIntercept, intercept + z * seIntercept];
        const r2 = pearsonR(xs, ys) ** 2;
        return {
          slope,
          intercept,
          fitted,
          residuals,
          sse,
          mse,
          seSlope,
          seIntercept,
          tSlope,
          tIntercept,
          pSlope,
          pIntercept,
          ciSlope,
          ciIntercept,
          meanX,
          meanY,
          r2
        };
      }

      function setupCorrelationModule(prefix) {
        const nInput = byId(`${prefix}-n`);
        const betaInput = byId(`${prefix}-beta`);
        const sdInput = byId(`${prefix}-sd`);
        const nLabel = byId(`${prefix}-n-label`);
        const betaLabel = byId(`${prefix}-beta-label`);
        const sdLabel = byId(`${prefix}-sd-label`);
        const runBtn = byId(`${prefix}-run`);
        const rOut = byId(`${prefix}-r`);
        const canvas = byId(`${prefix}-canvas`);
        const ctx = canvas.getContext("2d");

        function updateLabels() {
          nLabel.textContent = nInput.value;
          betaLabel.textContent = fmt(betaInput.value, 1);
          sdLabel.textContent = fmt(sdInput.value, 1);
        }

        function simulate() {
          const n = Number(nInput.value);
          const beta = Number(betaInput.value);
          const sigma = Number(sdInput.value);
          const xs = Array.from({ length: n }, () => normalSample(0, 1));
          const ys = xs.map((x) => beta * x + normalSample(0, sigma));
          const r = pearsonR(xs, ys);
          rOut.textContent = fmt(r, 2);

          ctx.clearRect(0, 0, canvas.width, canvas.height);
          const padding = 40;
          const minX = Math.min(...xs);
          const maxX = Math.max(...xs);
          const minY = Math.min(...ys);
          const maxY = Math.max(...ys);
          const scaleX = (x) =>
            padding + ((x - minX) / (maxX - minX)) * (canvas.width - 2 * padding);
          const scaleY = (y) =>
            canvas.height - padding - ((y - minY) / (maxY - minY)) * (canvas.height - 2 * padding);

          drawAxes(ctx, canvas.width, canvas.height, padding);

          ctx.fillStyle = "rgba(43, 109, 233, 0.6)";
          xs.forEach((x, i) => {
            ctx.beginPath();
            ctx.arc(scaleX(x), scaleY(ys[i]), 3, 0, Math.PI * 2);
            ctx.fill();
          });
        }

        nInput.addEventListener("input", updateLabels);
        betaInput.addEventListener("input", updateLabels);
        sdInput.addEventListener("input", updateLabels);
        runBtn.addEventListener("click", simulate);
        updateLabels();
        simulate();
      }

      function setupLineExplorer() {
        const slopeRange = byId("line-slope");
        const slopeNum = byId("line-slope-num");
        const interceptRange = byId("line-intercept");
        const interceptNum = byId("line-intercept-num");
        const eqOut = byId("line-eq");
        const canvas = byId("line-canvas");
        const ctx = canvas.getContext("2d");

        function syncValues(source, target) {
          target.value = source.value;
        }

        function draw() {
          const slope = Number(slopeRange.value);
          const intercept = Number(interceptRange.value);
          eqOut.innerHTML = `\\(y = ${fmt(intercept, 1)} + ${fmt(slope, 1)}x\\)`;
          typesetMath(eqOut);

          ctx.clearRect(0, 0, canvas.width, canvas.height);
          const padding = 40;
          const minX = -4;
          const maxX = 4;
          const minY = -4;
          const maxY = 4;
          const scaleX = (x) =>
            padding + ((x - minX) / (maxX - minX)) * (canvas.width - 2 * padding);
          const scaleY = (y) =>
            canvas.height - padding - ((y - minY) / (maxY - minY)) * (canvas.height - 2 * padding);

          ctx.strokeStyle = "#cbd5f6";
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.moveTo(scaleX(minX), scaleY(0));
          ctx.lineTo(scaleX(maxX), scaleY(0));
          ctx.stroke();
          ctx.beginPath();
          ctx.moveTo(scaleX(0), scaleY(minY));
          ctx.lineTo(scaleX(0), scaleY(maxY));
          ctx.stroke();

          ctx.strokeStyle = "#2563eb";
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.moveTo(scaleX(minX), scaleY(intercept + slope * minX));
          ctx.lineTo(scaleX(maxX), scaleY(intercept + slope * maxX));
          ctx.stroke();
        }

        slopeRange.addEventListener("input", () => {
          syncValues(slopeRange, slopeNum);
          draw();
        });
        slopeNum.addEventListener("input", () => {
          syncValues(slopeNum, slopeRange);
          draw();
        });
        interceptRange.addEventListener("input", () => {
          syncValues(interceptRange, interceptNum);
          draw();
        });
        interceptNum.addEventListener("input", () => {
          syncValues(interceptNum, interceptRange);
          draw();
        });
        draw();
      }

      function setupFitByEye() {
        const slopeInput = byId("fit-slope");
        const interceptInput = byId("fit-intercept");
        const slopeLabel = byId("fit-slope-label");
        const interceptLabel = byId("fit-intercept-label");
        const runBtn = byId("fit-run");
        const rmseOut = byId("fit-rmse");
        const statusOut = byId("fit-status");
        const canvas = byId("fit-canvas");
        const errorCanvas = byId("fit-error");
        const ctx = canvas.getContext("2d");
        const ctxErr = errorCanvas.getContext("2d");
        let xs = [];
        let ys = [];
        let ols = null;
        let olsRmse = 0;

        function resample() {
          xs = Array.from({ length: 60 }, () => normalSample(0, 1.2));
          ys = xs.map((x) => 0.5 + 0.9 * x + normalSample(0, 1.1));
          ols = olsFit(xs, ys);
          olsRmse = Math.sqrt(ols.sse / ys.length);
          draw();
        }

        function draw() {
          slopeLabel.textContent = fmt(slopeInput.value, 1);
          interceptLabel.textContent = fmt(interceptInput.value, 1);
          const slope = Number(slopeInput.value);
          const intercept = Number(interceptInput.value);

          const mse = ys.reduce((s, y, i) => {
            const err = y - (intercept + slope * xs[i]);
            return s + err * err;
          }, 0) / ys.length;
          const rmse = Math.sqrt(mse);
          const match = rmse <= olsRmse * 1.05;
          rmseOut.textContent = fmt(rmse, 2);
          statusOut.textContent = match ? "Matches OLS line" : "Adjust slope/intercept";

          const padding = 40;
          const minX = Math.min(...xs);
          const maxX = Math.max(...xs);
          const minY = Math.min(...ys);
          const maxY = Math.max(...ys);
          const scaleX = (x) =>
            padding + ((x - minX) / (maxX - minX)) * (canvas.width - 2 * padding);
          const scaleY = (y) =>
            canvas.height - padding - ((y - minY) / (maxY - minY)) * (canvas.height - 2 * padding);

          ctx.clearRect(0, 0, canvas.width, canvas.height);
          drawAxes(ctx, canvas.width, canvas.height, padding);
          ctx.fillStyle = "rgba(43, 109, 233, 0.6)";
          xs.forEach((x, i) => {
            ctx.beginPath();
            ctx.arc(scaleX(x), scaleY(ys[i]), 3, 0, Math.PI * 2);
            ctx.fill();
          });

          ctx.strokeStyle = match ? "#22c55e" : "#f97316";
          ctx.lineWidth = 2.5;
          ctx.beginPath();
          ctx.moveTo(scaleX(minX), scaleY(intercept + slope * minX));
          ctx.lineTo(scaleX(maxX), scaleY(intercept + slope * maxX));
          ctx.stroke();

          const meanX = ols.meanX;
          const meanY = ols.meanY;
          const minSlope = -2;
          const maxSlope = 2;
          const steps = 60;
          const sseVals = [];
          for (let i = 0; i <= steps; i += 1) {
            const s = minSlope + (i / steps) * (maxSlope - minSlope);
            const b0 = meanY - s * meanX;
            const sse = ys.reduce((sum, y, idx) => {
              const err = y - (b0 + s * xs[idx]);
              return sum + err * err;
            }, 0);
            sseVals.push(sse);
          }
          const maxSse = Math.max(...sseVals);
          ctxErr.clearRect(0, 0, errorCanvas.width, errorCanvas.height);
          drawAxes(ctxErr, errorCanvas.width, errorCanvas.height, 30);
          ctxErr.strokeStyle = "#2563eb";
          ctxErr.lineWidth = 2;
          ctxErr.beginPath();
          sseVals.forEach((val, i) => {
            const x =
              30 + (i / steps) * (errorCanvas.width - 60);
            const y =
              errorCanvas.height -
              30 -
              (val / maxSse) * (errorCanvas.height - 60);
            if (i === 0) ctxErr.moveTo(x, y);
            else ctxErr.lineTo(x, y);
          });
          ctxErr.stroke();
          const markerX =
            30 +
            ((slope - minSlope) / (maxSlope - minSlope)) * (errorCanvas.width - 60);
          ctxErr.strokeStyle = match ? "#22c55e" : "#f97316";
          ctxErr.setLineDash([5, 4]);
          ctxErr.beginPath();
          ctxErr.moveTo(markerX, 20);
          ctxErr.lineTo(markerX, errorCanvas.height - 20);
          ctxErr.stroke();
          ctxErr.setLineDash([]);
        }

        slopeInput.addEventListener("input", draw);
        interceptInput.addEventListener("input", draw);
        runBtn.addEventListener("click", resample);
        resample();
      }

      function setupRegressionOutput() {
        const nInput = byId("reg-n");
        const slopeInput = byId("reg-slope");
        const interceptInput = byId("reg-intercept");
        const sdInput = byId("reg-sd");
        const runBtn = byId("reg-run");
        const canvas = byId("reg-canvas");
        const ctx = canvas.getContext("2d");
        let xs = [];
        let ys = [];
        let fit = null;

        function drawPlot() {
          const padding = 40;
          const minX = Math.min(...xs);
          const maxX = Math.max(...xs);
          const minY = Math.min(...ys);
          const maxY = Math.max(...ys);
          const scaleX = (x) =>
            padding + ((x - minX) / (maxX - minX)) * (canvas.width - 2 * padding);
          const scaleY = (y) =>
            canvas.height - padding - ((y - minY) / (maxY - minY)) * (canvas.height - 2 * padding);

          ctx.clearRect(0, 0, canvas.width, canvas.height);
          drawAxes(ctx, canvas.width, canvas.height, padding);
          ctx.fillStyle = "rgba(43, 109, 233, 0.6)";
          xs.forEach((x, i) => {
            ctx.beginPath();
            ctx.arc(scaleX(x), scaleY(ys[i]), 3, 0, Math.PI * 2);
            ctx.fill();
          });

          ctx.strokeStyle = "#ef4444";
          ctx.lineWidth = 1.8;
          ctx.beginPath();
          ctx.moveTo(scaleX(minX), scaleY(fit.intercept));
          ctx.lineTo(scaleX(maxX), scaleY(fit.intercept));
          ctx.stroke();

          ctx.strokeStyle = "#2563eb";
          ctx.lineWidth = 2.5;
          ctx.beginPath();
          ctx.moveTo(scaleX(minX), scaleY(fit.intercept + fit.slope * minX));
          ctx.lineTo(scaleX(maxX), scaleY(fit.intercept + fit.slope * maxX));
          ctx.stroke();
        }

        function updateTable() {
          byId("reg-b0").textContent = fmt(fit.intercept, 2);
          byId("reg-b1").textContent = fmt(fit.slope, 2);
          byId("reg-se0").textContent = fmt(fit.seIntercept, 2);
          byId("reg-se1").textContent = fmt(fit.seSlope, 2);
          byId("reg-t0").textContent = fmt(fit.tIntercept, 2);
          byId("reg-t1").textContent = fmt(fit.tSlope, 2);
          byId("reg-p0").textContent = fmt(fit.pIntercept, 3);
          byId("reg-p1").textContent = fmt(fit.pSlope, 3);
          byId("reg-ci0").textContent = `${fmt(fit.ciIntercept[0], 2)} to ${fmt(
            fit.ciIntercept[1],
            2
          )}`;
          byId("reg-ci1").textContent = `${fmt(fit.ciSlope[0], 2)} to ${fmt(fit.ciSlope[1], 2)}`;
          byId("reg-sig0").textContent = fit.pIntercept < 0.05 ? "Sig" : "NS";
          byId("reg-sig1").textContent = fit.pSlope < 0.05 ? "Sig" : "NS";
        }

        function drawCIs() {
          const canvasCI = byId("ci-canvas");
          const ctxCI = canvasCI.getContext("2d");
          const padding = 50;
          const all = [...fit.ciIntercept, ...fit.ciSlope, 0];
          const minX = Math.min(...all) - 0.5;
          const maxX = Math.max(...all) + 0.5;
          const scaleX = (x) =>
            padding + ((x - minX) / (maxX - minX)) * (canvasCI.width - 2 * padding);
          ctxCI.clearRect(0, 0, canvasCI.width, canvasCI.height);
          ctxCI.strokeStyle = "#cbd5f6";
          ctxCI.beginPath();
          ctxCI.moveTo(scaleX(0), 20);
          ctxCI.lineTo(scaleX(0), canvasCI.height - 20);
          ctxCI.stroke();

          const drawCI = (ci, y, color) => {
            ctxCI.strokeStyle = color;
            ctxCI.lineWidth = 4;
            ctxCI.beginPath();
            ctxCI.moveTo(scaleX(ci[0]), y);
            ctxCI.lineTo(scaleX(ci[1]), y);
            ctxCI.stroke();
          };
          drawCI(fit.ciIntercept, canvasCI.height / 2 - 30, "#2563eb");
          drawCI(fit.ciSlope, canvasCI.height / 2 + 30, "#f97316");
          ctxCI.fillStyle = "#0f172a";
          ctxCI.font = "12px system-ui, sans-serif";
          ctxCI.fillText("Intercept", 10, canvasCI.height / 2 - 34);
          ctxCI.fillText("Slope", 10, canvasCI.height / 2 + 26);
        }

        function simulate() {
          const n = Number(nInput.value);
          const slope = Number(slopeInput.value);
          const intercept = Number(interceptInput.value);
          const sigma = Number(sdInput.value);
          xs = Array.from({ length: n }, () => (Math.random() * 6) - 3);
          ys = xs.map((x) => intercept + slope * x + normalSample(0, sigma));
          fit = olsFit(xs, ys);
          drawPlot();
          updateTable();
          drawCIs();
        }

        runBtn.addEventListener("click", simulate);
        [nInput, slopeInput, interceptInput, sdInput].forEach((input) => {
          input.addEventListener("change", simulate);
        });
        simulate();
      }

      function setupSumSquares() {
        const sseBtn = byId("ss-sse");
        const ssrBtn = byId("ss-ssr");
        const sstBtn = byId("ss-sst");
        const runBtn = byId("ss-run");
        const sseOut = byId("ss-sse-val");
        const ssrOut = byId("ss-ssr-val");
        const sstOut = byId("ss-sst-val");
        const canvas = byId("ss-canvas");
        const ctx = canvas.getContext("2d");
        let xs = [];
        let ys = [];
        let fit = null;
        let mode = "sse";

        function draw() {
          const padding = 40;
          const minX = Math.min(...xs);
          const maxX = Math.max(...xs);
          const minY = Math.min(...ys);
          const maxY = Math.max(...ys);
          const scaleX = (x) =>
            padding + ((x - minX) / (maxX - minX)) * (canvas.width - 2 * padding);
          const scaleY = (y) =>
            canvas.height - padding - ((y - minY) / (maxY - minY)) * (canvas.height - 2 * padding);
          ctx.clearRect(0, 0, canvas.width, canvas.height);
          drawAxes(ctx, canvas.width, canvas.height, padding);

          ctx.fillStyle = "rgba(43, 109, 233, 0.6)";
          xs.forEach((x, i) => {
            ctx.beginPath();
            ctx.arc(scaleX(x), scaleY(ys[i]), 3, 0, Math.PI * 2);
            ctx.fill();
          });

          ctx.strokeStyle = "#2563eb";
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.moveTo(scaleX(minX), scaleY(fit.intercept + fit.slope * minX));
          ctx.lineTo(scaleX(maxX), scaleY(fit.intercept + fit.slope * maxX));
          ctx.stroke();

          ctx.strokeStyle = "#94a3b8";
          ctx.beginPath();
          ctx.moveTo(scaleX(minX), scaleY(fit.meanY));
          ctx.lineTo(scaleX(maxX), scaleY(fit.meanY));
          ctx.stroke();

          xs.forEach((x, i) => {
            const y = ys[i];
            const yHat = fit.fitted[i];
            ctx.strokeStyle = mode === "sse" ? "#f97316" : mode === "ssr" ? "#22c55e" : "#a855f7";
            ctx.lineWidth = 1.4;
            ctx.beginPath();
            if (mode === "sse") {
              ctx.moveTo(scaleX(x), scaleY(yHat));
              ctx.lineTo(scaleX(x), scaleY(y));
            } else if (mode === "ssr") {
              ctx.moveTo(scaleX(x), scaleY(fit.meanY));
              ctx.lineTo(scaleX(x), scaleY(yHat));
            } else {
              ctx.moveTo(scaleX(x), scaleY(fit.meanY));
              ctx.lineTo(scaleX(x), scaleY(y));
            }
            ctx.stroke();
          });
        }

        function resample() {
          xs = Array.from({ length: 70 }, () => (Math.random() * 6) - 3);
          ys = xs.map((x) => 1 + 0.7 * x + normalSample(0, 1.2));
          fit = olsFit(xs, ys);
          const ssr = fit.fitted.reduce((s, yHat) => s + (yHat - fit.meanY) ** 2, 0);
          const sse = fit.sse;
          const sst = sse + ssr;
          const r2 = ssr / sst;
          sseOut.textContent = fmt(sse, 2);
          ssrOut.textContent = fmt(ssr, 2);
          sstOut.textContent = fmt(sst, 2);
          byId("ss-r2").textContent = fmt(r2, 2);
          draw();
        }

        sseBtn.addEventListener("click", () => {
          mode = "sse";
          draw();
        });
        ssrBtn.addEventListener("click", () => {
          mode = "ssr";
          draw();
        });
        sstBtn.addEventListener("click", () => {
          mode = "sst";
          draw();
        });
        runBtn.addEventListener("click", resample);
        resample();
      }

      function setupAssumptionViz() {
        const caseInput = byId("assump-case");
        const runBtn = byId("assump-run");
        const scatterCanvas = byId("assump-scatter");
        const residCanvas = byId("assump-resid");
        const qqCanvas = byId("assump-qq");
        const ctxScatter = scatterCanvas.getContext("2d");
        const ctxResid = residCanvas.getContext("2d");
        const ctxQQ = qqCanvas.getContext("2d");
        let xs = [];
        let ys = [];
        let fit = null;

        function simulate() {
          const n = 120;
          xs = Array.from({ length: n }, () => (Math.random() * 6) - 3);
          const mode = caseInput.value;
          ys = xs.map((x) => {
            if (mode === "nonlinear") {
              return 0.4 * x + 0.4 * x * x + normalSample(0, 0.7);
            }
            if (mode === "hetero") {
              return 0.4 * x + normalSample(0, 0.4 + 0.4 * Math.abs(x));
            }
            if (mode === "nonnormal") {
              const tail = Math.random() < 0.1 ? 3 : 1;
              return 0.4 * x + normalSample(0, 0.7 * tail);
            }
            const outlier = Math.random() < 0.06 ? normalSample(0, 4) : normalSample(0, 0.7);
            return 0.4 * x + outlier;
          });
          fit = olsFit(xs, ys);
          drawScatter();
          drawResiduals();
          drawQQ();
        }

        function drawScatter() {
          const padding = 40;
          const minX = Math.min(...xs);
          const maxX = Math.max(...xs);
          const minY = Math.min(...ys);
          const maxY = Math.max(...ys);
          const scaleX = (x) =>
            padding + ((x - minX) / (maxX - minX)) * (scatterCanvas.width - 2 * padding);
          const scaleY = (y) =>
            scatterCanvas.height -
            padding -
            ((y - minY) / (maxY - minY)) * (scatterCanvas.height - 2 * padding);
          ctxScatter.clearRect(0, 0, scatterCanvas.width, scatterCanvas.height);
          drawAxes(ctxScatter, scatterCanvas.width, scatterCanvas.height, padding);
          ctxScatter.fillStyle = "rgba(43, 109, 233, 0.6)";
          xs.forEach((x, i) => {
            ctxScatter.beginPath();
            ctxScatter.arc(scaleX(x), scaleY(ys[i]), 3, 0, Math.PI * 2);
            ctxScatter.fill();
          });
          ctxScatter.strokeStyle = "#f97316";
          ctxScatter.lineWidth = 2;
          ctxScatter.beginPath();
          ctxScatter.moveTo(scaleX(minX), scaleY(fit.intercept + fit.slope * minX));
          ctxScatter.lineTo(scaleX(maxX), scaleY(fit.intercept + fit.slope * maxX));
          ctxScatter.stroke();
        }

        function drawResiduals() {
          const padding = 30;
          const fitted = fit.fitted;
          const residuals = fit.residuals;
          const minX = Math.min(...fitted);
          const maxX = Math.max(...fitted);
          const minY = Math.min(...residuals);
          const maxY = Math.max(...residuals);
          const scaleX = (x) =>
            padding + ((x - minX) / (maxX - minX)) * (residCanvas.width - 2 * padding);
          const scaleY = (y) =>
            residCanvas.height -
            padding -
            ((y - minY) / (maxY - minY)) * (residCanvas.height - 2 * padding);
          ctxResid.clearRect(0, 0, residCanvas.width, residCanvas.height);
          drawAxes(ctxResid, residCanvas.width, residCanvas.height, padding);
          ctxResid.strokeStyle = "#cbd5f6";
          ctxResid.beginPath();
          ctxResid.moveTo(padding, scaleY(0));
          ctxResid.lineTo(residCanvas.width - padding, scaleY(0));
          ctxResid.stroke();
          ctxResid.fillStyle = "rgba(249, 115, 22, 0.7)";
          fitted.forEach((x, i) => {
            ctxResid.beginPath();
            ctxResid.arc(scaleX(x), scaleY(residuals[i]), 2.5, 0, Math.PI * 2);
            ctxResid.fill();
          });
        }

        function drawQQ() {
          const padding = 30;
          const residuals = [...fit.residuals].sort((a, b) => a - b);
          const n = residuals.length;
          const theo = residuals.map((_, i) => normalInv((i + 0.5) / n));
          const minX = Math.min(...theo);
          const maxX = Math.max(...theo);
          const minY = Math.min(...residuals);
          const maxY = Math.max(...residuals);
          const scaleX = (x) =>
            padding + ((x - minX) / (maxX - minX)) * (qqCanvas.width - 2 * padding);
          const scaleY = (y) =>
            qqCanvas.height - padding - ((y - minY) / (maxY - minY)) * (qqCanvas.height - 2 * padding);
          ctxQQ.clearRect(0, 0, qqCanvas.width, qqCanvas.height);
          drawAxes(ctxQQ, qqCanvas.width, qqCanvas.height, padding);
          ctxQQ.strokeStyle = "#cbd5f6";
          ctxQQ.beginPath();
          ctxQQ.moveTo(scaleX(minX), scaleY(minY));
          ctxQQ.lineTo(scaleX(maxX), scaleY(maxY));
          ctxQQ.stroke();
          ctxQQ.fillStyle = "rgba(43, 109, 233, 0.7)";
          residuals.forEach((r, i) => {
            ctxQQ.beginPath();
            ctxQQ.arc(scaleX(theo[i]), scaleY(r), 2.5, 0, Math.PI * 2);
            ctxQQ.fill();
          });
        }

        runBtn.addEventListener("click", simulate);
        caseInput.addEventListener("change", simulate);
        simulate();
      }

      function setupPlaneViz() {
        const b0Input = byId("plane-b0");
        const b1Input = byId("plane-b1");
        const b2Input = byId("plane-b2");
        const viewInput = byId("plane-view");
        const azInput = byId("plane-az");
        const elInput = byId("plane-el");
        const azLabel = byId("plane-az-label");
        const elLabel = byId("plane-el-label");
        const runBtn = byId("plane-run");
        const canvas = byId("plane-canvas");
        const ctx = canvas.getContext("2d");
        let points = [];
        const x1Min = -2;
        const x1Max = 2;
        const x2Min = -2;
        const x2Max = 2;

        function project(x, z, y, az, el) {
          const azRad = (az * Math.PI) / 180;
          const elRad = (el * Math.PI) / 180;
          const x1 = x * Math.cos(azRad) + z * Math.sin(azRad);
          const z1 = -x * Math.sin(azRad) + z * Math.cos(azRad);
          const y1 = y * Math.cos(elRad) - z1 * Math.sin(elRad);
          return { x: x1, y: y1 };
        }

        function resample() {
          const coeffs = {
            b0: Number(b0Input.value),
            b1: Number(b1Input.value),
            b2: Number(b2Input.value)
          };
          points = Array.from({ length: 90 }, () => {
            const x1 = (Math.random() * (x1Max - x1Min)) + x1Min;
            const x2 = (Math.random() * (x2Max - x2Min)) + x2Min;
            const y = coeffs.b0 + coeffs.b1 * x1 + coeffs.b2 * x2 + normalSample(0, 0.6);
            return { x1, x2, y };
          });
          draw();
        }

        function drawFace(xVals, yVals, xLabel, yLabel) {
          const padding = 40;
          const minX = Math.min(...xVals);
          const maxX = Math.max(...xVals);
          const minY = Math.min(...yVals);
          const maxY = Math.max(...yVals);
          const scaleX = (x) =>
            padding + ((x - minX) / (maxX - minX)) * (canvas.width - 2 * padding);
          const scaleY = (y) =>
            canvas.height - padding - ((y - minY) / (maxY - minY)) * (canvas.height - 2 * padding);

          ctx.clearRect(0, 0, canvas.width, canvas.height);
          drawAxes(ctx, canvas.width, canvas.height, padding);
          ctx.fillStyle = "rgba(43, 109, 233, 0.6)";
          xVals.forEach((x, i) => {
            ctx.beginPath();
            ctx.arc(scaleX(x), scaleY(yVals[i]), 3, 0, Math.PI * 2);
            ctx.fill();
          });

          const fit = olsFit(xVals, yVals);
          ctx.strokeStyle = "#f97316";
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.moveTo(scaleX(minX), scaleY(fit.intercept + fit.slope * minX));
          ctx.lineTo(scaleX(maxX), scaleY(fit.intercept + fit.slope * maxX));
          ctx.stroke();

          ctx.fillStyle = "#0f172a";
          ctx.font = "12px system-ui, sans-serif";
          ctx.fillText(xLabel, canvas.width - 120, canvas.height - 12);
          ctx.fillText(yLabel, 10, 18);
        }

        function drawCube(coeffs) {
          const az = Number(azInput.value);
          const el = Number(elInput.value);
          azLabel.textContent = `${az} deg`;
          elLabel.textContent = `${el} deg`;
          ctx.clearRect(0, 0, canvas.width, canvas.height);

          const proj = points.map((p) => project(p.x1, p.x2, p.y, az, el));
          const corners = [
            { x1: x1Min, x2: x2Min },
            { x1: x1Max, x2: x2Min },
            { x1: x1Max, x2: x2Max },
            { x1: x1Min, x2: x2Max }
          ];
          const planeCorners = corners.map((c) => ({
            ...c,
            y: coeffs.b0 + coeffs.b1 * c.x1 + coeffs.b2 * c.x2
          }));
          const planeProj = planeCorners.map((c) => project(c.x1, c.x2, c.y, az, el));
          const gridProj = [];
          for (let x1 = x1Min; x1 <= x1Max + 0.01; x1 += 1) {
            for (let x2 = x2Min; x2 <= x2Max + 0.01; x2 += 0.5) {
              const y = coeffs.b0 + coeffs.b1 * x1 + coeffs.b2 * x2;
              gridProj.push(project(x1, x2, y, az, el));
            }
          }
          const yVals = [
            ...points.map((p) => p.y),
            ...planeCorners.map((c) => c.y)
          ];
          const yMin = Math.min(...yVals);
          const yMax = Math.max(...yVals);
          const origin = project(x1Min, x2Min, yMin, az, el);
          const axisX = project(x1Max, x2Min, yMin, az, el);
          const axisZ = project(x1Min, x2Max, yMin, az, el);
          const axisY = project(x1Min, x2Min, yMax, az, el);
          const cubeCorners = [
            project(x1Min, x2Min, yMin, az, el),
            project(x1Max, x2Min, yMin, az, el),
            project(x1Max, x2Max, yMin, az, el),
            project(x1Min, x2Max, yMin, az, el),
            project(x1Min, x2Min, yMax, az, el),
            project(x1Max, x2Min, yMax, az, el),
            project(x1Max, x2Max, yMax, az, el),
            project(x1Min, x2Max, yMax, az, el)
          ];
          const all = [...proj, ...planeProj, ...gridProj, origin, axisX, axisZ, axisY, ...cubeCorners];
          const minX = Math.min(...all.map((p) => p.x));
          const maxX = Math.max(...all.map((p) => p.x));
          const minY = Math.min(...all.map((p) => p.y));
          const maxY = Math.max(...all.map((p) => p.y));
          const padding = 40;
          const scaleX = (x) =>
            padding + ((x - minX) / (maxX - minX)) * (canvas.width - 2 * padding);
          const scaleY = (y) =>
            canvas.height - padding - ((y - minY) / (maxY - minY)) * (canvas.height - 2 * padding);

          const edges = [
            [0, 1], [1, 2], [2, 3], [3, 0],
            [4, 5], [5, 6], [6, 7], [7, 4],
            [0, 4], [1, 5], [2, 6], [3, 7]
          ];
          ctx.strokeStyle = "#d1d5db";
          ctx.lineWidth = 1;
          edges.forEach(([a, b]) => {
            ctx.beginPath();
            ctx.moveTo(scaleX(cubeCorners[a].x), scaleY(cubeCorners[a].y));
            ctx.lineTo(scaleX(cubeCorners[b].x), scaleY(cubeCorners[b].y));
            ctx.stroke();
          });

          ctx.fillStyle = "rgba(191, 219, 254, 0.35)";
          ctx.beginPath();
          planeProj.forEach((p, idx) => {
            if (idx === 0) ctx.moveTo(scaleX(p.x), scaleY(p.y));
            else ctx.lineTo(scaleX(p.x), scaleY(p.y));
          });
          ctx.closePath();
          ctx.fill();

          ctx.strokeStyle = "#94a3b8";
          ctx.lineWidth = 1.4;
          ctx.beginPath();
          ctx.moveTo(scaleX(origin.x), scaleY(origin.y));
          ctx.lineTo(scaleX(axisX.x), scaleY(axisX.y));
          ctx.stroke();
          ctx.beginPath();
          ctx.moveTo(scaleX(origin.x), scaleY(origin.y));
          ctx.lineTo(scaleX(axisZ.x), scaleY(axisZ.y));
          ctx.stroke();
          ctx.beginPath();
          ctx.moveTo(scaleX(origin.x), scaleY(origin.y));
          ctx.lineTo(scaleX(axisY.x), scaleY(axisY.y));
          ctx.stroke();

          ctx.fillStyle = "#0f172a";
          ctx.font = "12px system-ui, sans-serif";
          ctx.fillText("Marketing (X1)", scaleX(axisX.x) + 4, scaleY(axisX.y));
          ctx.fillText("Price (X2)", scaleX(axisZ.x) + 4, scaleY(axisZ.y));
          ctx.fillText("Sales (Y)", scaleX(axisY.x) + 4, scaleY(axisY.y) - 4);

          ctx.strokeStyle = "#cbd5f6";
          ctx.lineWidth = 1;
          for (let x1 = x1Min; x1 <= x1Max + 0.01; x1 += 1) {
            ctx.beginPath();
            for (let x2 = x2Min; x2 <= x2Max + 0.01; x2 += 0.5) {
              const y = coeffs.b0 + coeffs.b1 * x1 + coeffs.b2 * x2;
              const p = project(x1, x2, y, az, el);
              if (x2 === x2Min) ctx.moveTo(scaleX(p.x), scaleY(p.y));
              else ctx.lineTo(scaleX(p.x), scaleY(p.y));
            }
            ctx.stroke();
          }

          ctx.fillStyle = "rgba(43, 109, 233, 0.6)";
          proj.forEach((p) => {
            ctx.beginPath();
            ctx.arc(scaleX(p.x), scaleY(p.y), 3, 0, Math.PI * 2);
            ctx.fill();
          });
        }

        function draw() {
          const view = viewInput.value;
          const coeffs = {
            b0: Number(b0Input.value),
            b1: Number(b1Input.value),
            b2: Number(b2Input.value)
          };
          if (view === "cube") {
            azInput.disabled = false;
            elInput.disabled = false;
            drawCube(coeffs);
          } else if (view === "x1y") {
            azInput.disabled = true;
            elInput.disabled = true;
            drawFace(
              points.map((p) => p.x1),
              points.map((p) => p.y),
              "Marketing (X1)",
              "Sales (Y)"
            );
          } else if (view === "x2y") {
            azInput.disabled = true;
            elInput.disabled = true;
            drawFace(
              points.map((p) => p.x2),
              points.map((p) => p.y),
              "Price (X2)",
              "Sales (Y)"
            );
          } else {
            azInput.disabled = true;
            elInput.disabled = true;
            drawFace(
              points.map((p) => p.x1),
              points.map((p) => p.x2),
              "Marketing (X1)",
              "Price (X2)"
            );
          }
        }

        runBtn.addEventListener("click", resample);
        [b0Input, b1Input, b2Input].forEach((input) => input.addEventListener("input", resample));
        viewInput.addEventListener("change", draw);
        azInput.addEventListener("input", draw);
        elInput.addEventListener("input", draw);
        resample();
      }

      function setupDummyCategorical() {
        const baseInput = byId("dummy-base");
        const slopeInput = byId("dummy-slope");
        const gapInput = byId("dummy-gap");
        const kInput = byId("dummy-k");
        const toggleInput = byId("dummy-toggle");
        const runBtn = byId("dummy-run");
        const noteOut = byId("dummy-note");
        const canvas = byId("dummy-canvas");
        const ctx = canvas.getContext("2d");
        let points = [];

        function resample() {
          const k = toggleInput.checked ? 2 : Number(kInput.value);
          points = [];
          for (let cat = 0; cat < k; cat += 1) {
            const xVals = Array.from({ length: 25 }, () => (Math.random() * 6) - 3);
            xVals.forEach((x) => {
              const y =
                Number(baseInput.value) +
                Number(slopeInput.value) * x +
                Number(gapInput.value) * cat +
                normalSample(0, 0.5);
              points.push({ x, y, cat });
            });
          }
          draw();
        }

        function draw() {
          const k = toggleInput.checked ? 2 : Number(kInput.value);
          kInput.disabled = toggleInput.checked;
          noteOut.textContent = toggleInput.checked
            ? "Binary dummy mode: two parallel lines."
            : `Categorical mode: ${k} categories (m - 1 dummies).`;

          const xs = points.map((p) => p.x);
          const ys = points.map((p) => p.y);
          const padding = 40;
          const minX = Math.min(...xs);
          const maxX = Math.max(...xs);
          const minY = Math.min(...ys);
          const maxY = Math.max(...ys);
          const scaleX = (x) =>
            padding + ((x - minX) / (maxX - minX)) * (canvas.width - 2 * padding);
          const scaleY = (y) =>
            canvas.height - padding - ((y - minY) / (maxY - minY)) * (canvas.height - 2 * padding);

          ctx.clearRect(0, 0, canvas.width, canvas.height);
          drawAxes(ctx, canvas.width, canvas.height, padding);
          const colors = ["#2563eb", "#f97316", "#22c55e", "#a855f7"];
          points.forEach((p) => {
            ctx.fillStyle = colors[p.cat % colors.length];
            ctx.beginPath();
            ctx.arc(scaleX(p.x), scaleY(p.y), 3, 0, Math.PI * 2);
            ctx.fill();
          });

          for (let cat = 0; cat < k; cat += 1) {
            const intercept = Number(baseInput.value) + Number(gapInput.value) * cat;
            const slope = Number(slopeInput.value);
            ctx.strokeStyle = colors[cat % colors.length];
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(scaleX(minX), scaleY(intercept + slope * minX));
            ctx.lineTo(scaleX(maxX), scaleY(intercept + slope * maxX));
            ctx.stroke();
          }
        }

        [baseInput, slopeInput, gapInput, kInput].forEach((input) => {
          input.addEventListener("input", resample);
        });
        toggleInput.addEventListener("change", resample);
        runBtn.addEventListener("click", resample);
        resample();
      }

      function setupInteractionViz() {
        const interceptInput = byId("intercept-base");
        const slopeInput = byId("intercept-slope");
        const deltaInput = byId("intercept-delta");
        const runBtn = byId("intercept-run");
        const canvas = byId("interact-canvas");
        const ctx = canvas.getContext("2d");
        let points = [];

        function resample() {
          const intercept = Number(interceptInput.value);
          const slope = Number(slopeInput.value);
          const delta = Number(deltaInput.value);
          points = [];
          for (let group = 0; group < 2; group += 1) {
            const xVals = Array.from({ length: 35 }, () => (Math.random() * 6) - 3);
            xVals.forEach((x) => {
              const b = slope + delta * group;
              const y = intercept + b * x + normalSample(0, 0.7);
              points.push({ x, y, group });
            });
          }
          draw();
        }

        function draw() {
          const xs = points.map((p) => p.x);
          const ys = points.map((p) => p.y);
          const padding = 40;
          const minX = Math.min(...xs);
          const maxX = Math.max(...xs);
          const minY = Math.min(...ys);
          const maxY = Math.max(...ys);
          const scaleX = (x) =>
            padding + ((x - minX) / (maxX - minX)) * (canvas.width - 2 * padding);
          const scaleY = (y) =>
            canvas.height - padding - ((y - minY) / (maxY - minY)) * (canvas.height - 2 * padding);

          ctx.clearRect(0, 0, canvas.width, canvas.height);
          drawAxes(ctx, canvas.width, canvas.height, padding);
          const colors = ["#2563eb", "#f97316"];
          points.forEach((p) => {
            ctx.fillStyle = colors[p.group];
            ctx.beginPath();
            ctx.arc(scaleX(p.x), scaleY(p.y), 3, 0, Math.PI * 2);
            ctx.fill();
          });

          const intercept = Number(interceptInput.value);
          const slope = Number(slopeInput.value);
          const delta = Number(deltaInput.value);
          [0, 1].forEach((group) => {
            const b = slope + delta * group;
            ctx.strokeStyle = colors[group];
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(scaleX(minX), scaleY(intercept + b * minX));
            ctx.lineTo(scaleX(maxX), scaleY(intercept + b * maxX));
            ctx.stroke();
          });
        }

        runBtn.addEventListener("click", resample);
        [interceptInput, slopeInput, deltaInput].forEach((input) =>
          input.addEventListener("input", resample)
        );
        resample();
      }

      function setupQuizzes() {
        document.querySelectorAll(".quiz").forEach((quiz) => {
          const correct = quiz.dataset.answer;
          const button = quiz.querySelector(".check-btn");
          const feedback = quiz.querySelector(".feedback");

          button.addEventListener("click", () => {
            const selected = quiz.querySelector("input:checked");
            if (!selected) {
              feedback.textContent = "Select an answer first.";
              feedback.className = "feedback";
              return;
            }
            if (selected.value === correct) {
              feedback.textContent = "Correct. Nice work.";
              feedback.className = "feedback correct";
            } else {
              feedback.textContent = "Not quite. Review the concept and try again.";
              feedback.className = "feedback wrong";
            }
          });
        });
      }

      function setupHeteroViz() {
        const nInput = byId("hetero-n");
        const levelInput = byId("hetero-level");
        const nLabel = byId("hetero-n-label");
        const levelLabel = byId("hetero-level-label");
        const runBtn = byId("hetero-run");
        const slopeOut = byId("hetero-slope");
        const noteOut = byId("hetero-note");
        const scatter = byId("hetero-canvas");
        const resid = byId("resid-canvas");
        const ctxScatter = scatter.getContext("2d");
        const ctxResid = resid.getContext("2d");

        function updateLabels() {
          nLabel.textContent = nInput.value;
          levelLabel.textContent = fmt(levelInput.value, 1);
        }

        function simulate() {
          updateLabels();
          const n = Number(nInput.value);
          const level = Number(levelInput.value);
          const xs = Array.from({ length: n }, () => (Math.random() * 4) - 2);
          const ys = xs.map((x) => 1 + 0.8 * x + normalSample(0, 1 + level * Math.abs(x)));

          const meanX = xs.reduce((s, v) => s + v, 0) / n;
          const meanY = ys.reduce((s, v) => s + v, 0) / n;
          const ssX = xs.reduce((s, v) => s + (v - meanX) ** 2, 0);
          const cov = xs.reduce((s, v, i) => s + (v - meanX) * (ys[i] - meanY), 0);
          const slope = cov / ssX;
          const intercept = meanY - slope * meanX;

          const fitted = xs.map((x) => intercept + slope * x);
          const residuals = ys.map((y, i) => y - fitted[i]);

          slopeOut.textContent = fmt(slope, 2);
          noteOut.textContent = level > 0.8 ? "Clear heteroskedasticity" : "Mostly homoskedastic";

          const drawScatter = () => {
            const padding = 30;
            const w = scatter.width;
            const h = scatter.height;
            const minX = -2;
            const maxX = 2;
            const minY = Math.min(...ys);
            const maxY = Math.max(...ys);
            const scaleX = (x) => padding + ((x - minX) / (maxX - minX)) * (w - 2 * padding);
            const scaleY = (y) => h - padding - ((y - minY) / (maxY - minY)) * (h - 2 * padding);

            ctxScatter.clearRect(0, 0, w, h);
            drawAxes(ctxScatter, w, h, padding);

            ctxScatter.fillStyle = "rgba(59, 130, 246, 0.6)";
            xs.forEach((x, i) => {
              ctxScatter.beginPath();
              ctxScatter.arc(scaleX(x), scaleY(ys[i]), 3, 0, Math.PI * 2);
              ctxScatter.fill();
            });

            ctxScatter.strokeStyle = "#f97316";
            ctxScatter.lineWidth = 2;
            ctxScatter.beginPath();
            ctxScatter.moveTo(scaleX(minX), scaleY(intercept + slope * minX));
            ctxScatter.lineTo(scaleX(maxX), scaleY(intercept + slope * maxX));
            ctxScatter.stroke();
          };

          const drawResiduals = () => {
            const padding = 30;
            const w = resid.width;
            const h = resid.height;
            const minX = Math.min(...fitted);
            const maxX = Math.max(...fitted);
            const maxAbs = Math.max(...residuals.map((r) => Math.abs(r)));
            const scaleX = (x) => padding + ((x - minX) / (maxX - minX)) * (w - 2 * padding);
            const scaleY = (r) => h / 2 - (r / maxAbs) * (h / 2 - padding);

            ctxResid.clearRect(0, 0, w, h);
            drawAxes(ctxResid, w, h, padding);
            ctxResid.strokeStyle = "#cbd5f6";
            ctxResid.beginPath();
            ctxResid.moveTo(padding, h / 2);
            ctxResid.lineTo(w - padding, h / 2);
            ctxResid.stroke();

            ctxResid.fillStyle = "rgba(248, 113, 113, 0.7)";
            residuals.forEach((r, i) => {
              ctxResid.beginPath();
              ctxResid.arc(scaleX(fitted[i]), scaleY(r), 3, 0, Math.PI * 2);
              ctxResid.fill();
            });
          };

          drawScatter();
          drawResiduals();
        }

        nInput.addEventListener("input", simulate);
        levelInput.addEventListener("input", simulate);
        runBtn.addEventListener("click", simulate);
        simulate();
      }

      function setupCollinearityViz() {
        const rInput = byId("collin-r");
        const rLabel = byId("collin-r-label");
        const vifOut = byId("collin-vif");
        const intOut = byId("collin-int");
        const canvas = byId("collin-canvas");
        const ctx = canvas.getContext("2d");

        function draw() {
          const r = Number(rInput.value);
          rLabel.textContent = fmt(r, 2);
          const n = 200;
          const x1 = Array.from({ length: n }, () => normalSample(0, 1));
          const x2 = x1.map((x) => r * x + Math.sqrt(1 - r * r) * normalSample(0, 1));
          const vif = 1 / (1 - r * r);
          vifOut.textContent = fmt(vif, 2);
          intOut.textContent = vif > 5 ? "High multicollinearity" : "Manageable";

          const padding = 30;
          const w = canvas.width;
          const h = canvas.height;
          const minX = Math.min(...x1);
          const maxX = Math.max(...x1);
          const minY = Math.min(...x2);
          const maxY = Math.max(...x2);
          const scaleX = (x) => padding + ((x - minX) / (maxX - minX)) * (w - 2 * padding);
          const scaleY = (y) => h - padding - ((y - minY) / (maxY - minY)) * (h - 2 * padding);

          ctx.clearRect(0, 0, w, h);
          drawAxes(ctx, w, h, padding);

          ctx.fillStyle = "rgba(16, 185, 129, 0.6)";
          for (let i = 0; i < n; i += 1) {
            ctx.beginPath();
            ctx.arc(scaleX(x1[i]), scaleY(x2[i]), 3, 0, Math.PI * 2);
            ctx.fill();
          }
        }

        rInput.addEventListener("input", draw);
        draw();
      }

      function setupMiniChecks() {
        document.querySelectorAll(".mini-check").forEach((check) => {
          const correct = check.dataset.answer;
          const button = check.querySelector(".check-btn");
          const select = check.querySelector("select");
          const feedback = check.querySelector(".feedback");

          button.addEventListener("click", () => {
            if (!select.value) {
              feedback.textContent = "Select an option first.";
              feedback.className = "feedback";
              return;
            }
            if (select.value === correct) {
              feedback.textContent = "Correct.";
              feedback.className = "feedback correct";
            } else {
              feedback.textContent = "Not quite. Try again.";
              feedback.className = "feedback wrong";
            }
          });
        });
      }

      async function setupWebRBench() {
        const output = byId("r-output");
        const runBtn = byId("r-run");
        const resetBtn = byId("r-reset");
        const buildBtn = byId("r-build");
        const codeArea = byId("r-code");
        const canvas = byId("r-plot");
        const ctx = canvas.getContext("2d");

        const nInput = byId("r-n");
        const rhoInput = byId("r-rho");
        const b1Input = byId("r-b1");
        const b2Input = byId("r-b2");
        const b3Input = byId("r-b3");
        const sdInput = byId("r-sd");

        const defaultParams = {
          n: 250,
          rho: 0.6,
          b1: 1.5,
          b2: 0.8,
          b3: -0.5,
          sigma: 1.5
        };

        function buildCode() {
          const n = Number(nInput.value);
          const rho = Number(rhoInput.value);
          const b1 = Number(b1Input.value);
          const b2 = Number(b2Input.value);
          const b3 = Number(b3Input.value);
          const sigma = Number(sdInput.value);
          return `set.seed(101)
n <- ${n}
rho <- ${rho}
b1 <- ${b1}
b2 <- ${b2}
b3 <- ${b3}
sigma <- ${sigma}

x1 <- rnorm(n)
x2 <- rho * x1 + sqrt(1 - rho^2) * rnorm(n)
x3 <- rnorm(n)
y <- 2 + b1 * x1 + b2 * x2 + b3 * x3 + rnorm(n, 0, sigma)
df <- data.frame(y, x1, x2, x3)

fit <- lm(y ~ x1 + x2 + x3, df)
cat("OLS summary\\n")
print(summary(fit))

vif <- sapply(c("x1", "x2", "x3"), function(v) {
  others <- setdiff(c("x1", "x2", "x3"), v)
  f <- as.formula(paste(v, "~", paste(others, collapse = "+")))
  r2 <- summary(lm(f, df))$r.squared
  1 / (1 - r2)
})
cat("\\nVIF\\n")
print(round(vif, 2))

par(mfrow = c(1, 2))
plot(fitted(fit), resid(fit),
     main = "Residuals vs Fitted",
     xlab = "Fitted", ylab = "Residuals",
     col = "#60a5fa", pch = 16)
abline(h = 0, col = "#f87171")
qqnorm(resid(fit), main = "Normal Q-Q", col = "#34d399")
qqline(resid(fit), col = "#1f2937")`;
        }

        function reset() {
          nInput.value = defaultParams.n;
          rhoInput.value = defaultParams.rho;
          b1Input.value = defaultParams.b1;
          b2Input.value = defaultParams.b2;
          b3Input.value = defaultParams.b3;
          sdInput.value = defaultParams.sigma;
          codeArea.value = buildCode();
        }

        function clearOutput() {
          output.textContent = "";
          ctx.clearRect(0, 0, canvas.width, canvas.height);
        }

        let webRConsole = null;
        try {
          const { Console } = await import("https://webr.r-wasm.org/latest/webr.mjs");
          webRConsole = new Console({
            stdout: (line) => {
              output.textContent += `${line}\n`;
            },
            stderr: (line) => {
              output.textContent += `${line}\n`;
            },
            prompt: (line) => {
              output.textContent += line;
            },
            canvasImage: (img) => {
              ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
            },
            canvasNewPage: () => {
              ctx.clearRect(0, 0, canvas.width, canvas.height);
            }
          });
          await webRConsole.run();
          await webRConsole.stdin("options(device=webr::canvas(450, 260))");
          output.textContent = "webR is ready. Update parameters and run the code.";
          runBtn.disabled = false;
        } catch (err) {
          output.textContent = `webR failed to load: ${err.message}`;
        }

        buildBtn.addEventListener("click", () => {
          codeArea.value = buildCode();
        });

        resetBtn.addEventListener("click", () => {
          reset();
          clearOutput();
          output.textContent = "Reset to defaults. Click Run R to execute.";
        });

        runBtn.addEventListener("click", async () => {
          if (!webRConsole) return;
          clearOutput();
          await webRConsole.stdin(codeArea.value);
        });

        reset();
      }

      reorderSections();
      setupTheoryCards();
      setupViewSettings();
      setupCorrelationModule("corr6");
      setupCorrelationModule("corr8");
      setupLineExplorer();
      setupFitByEye();
      setupRegressionOutput();
      setupSumSquares();
      setupAssumptionViz();
      setupPlaneViz();
      setupDummyCategorical();
      setupInteractionViz();
      setupQuizzes();
      setupMiniChecks();
      setupHeteroViz();
      setupCollinearityViz();
      setupWebRBench();
    </script>
  </body>
  </html>
