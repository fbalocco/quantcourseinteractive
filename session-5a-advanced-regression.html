<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Session 5A - Advanced Regression Methods</title>
    <script>
      window.MathJax = {
        tex: { inlineMath: [["\\(", "\\)"]], displayMath: [["$$", "$$"]] }
      };
    </script>
    <script defer src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <style>
      :root {
        color-scheme: light;
        --bg: #f7f8fc;
        --card: #ffffff;
        --text: #1c1f24;
        --muted: #5d6473;
        --border: #e3e7f1;
        --accent: #2b6de9;
        --accent-2: #1f4fb1;
        --success: #1c7c54;
        --warning: #d97706;
      }

      * {
        box-sizing: border-box;
      }

      body {
        margin: 0;
        font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
        color: var(--text);
        background: var(--bg);
        line-height: 1.6;
        padding-top: 70px;
      }

      a {
        color: var(--accent);
        text-decoration: none;
      }

      a:hover {
        color: var(--accent-2);
        text-decoration: underline;
      }

      header {
        background: linear-gradient(135deg, #eaf0ff, #ffffff);
        border-bottom: 1px solid var(--border);
      }

      .container {
        max-width: min(1320px, 96vw);
        margin: 0 auto;
        padding: 24px 20px 60px;
      }

      .hero {
        display: grid;
        gap: 12px;
        padding: 28px 0 18px;
      }

      .breadcrumbs {
        font-size: 14px;
        color: var(--muted);
      }

      .hero h1 {
        margin: 0;
        font-size: 32px;
      }

      .hero p {
        margin: 0;
        color: var(--muted);
        max-width: 920px;
      }

      .section {
        margin-top: 28px;
        display: grid;
        gap: 16px;
      }

      .card {
        background: var(--card);
        border: 1px solid var(--border);
        border-radius: 14px;
        padding: 18px;
        box-shadow: 0 12px 24px rgba(24, 34, 72, 0.06);
      }

      .card h3 {
        margin-top: 0;
      }

      .grid-2 {
        display: grid;
        gap: 16px;
        grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
      }

      .tag {
        display: inline-block;
        font-size: 12px;
        letter-spacing: 0.08em;
        text-transform: uppercase;
        color: var(--muted);
      }

      .pill {
        display: inline-block;
        border: 1px solid var(--border);
        border-radius: 999px;
        padding: 4px 10px;
        font-size: 12px;
        color: var(--muted);
        background: #f2f4fa;
      }

      .topbar {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        height: 56px;
        background: #ffffff;
        border-bottom: 1px solid var(--border);
        display: flex;
        align-items: center;
        gap: 16px;
        padding: 0 16px;
        z-index: 1000;
      }

      .topbar-link {
        font-weight: 600;
        color: var(--accent);
      }

      .topbar-progress {
        flex: 1;
        display: grid;
        gap: 4px;
      }

      .progress-track {
        height: 6px;
        background: #e5e7eb;
        border-radius: 999px;
        overflow: hidden;
      }

      .progress-bar {
        height: 100%;
        width: 0%;
        background: var(--accent);
        transition: width 0.2s ease;
      }

      .progress-text {
        font-size: 12px;
        color: var(--muted);
      }

      .topbar-actions {
        display: flex;
        align-items: center;
        gap: 8px;
      }

      .settings-panel {
        position: fixed;
        top: 64px;
        right: 16px;
        background: #ffffff;
        border: 1px solid var(--border);
        border-radius: 12px;
        padding: 12px;
        box-shadow: 0 10px 24px rgba(24, 34, 72, 0.12);
        z-index: 1001;
        display: none;
      }

      .settings-panel.open {
        display: grid;
        gap: 8px;
      }

      .settings-title {
        font-weight: 600;
        font-size: 13px;
      }

      .controls {
        display: grid;
        gap: 10px;
        margin-top: 12px;
      }

      .control-row {
        display: grid;
        gap: 6px;
      }

      label {
        font-size: 13px;
        color: var(--muted);
      }

      input[type="range"],
      input[type="number"],
      select,
      textarea {
        width: 100%;
      }

      .btn {
        background: var(--accent);
        color: #fff;
        border: none;
        padding: 10px 14px;
        border-radius: 10px;
        cursor: pointer;
        font-weight: 600;
        font-size: 14px;
      }

      .btn.secondary {
        background: #e9eefc;
        color: var(--accent-2);
      }

      .btn:disabled {
        opacity: 0.6;
        cursor: not-allowed;
      }

      .stats {
        display: grid;
        gap: 8px;
        grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
        margin-top: 12px;
      }

      .stat {
        background: #f5f7ff;
        border-radius: 10px;
        padding: 10px;
        font-size: 13px;
      }

      .small {
        font-size: 12px;
        color: var(--muted);
      }

      .center {
        text-align: center;
      }

      .equation {
        font-size: 13px;
        background: #f5f7ff;
        border: 1px dashed #d7deef;
        border-radius: 10px;
        padding: 8px 10px;
        margin: 8px 0 12px;
        font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
      }

      .output-table {
        width: 100%;
        border-collapse: collapse;
        font-size: 13px;
        margin-top: 12px;
      }

      .output-table th,
      .output-table td {
        padding: 6px 8px;
        border-bottom: 1px solid var(--border);
        text-align: left;
      }

      .output-table th {
        color: var(--muted);
        font-weight: 600;
      }

      .btn-row {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
      }

      canvas {
        width: 100%;
        border: 1px solid var(--border);
        border-radius: 12px;
        background: #fbfcff;
      }

      .quiz {
        display: grid;
        gap: 10px;
      }

      .quiz label {
        font-size: 14px;
        color: var(--text);
      }

      .feedback {
        font-size: 13px;
        padding: 8px 10px;
        border-radius: 8px;
        background: #f5f7ff;
        color: var(--muted);
      }

      .feedback.correct {
        background: #e7f6ee;
        color: var(--success);
      }

      .feedback.wrong {
        background: #fff4e5;
        color: var(--warning);
      }

      .bench {
        display: grid;
        gap: 12px;
      }

      .bench textarea {
        min-height: 180px;
        font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
        font-size: 12px;
        border: 1px solid var(--border);
        border-radius: 10px;
        padding: 10px;
      }

      .bench-output {
        display: grid;
        gap: 12px;
      }

      pre {
        margin: 0;
        background: #0f172a;
        color: #e2e8f0;
        padding: 12px;
        border-radius: 12px;
        min-height: 140px;
        overflow-x: auto;
        font-size: 12px;
      }

      ul {
        margin: 0 0 0 18px;
      }

      .callout {
        border-left: 4px solid #9bb8ff;
        padding-left: 12px;
        color: var(--muted);
      }

      .topic-list {
        list-style: none;
        margin: 0;
        padding: 0;
        display: grid;
        gap: 12px;
      }

      .topic-card {
        background: #fdfdff;
        border: 1px dashed #d8e1f6;
        border-radius: 12px;
        padding: 14px;
        display: grid;
        gap: 8px;
      }

      .topic-card h4 {
        margin: 0;
        font-size: 16px;
      }

      .card-grid {
        display: grid;
        gap: 16px;
        grid-template-columns: minmax(320px, 1.15fr) 2.15fr;
        align-items: start;
      }

      .card-left {
        display: grid;
        gap: 8px;
      }

      .card-right {
        display: grid;
        gap: 12px;
      }

      /* In single-card view, let theory and practice scroll independently. */
      .view-mode-single .card-left,
      .view-mode-single .card-right {
        max-height: var(--split-pane-height, 70vh);
        overflow-y: auto;
        overscroll-behavior: contain;
        scrollbar-gutter: stable;
        padding-right: 6px;
      }

      /* In all-cards view, keep theory visible while the page scrolls. */
      @media (min-width: 901px) {
        .view-mode-all .topic-card .card-left {
          position: sticky;
          top: 72px;
        }
      }

      .theory {
        font-size: 13px;
        color: var(--muted);
      }

      .exercise-intro {
        font-size: 12px;
        color: var(--muted);
      }

      footer {
        margin-top: 32px;
        font-size: 12px;
        color: var(--muted);
      }

      @media (max-width: 900px) {
        .card-grid {
          grid-template-columns: 1fr;
        }
      }

      .topic-card ul {
        margin: 0 0 0 18px;
      }

      .topic-figure {
        margin-top: 6px;
        background: #f5f7ff;
        border: 1px solid #e1e7f8;
        border-radius: 10px;
        padding: 8px;
        display: grid;
        justify-items: center;
      }

      .topic-figure svg {
        max-width: 100%;
        height: auto;
      }

      .topic-note {
        font-size: 12px;
        color: var(--muted);
      }

      .mini-check {
        display: grid;
        gap: 6px;
        margin-top: 8px;
        padding: 10px;
        border-radius: 10px;
        border: 1px solid #e1e7f8;
        background: #f6f8ff;
      }

      .mini-check label {
        font-size: 12px;
        color: var(--muted);
      }

      .mini-check select {
        padding: 6px 8px;
        border-radius: 8px;
        border: 1px solid var(--border);
        background: #fff;
        font-size: 13px;
      }
    </style>
  </head>
  <body>
    <div class="topbar">
      <a class="topbar-link" href="index.html">All modules</a>
      <div class="topbar-progress">
        <div class="progress-track"><div class="progress-bar" id="progress-bar"></div></div>
        <div class="progress-text" id="progress-text">Cards</div>
      </div>
      <div class="topbar-actions">
        <button class="btn secondary" id="prev-card" type="button">Prev</button>
        <button class="btn secondary" id="next-card" type="button">Next</button>
        <button class="btn" id="settings-btn" type="button">Settings</button>
      </div>
    </div>
    <div class="settings-panel" id="settings-panel">
      <div class="settings-title">View settings</div>
      <label><input type="radio" name="view-mode" value="all"> Show all cards</label>
      <label><input type="radio" name="view-mode" value="single"> Card-by-card</label>
    </div>
    <header>
      <div class="container hero">
        <div class="breadcrumbs"><a href="index.html">All modules</a> / Session 5A</div>
        <span class="tag">RDM Quantitative Track</span>
        <h1>Advanced Regression Methods</h1>
        <p>
          Explore non-linear relationships, limited dependent variables, and panel data.
          Learn when to use logit or probit models and how fixed effects handle unobserved heterogeneity.
        </p>
        <div class="pill">Session 5A - 5 Mar 2024</div>
      </div>
    </header>

    <main class="container">
      <section class="section card">
        <h3>Learning goals</h3>
        <ul>
          <li>Diagnose non-linear relationships and model them with polynomials or logs.</li>
          <li>Understand why linear probability models can fail.</li>
          <li>Interpret logit coefficients as odds ratios.</li>
          <li>Recognize the structure of panel data and the role of fixed effects.</li>
          <li>Compare pooled and fixed effects estimates.</li>
        </ul>
      </section>

      <section class="section card">
        <h3>Syllabus walkthrough (slide order)</h3>
        <p class="small">Selected topics follow the slide sequence.</p>
        <ol class="topic-list">
          <li class="topic-card">
            <h4>1. Non-linearity explorer</h4>
            <p class="small">
              Explore linear, quadratic, cubic, and log shapes using an example with ad spend (X)
              and sales (Y).
            </p>
            <div class="controls grid-2">
              <div class="control-row">
                <label>Shape</label>
                <select id="nl-type">
                  <option value="linear">Linear</option>
                  <option value="quadratic">Quadratic</option>
                  <option value="cubic">Cubic</option>
                  <option value="log">Log</option>
                </select>
              </div>
              <div class="control-row">
                <label>Intercept (b0)</label>
                <input id="nl-b0" type="range" min="-2" max="2" step="0.1" value="0.2">
              </div>
              <div class="control-row">
                <label>Linear term (b1)</label>
                <input id="nl-b1" type="range" min="-2" max="2" step="0.1" value="0.8">
              </div>
              <div class="control-row">
                <label>Quadratic term (b2)</label>
                <input id="nl-b2" type="range" min="-1" max="1" step="0.1" value="-0.4">
              </div>
              <div class="control-row">
                <label>Cubic term (b3)</label>
                <input id="nl-b3" type="range" min="-0.6" max="0.6" step="0.05" value="0.1">
              </div>
            </div>
            <canvas id="nl-canvas" width="820" height="320" aria-label="Non-linearity explorer"></canvas>
            <div class="stats">
              <div class="stat">Shape: <span id="nl-shape">-</span></div>
              <div class="stat">Note: <span id="nl-note">-</span></div>
            </div>
            <div class="mini-check" data-answer="a">
              <label>Quick check: curvature suggests you may need...</label>
              <select>
                <option value="">Choose an answer</option>
                <option value="a">Non-linear terms</option>
                <option value="b">No model at all</option>
              </select>
              <button class="btn secondary check-btn" type="button">Check</button>
              <div class="feedback" aria-live="polite"></div>
            </div>
            <div class="mini-check" data-answer="b">
              <label>Quick check: an inverted U-shape often uses a...</label>
              <select>
                <option value="">Choose an answer</option>
                <option value="a">Positive quadratic term</option>
                <option value="b">Negative quadratic term</option>
              </select>
              <button class="btn secondary check-btn" type="button">Check</button>
              <div class="feedback" aria-live="polite"></div>
            </div>
          </li>
          <li class="topic-card">
            <h4>2. Fit linear vs non-linear models</h4>
            <p class="small">
              Compare a linear fit with a non-linear model for four cases: linear, quadratic, cubic, log.
            </p>
            <div class="controls grid-2">
              <div class="control-row">
                <label>Data generating shape</label>
                <select id="fit-type">
                  <option value="linear">Linear</option>
                  <option value="quadratic">Quadratic</option>
                  <option value="cubic">Cubic</option>
                  <option value="log">Log</option>
                </select>
              </div>
              <div class="control-row">
                <label>&nbsp;</label>
                <button class="btn" id="fit-run">Resample data</button>
              </div>
            </div>
            <canvas id="fit-model-canvas" width="820" height="240" aria-label="Linear vs non-linear fit"></canvas>
            <table class="output-table">
              <thead>
                <tr>
                  <th>Model</th>
                  <th>b0</th>
                  <th>b1</th>
                  <th>b2</th>
                  <th>b3</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td>Linear only</td>
                  <td id="fit-lin-b0">-</td>
                  <td id="fit-lin-b1">-</td>
                  <td id="fit-lin-b2">-</td>
                  <td id="fit-lin-b3">-</td>
                </tr>
                <tr>
                  <td>Non-linear</td>
                  <td id="fit-nl-b0">-</td>
                  <td id="fit-nl-b1">-</td>
                  <td id="fit-nl-b2">-</td>
                  <td id="fit-nl-b3">-</td>
                </tr>
              </tbody>
            </table>
            <div class="mini-check" data-answer="a">
              <label>Quick check: you test nonlinearity by checking whether...</label>
              <select>
                <option value="">Choose an answer</option>
                <option value="a">Higher-order terms are significant</option>
                <option value="b">R-squared is always 1</option>
              </select>
              <button class="btn secondary check-btn" type="button">Check</button>
              <div class="feedback" aria-live="polite"></div>
            </div>
          </li>
          <li class="topic-card">
            <h4>3. Which variables are binary?</h4>
            <p class="small">Select all variables that are binary (0/1).</p>
            <div class="controls grid-2" id="binary-options">
              <label><input type="checkbox" data-correct="true"> Churned (0/1)</label>
              <label><input type="checkbox" data-correct="false"> Age (years)</label>
              <label><input type="checkbox" data-correct="true"> Purchased (yes/no)</label>
              <label><input type="checkbox" data-correct="false"> Income (USD)</label>
              <label><input type="checkbox" data-correct="false"> Region (4 categories)</label>
              <label><input type="checkbox" data-correct="true"> Treated (0/1)</label>
            </div>
            <div class="controls">
              <button class="btn" id="binary-check">Check answers</button>
            </div>
            <div class="stats">
              <div class="stat">Correct selections: <span id="binary-score">-</span></div>
              <div class="stat">Feedback: <span id="binary-feedback">-</span></div>
            </div>
            <div class="mini-check" data-answer="a">
              <label>Quick check: a binary outcome is coded as...</label>
              <select>
                <option value="">Choose an answer</option>
                <option value="a">0/1</option>
                <option value="b">Any real number</option>
              </select>
              <button class="btn secondary check-btn" type="button">Check</button>
              <div class="feedback" aria-live="polite"></div>
            </div>
          </li>
          <li class="topic-card">
            <h4>4. Linear probability model (LPM)</h4>
            <p class="small">
              Regress churn (0/1) on price to predict Pr(Churn = 1). LPM is linear,
              so it can predict values below 0 or above 1. Those regions are highlighted.
            </p>
            <div class="equation">\(P(\text{Churn}=1)=b_0+b_1 \cdot \text{Price}\)</div>
            <div class="controls grid-2">
              <div class="control-row">
                <label>Intercept (b0)</label>
                <input id="lpm-b0" type="range" min="-0.5" max="1.5" step="0.05" value="0.2">
              </div>
              <div class="control-row">
                <label>Slope (b1)</label>
                <input id="lpm-b1" type="range" min="-0.6" max="0.6" step="0.05" value="0.3">
              </div>
            </div>
            <canvas id="lpm-canvas" width="820" height="240" aria-label="LPM fit"></canvas>
            <div class="stats">
              <div class="stat">Out of bounds: <span id="lpm-oob">-</span></div>
            </div>
            <div class="mini-check" data-answer="a">
              <label>Quick check: the LPM problem is that predictions can be...</label>
              <select>
                <option value="">Choose an answer</option>
                <option value="a">Below 0 or above 1</option>
                <option value="b">Only between 0 and 1</option>
              </select>
              <button class="btn secondary check-btn" type="button">Check</button>
              <div class="feedback" aria-live="polite"></div>
            </div>
          </li>
          <li class="topic-card">
            <h4>5. Logistic regression equation</h4>
            <p class="small">
              The logistic curve maps any linear predictor into probabilities between 0 and 1.
            </p>
            <div class="equation">\(p = \frac{1}{1+\exp(-(b_0+b_1 X))}\)</div>
            <div class="controls grid-2">
              <div class="control-row">
                <label>Intercept (b0)</label>
                <input id="logistic-b0" type="range" min="-2" max="2" step="0.1" value="-0.2">
              </div>
              <div class="control-row">
                <label>Slope (b1)</label>
                <input id="logistic-b1" type="range" min="-2" max="2" step="0.1" value="1.2">
              </div>
              <div class="control-row">
                <label>Predictor (X)</label>
                <input id="logistic-x" type="range" min="-3" max="3" step="0.2" value="0.6">
              </div>
            </div>
            <canvas id="logistic-canvas" width="820" height="240" aria-label="Logistic curve"></canvas>
            <div class="stats">
              <div class="stat">Probability at X: <span id="logistic-prob">-</span></div>
              <div class="stat">CDF link: <span id="logistic-cdf">-</span></div>
            </div>
            <div class="mini-check" data-answer="b">
              <label>Quick check: logistic regression outputs...</label>
              <select>
                <option value="">Choose an answer</option>
                <option value="a">Unbounded values</option>
                <option value="b">Probabilities between 0 and 1</option>
              </select>
              <button class="btn secondary check-btn" type="button">Check</button>
              <div class="feedback" aria-live="polite"></div>
            </div>
          </li>
          <li class="topic-card">
            <h4>6. Logistic vs logit mapping</h4>
            <p class="small">
              The logit is the log-odds transformation. The curves below show how z maps to p.
            </p>
            <div class="equation" id="map-eq-logit"></div>
            <div class="equation" id="map-eq-prob"></div>
            <div class="controls grid-2">
              <div class="control-row">
                <label>Intercept (b0)</label>
                <input id="map-b0" type="range" min="-2" max="2" step="0.1" value="0.2">
              </div>
              <div class="control-row">
                <label>Slope (b1)</label>
                <input id="map-b1" type="range" min="-2" max="2" step="0.1" value="1">
              </div>
              <div class="control-row">
                <label>Predictor (X)</label>
                <input id="map-x" type="range" min="-3" max="3" step="0.2" value="0.6">
              </div>
            </div>
            <canvas id="map-canvas" width="820" height="240" aria-label="Logit mapping"></canvas>
            <div class="stats">
              <div class="stat">p(X): <span id="map-prob">-</span></div>
              <div class="stat">logit(p): <span id="map-logit">-</span></div>
              <div class="stat">Odds ratio (exp b1): <span id="map-odds">-</span></div>
            </div>
            <div class="mini-check" data-answer="a">
              <label>Quick check: the logit is the log of...</label>
              <select>
                <option value="">Choose an answer</option>
                <option value="a">Odds</option>
                <option value="b">Probabilities squared</option>
              </select>
              <button class="btn secondary check-btn" type="button">Check</button>
              <div class="feedback" aria-live="polite"></div>
            </div>
          </li>
          <li class="topic-card">
            <h4>7. Logit fit on binary scatter</h4>
            <p class="small">
              Fit a logit model to simulated churn data. Interpret coefficients in log-odds and odds.
            </p>
            <div class="controls grid-2">
              <div class="control-row">
                <label>Sample size</label>
                <input id="logit-n" type="number" min="80" max="400" step="20" value="200">
              </div>
              <div class="control-row">
                <label>&nbsp;</label>
                <button class="btn" id="logit-run">Resample data</button>
              </div>
            </div>
            <canvas id="logit-fit-canvas" width="820" height="240" aria-label="Logit fit"></canvas>
            <table class="output-table">
              <thead>
                <tr>
                  <th>Term</th>
                  <th>Coef</th>
                  <th>SE</th>
                  <th>Odds ratio</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td>Intercept</td>
                  <td id="logit-b0">-</td>
                  <td id="logit-se0">-</td>
                  <td id="logit-or0">-</td>
                </tr>
                <tr>
                  <td>Price (X)</td>
                  <td id="logit-b1">-</td>
                  <td id="logit-se1">-</td>
                  <td id="logit-or1">-</td>
                </tr>
              </tbody>
            </table>
            <p class="small" id="logit-explain">-</p>
            <div class="mini-check" data-answer="b">
              <label>Quick check: exp(beta) in logit is an...</label>
              <select>
                <option value="">Choose an answer</option>
                <option value="a">Effect on variance</option>
                <option value="b">Odds ratio</option>
              </select>
              <button class="btn secondary check-btn" type="button">Check</button>
              <div class="feedback" aria-live="polite"></div>
            </div>
          </li>
          <li class="topic-card">
            <h4>8. Probit fit on binary scatter</h4>
            <p class="small">
              Fit a probit model to the same data and compare the probability transformation.
            </p>
            <div class="controls grid-2">
              <div class="control-row">
                <label>Sample size</label>
                <input id="probit-n" type="number" min="80" max="400" step="20" value="200">
              </div>
              <div class="control-row">
                <label>&nbsp;</label>
                <button class="btn" id="probit-run">Resample data</button>
              </div>
            </div>
            <canvas id="probit-fit-canvas" width="820" height="240" aria-label="Probit fit"></canvas>
            <table class="output-table">
              <thead>
                <tr>
                  <th>Term</th>
                  <th>Coef</th>
                  <th>SE</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td>Intercept</td>
                  <td id="probit-b0">-</td>
                  <td id="probit-se0">-</td>
                </tr>
                <tr>
                  <td>Price (X)</td>
                  <td id="probit-b1">-</td>
                  <td id="probit-se1">-</td>
                </tr>
              </tbody>
            </table>
            <p class="small" id="probit-explain">-</p>
            <div class="mini-check" data-answer="a">
              <label>Quick check: probit uses the...</label>
              <select>
                <option value="">Choose an answer</option>
                <option value="a">Normal CDF</option>
                <option value="b">Uniform CDF</option>
              </select>
              <button class="btn secondary check-btn" type="button">Check</button>
              <div class="feedback" aria-live="polite"></div>
            </div>
          </li>
          <li class="topic-card">
            <h4>9. Probit vs logit vs LPM</h4>
            <p class="small">
              Compare all three models on the same axes. LPM can leave the 0-1 range.
            </p>
            <div class="controls grid-2">
              <div class="control-row">
                <label>Predictor (X)</label>
                <input id="compare-x" type="range" min="-3" max="3" step="0.2" value="0.6">
              </div>
              <div class="control-row">
                <label>Slope (b1)</label>
                <input id="compare-b1" type="range" min="-2" max="2" step="0.2" value="1.1">
              </div>
            </div>
            <canvas id="compare-canvas" width="820" height="240" aria-label="LPM vs logit vs probit"></canvas>
            <div class="stats">
              <div class="stat">LPM: <span id="compare-lpm">-</span></div>
              <div class="stat">Logit: <span id="compare-logit">-</span></div>
              <div class="stat">Probit: <span id="compare-probit">-</span></div>
              <div class="stat">Odds ratio: <span id="compare-odds">-</span></div>
            </div>
            <div class="mini-check" data-answer="b">
              <label>Quick check: probit and logit often give...</label>
              <select>
                <option value="">Choose an answer</option>
                <option value="a">Completely different results</option>
                <option value="b">Similar conclusions</option>
              </select>
              <button class="btn secondary check-btn" type="button">Check</button>
              <div class="feedback" aria-live="polite"></div>
            </div>
          </li>
          <li class="topic-card">
            <h4>10. Poisson regression for count data</h4>
            <p class="small">
              Counts (e.g., number of visits) are modeled with a log link: E[Y|X] = exp(b0 + b1 X).
            </p>
            <div class="controls grid-2">
              <div class="control-row">
                <label>Intercept (b0)</label>
                <input id="pois-b0" type="range" min="-0.5" max="1.5" step="0.1" value="0.3">
              </div>
              <div class="control-row">
                <label>Slope (b1)</label>
                <input id="pois-b1" type="range" min="-0.5" max="0.8" step="0.05" value="0.25">
              </div>
              <div class="control-row">
                <label>&nbsp;</label>
                <button class="btn" id="pois-run">Resample data</button>
              </div>
            </div>
            <canvas id="pois-canvas" width="820" height="240" aria-label="Poisson regression fit"></canvas>
            <div class="stats">
              <div class="stat">Exp(b1): <span id="pois-exp">-</span></div>
              <div class="stat">Meaning: <span id="pois-meaning">-</span></div>
            </div>
            <div class="mini-check" data-answer="a">
              <label>Quick check: count data often uses...</label>
              <select>
                <option value="">Choose an answer</option>
                <option value="a">Poisson regression</option>
                <option value="b">ANOVA only</option>
              </select>
              <button class="btn secondary check-btn" type="button">Check</button>
              <div class="feedback" aria-live="polite"></div>
            </div>
          </li>
          <li class="topic-card">
            <h4>11. Panel dataset example</h4>
            <p class="small">
              Simulate a panel of firms followed over time. Sales (Y) moves with engagement (X),
              while segment (Z) is a time-invariant firm trait.
            </p>
            <p class="small">
              The regression goal is to estimate how engagement changes are associated with sales,
              while controlling for stable firm differences that do not change over time.
            </p>
            <div class="controls grid-2">
              <div class="control-row">
                <label>Individuals (N)</label>
                <input id="panel-n" type="range" min="6" max="20" step="1" value="10">
              </div>
              <div class="control-row">
                <label>Time periods (T)</label>
                <input id="panel-t" type="range" min="4" max="12" step="1" value="6">
              </div>
              <div class="control-row">
                <label><input id="panel-show-y" type="checkbox" checked> Outcome (Sales)</label>
              </div>
              <div class="control-row">
                <label><input id="panel-show-x" type="checkbox" checked> Time-varying X (Engagement)</label>
              </div>
              <div class="control-row">
                <label><input id="panel-show-z" type="checkbox" checked> Time-invariant Z (Segment)</label>
              </div>
              <div class="control-row">
                <label>Focus individual</label>
                <select id="panel-focus">
                  <option value="all">All</option>
                </select>
              </div>
            </div>
            <canvas id="panel-canvas" width="820" height="260" aria-label="Panel dataset overview"></canvas>
            <div class="stats">
              <div class="stat">Within variance: <span id="panel-within">-</span></div>
              <div class="stat">Between variance: <span id="panel-between">-</span></div>
            </div>
            <div class="small">First rows of the dataset</div>
            <table class="output-table" id="panel-table"></table>
          </li>
          <li class="topic-card">
            <h4>12. Panel regression models</h4>
            <p class="small">
              Estimate pooled, fixed effects, LSDV, and first-difference models from the same dataset.
            </p>
            <div class="controls">
              <div class="btn-row" id="panel-models">
                <button class="btn secondary" data-model="pooled">Pooled OLS</button>
                <button class="btn secondary" data-model="fe">Fixed effects</button>
                <button class="btn secondary" data-model="lsdv">LSDV</button>
                <button class="btn secondary" data-model="fd">First differences</button>
                <button class="btn secondary" data-model="re">Random effects</button>
              </div>
            </div>
            <table class="output-table">
              <thead>
                <tr>
                  <th>Term</th>
                  <th>Coef</th>
                  <th>Note</th>
                </tr>
              </thead>
              <tbody id="panel-coefs"></tbody>
            </table>
            <p class="small" id="panel-summary">-</p>
            <div class="card" style="margin-top: 16px;">
              <h3>Panel bias estimator (pooled vs fixed effects)</h3>
              <p class="callout">
                Increase correlation between unobserved effects and X to see pooled estimates drift.
              </p>
              <div class="controls grid-2">
                <div class="control-row">
                  <label>Correlation (rho): <strong id="panel-rho-label">0.4</strong></label>
                  <input id="panel-rho" type="range" min="0" max="0.9" step="0.05" value="0.4">
                </div>
                <div class="control-row">
                  <label>Individuals (N): <strong id="panel-n-label">80</strong></label>
                  <input id="panel-n-label-input" type="range" min="30" max="200" step="10" value="80">
                </div>
                <div class="control-row">
                  <label>Periods (T): <strong id="panel-t-label">6</strong></label>
                  <input id="panel-t-label-input" type="range" min="3" max="12" step="1" value="6">
                </div>
                <div class="control-row">
                  <label>&nbsp;</label>
                  <button class="btn" id="panel-bias-run">Resimulate</button>
                </div>
              </div>
              <canvas id="panel-bias-canvas" width="820" height="240" aria-label="Pooled vs fixed effects slopes"></canvas>
              <div class="stats">
                <div class="stat">Pooled slope: <span id="panel-pooled">-</span></div>
                <div class="stat">Fixed effects slope: <span id="panel-fe">-</span></div>
                <div class="stat">Bias note: <span id="panel-note">-</span></div>
              </div>
            </div>
            <div class="card" style="margin-top: 16px;">
              <h3>Fixed vs random effects lines</h3>
              <p class="small">
                Each colored line is a unit-specific fit. Fixed effects allow each unit its own intercept;
                random effects shrink intercepts toward the pooled line.
              </p>
              <div class="controls grid-2">
                <div class="control-row">
                  <label>Correlation (rho)</label>
                  <input id="fe-re-rho" type="range" min="0" max="0.9" step="0.05" value="0.4">
                </div>
                <div class="control-row">
                  <label>View</label>
                  <select id="fe-re-view">
                    <option value="fe">Fixed effects lines</option>
                    <option value="re">Random effects lines</option>
                  </select>
                </div>
                <div class="control-row">
                  <label>&nbsp;</label>
                  <button class="btn" id="fe-re-run">Resimulate</button>
                </div>
              </div>
              <canvas id="fe-re-canvas" width="820" height="260" aria-label="FE vs RE fitted lines"></canvas>
              <div class="stats">
                <div class="stat">FE slope: <span id="fe-re-fe">-</span></div>
                <div class="stat">RE slope: <span id="fe-re-re">-</span></div>
              </div>
              <div class="topic-note">Black line shows pooled fit; colored lines show unit fits.</div>
            </div>
          </li>
        </ol>
      </section>

      <section class="section" id="quick-check">
        <div class="card">
          <h3>Quick check</h3>
          <div class="quiz" data-answer="c">
            <strong>1) Which symbol is the error term?</strong>
            <label><input type="radio" name="q1" value="a"> b0</label>
            <label><input type="radio" name="q1" value="b"> b1</label>
            <label><input type="radio" name="q1" value="c"> e</label>
            <label><input type="radio" name="q1" value="d"> y</label>
            <button class="btn secondary check-btn">Check</button>
            <div class="feedback" aria-live="polite"></div>
          </div>

          <div class="quiz" data-answer="a">
            <strong>2) Multivariable regression includes:</strong>
            <label><input type="radio" name="q2" value="a"> Multiple predictors.</label>
            <label><input type="radio" name="q2" value="b"> Only one predictor.</label>
            <label><input type="radio" name="q2" value="c"> No intercept.</label>
            <label><input type="radio" name="q2" value="d"> Only categorical variables.</label>
            <button class="btn secondary check-btn">Check</button>
            <div class="feedback" aria-live="polite"></div>
          </div>

          <div class="quiz" data-answer="b">
            <strong>3) Panel data combines:</strong>
            <label><input type="radio" name="q3" value="a"> Only cross-sectional data.</label>
            <label><input type="radio" name="q3" value="b"> Cross-sectional and time variation.</label>
            <label><input type="radio" name="q3" value="c"> Only time series.</label>
            <label><input type="radio" name="q3" value="d"> Only experimental data.</label>
            <button class="btn secondary check-btn">Check</button>
            <div class="feedback" aria-live="polite"></div>
          </div>

          <div class="quiz" data-answer="a">
            <strong>4) Panel data follows the same units:</strong>
            <label><input type="radio" name="q4" value="a"> Over time.</label>
            <label><input type="radio" name="q4" value="b"> Only once.</label>
            <label><input type="radio" name="q4" value="c"> Only after treatment.</label>
            <label><input type="radio" name="q4" value="d"> Only across regions.</label>
            <button class="btn secondary check-btn">Check</button>
            <div class="feedback" aria-live="polite"></div>
          </div>

          <div class="quiz" data-answer="b">
            <strong>5) In Y_it, the i index refers to:</strong>
            <label><input type="radio" name="q5" value="a"> Time only.</label>
            <label><input type="radio" name="q5" value="b"> The subject.</label>
            <label><input type="radio" name="q5" value="c"> The regression slope.</label>
            <label><input type="radio" name="q5" value="d"> The error term.</label>
            <button class="btn secondary check-btn">Check</button>
            <div class="feedback" aria-live="polite"></div>
          </div>

          <div class="quiz" data-answer="a">
            <strong>6) A time-invariant variable:</strong>
            <label><input type="radio" name="q6" value="a"> Does not change across periods.</label>
            <label><input type="radio" name="q6" value="b"> Changes every period.</label>
            <label><input type="radio" name="q6" value="c"> Is always missing.</label>
            <label><input type="radio" name="q6" value="d"> Is binary only.</label>
            <button class="btn secondary check-btn">Check</button>
            <div class="feedback" aria-live="polite"></div>
          </div>

          <div class="quiz" data-answer="b">
            <strong>7) Time-varying variables:</strong>
            <label><input type="radio" name="q7" value="a"> Stay constant.</label>
            <label><input type="radio" name="q7" value="b"> Change across periods.</label>
            <label><input type="radio" name="q7" value="c"> Are always unobserved.</label>
            <label><input type="radio" name="q7" value="d"> Can only be categorical.</label>
            <button class="btn secondary check-btn">Check</button>
            <div class="feedback" aria-live="polite"></div>
          </div>

          <div class="quiz" data-answer="a">
            <strong>8) u_i captures:</strong>
            <label><input type="radio" name="q8" value="a"> Time-invariant unobservables.</label>
            <label><input type="radio" name="q8" value="b"> Time-varying shocks.</label>
            <label><input type="radio" name="q8" value="c"> Measurement error only.</label>
            <label><input type="radio" name="q8" value="d"> The dependent variable.</label>
            <button class="btn secondary check-btn">Check</button>
            <div class="feedback" aria-live="polite"></div>
          </div>

          <div class="quiz" data-answer="b">
            <strong>9) e_it represents:</strong>
            <label><input type="radio" name="q9" value="a"> Time-invariant traits.</label>
            <label><input type="radio" name="q9" value="b"> Time-varying shocks.</label>
            <label><input type="radio" name="q9" value="c"> The intercept.</label>
            <label><input type="radio" name="q9" value="d"> The slope on X.</label>
            <button class="btn secondary check-btn">Check</button>
            <div class="feedback" aria-live="polite"></div>
          </div>

          <div class="quiz" data-answer="a">
            <strong>10) The panel model includes u_i and e_it to capture:</strong>
            <label><input type="radio" name="q10" value="a"> Time-invariant and time-varying unobservables.</label>
            <label><input type="radio" name="q10" value="b"> Only observed variables.</label>
            <label><input type="radio" name="q10" value="c"> Only measurement error.</label>
            <label><input type="radio" name="q10" value="d"> Only treatment effects.</label>
            <button class="btn secondary check-btn">Check</button>
            <div class="feedback" aria-live="polite"></div>
          </div>

          <div class="quiz" data-answer="b">
            <strong>11) Pooled OLS assumes:</strong>
            <label><input type="radio" name="q11" value="a"> All unobservables are captured.</label>
            <label><input type="radio" name="q11" value="b"> Time-invariant effects are negligible.</label>
            <label><input type="radio" name="q11" value="c"> Fixed effects are always required.</label>
            <label><input type="radio" name="q11" value="d"> All variables are time-invariant.</label>
            <button class="btn secondary check-btn">Check</button>
            <div class="feedback" aria-live="polite"></div>
          </div>

          <div class="quiz" data-answer="a">
            <strong>12) Fixed effects primarily remove:</strong>
            <label><input type="radio" name="q12" value="a"> Time-invariant differences.</label>
            <label><input type="radio" name="q12" value="b"> All time-varying shocks.</label>
            <label><input type="radio" name="q12" value="c"> The dependent variable.</label>
            <label><input type="radio" name="q12" value="d"> The intercept only.</label>
            <button class="btn secondary check-btn">Check</button>
            <div class="feedback" aria-live="polite"></div>
          </div>

          <div class="quiz" data-answer="b">
            <strong>13) LSDV uses:</strong>
            <label><input type="radio" name="q13" value="a"> One dummy total.</label>
            <label><input type="radio" name="q13" value="b"> A dummy for each subject.</label>
            <label><input type="radio" name="q13" value="c"> A dummy for each time period only.</label>
            <label><input type="radio" name="q13" value="d"> No dummies at all.</label>
            <button class="btn secondary check-btn">Check</button>
            <div class="feedback" aria-live="polite"></div>
          </div>

          <div class="quiz" data-answer="a">
            <strong>14) First differencing removes:</strong>
            <label><input type="radio" name="q14" value="a"> Time-invariant unobservables.</label>
            <label><input type="radio" name="q14" value="b"> All predictors.</label>
            <label><input type="radio" name="q14" value="c"> Only time trends.</label>
            <label><input type="radio" name="q14" value="d"> Only noise.</label>
            <button class="btn secondary check-btn">Check</button>
            <div class="feedback" aria-live="polite"></div>
          </div>

          <div class="quiz" data-answer="b">
            <strong>15) Fixed effects coefficients represent:</strong>
            <label><input type="radio" name="q15" value="a"> Between-subject differences.</label>
            <label><input type="radio" name="q15" value="b"> Within-subject changes.</label>
            <label><input type="radio" name="q15" value="c"> The average intercept only.</label>
            <label><input type="radio" name="q15" value="d"> Random noise.</label>
            <button class="btn secondary check-btn">Check</button>
            <div class="feedback" aria-live="polite"></div>
          </div>

          <div class="quiz" data-answer="a">
            <strong>16) Random effects assumes u_i is:</strong>
            <label><input type="radio" name="q16" value="a"> Uncorrelated with predictors.</label>
            <label><input type="radio" name="q16" value="b"> Always zero.</label>
            <label><input type="radio" name="q16" value="c"> Perfectly correlated with X.</label>
            <label><input type="radio" name="q16" value="d"> Equal to the error term.</label>
            <button class="btn secondary check-btn">Check</button>
            <div class="feedback" aria-live="polite"></div>
          </div>
        </div>
      </section>

      <section class="section card" id="case-study">
        <h3>Case study: Predicting customer churn over time</h3>
        <p>
          A subscription business tracks customers monthly. The outcome is whether a
          customer churns (1/0). You also track engagement and price changes over time.
        </p>
        <ul>
          <li>Model churn with logit or probit, not linear probability.</li>
          <li>Interpret coefficients as changes in log odds and odds ratios.</li>
          <li>Use panel data to control for time-invariant customer traits.</li>
          <li>Compare pooled and fixed effects estimates for robustness.</li>
        </ul>
      </section>

      <section class="section card" id="r-section">
        <h3>Interactive R test bench: logit and fixed effects</h3>
        <p class="callout">
          Simulate a binary outcome for logit estimation, then create panel data and compare
          pooled versus fixed effects regressions.
        </p>
        <ul>
          <li>Increase the logit slope and check how the odds ratio changes.</li>
          <li>Adjust the number of panel individuals and time periods for stability.</li>
          <li>Increase unobserved effect sd and compare pooled vs fixed effects.</li>
          <li>Inspect the fitted vs residual plot for the logit model.</li>
        </ul>
        <div class="bench">
          <div class="grid-2">
            <div class="control-row">
              <label>Logit sample size</label>
              <input id="r-n" type="number" min="100" max="2000" step="50" value="500">
            </div>
            <div class="control-row">
              <label>Logit slope (beta)</label>
              <input id="r-beta" type="number" min="-3" max="3" step="0.2" value="1.1">
            </div>
            <div class="control-row">
              <label>Panel individuals</label>
              <input id="r-ids" type="number" min="20" max="400" step="10" value="120">
            </div>
            <div class="control-row">
              <label>Time periods</label>
              <input id="r-t" type="number" min="3" max="20" step="1" value="6">
            </div>
            <div class="control-row">
              <label>Panel slope (beta)</label>
              <input id="r-bpanel" type="number" min="-3" max="3" step="0.2" value="0.8">
            </div>
            <div class="control-row">
              <label>Unobserved effect sd</label>
              <input id="r-usd" type="number" min="0.2" max="2" step="0.2" value="0.8">
            </div>
          </div>
          <div class="controls">
            <button class="btn secondary" id="r-build">Update R code</button>
          </div>
          <textarea id="r-code" spellcheck="false"></textarea>
          <div class="controls">
            <button class="btn" id="r-run" disabled>Run R</button>
            <button class="btn secondary" id="r-reset">Reset</button>
          </div>
          <div class="bench-output">
            <pre id="r-output">Loading webR, please wait...</pre>
            <canvas id="r-plot" width="900" height="520"></canvas>
          </div>
        </div>
      </section>

    </main>
    <footer class="container"> 2026 Francesco Balocco.</footer>

    <script type="module">
      const byId = (id) => document.getElementById(id);

      function fmt(num, digits = 2) {
        return Number(num).toFixed(digits);
      }

      function typesetMath(el) {
        if (window.MathJax && window.MathJax.typesetPromise) {
          window.MathJax.typesetPromise(el ? [el] : undefined);
        }
      }

      function setupViewSettings() {
        const cards = Array.from(
          document.querySelectorAll(".topic-card, section.card, section#quick-check")
        );
        if (!cards.length) return;
        const crumbEl = document.querySelector(".breadcrumbs");
        const crumbText = crumbEl ? crumbEl.textContent : "";
        const hasSlash = crumbText.indexOf("/") !== -1;
        const sessionLabel = hasSlash ? crumbText.split("/").pop().trim() : crumbText.trim();
        const headingEl = document.querySelector("header h1");
        const sessionHeading = headingEl && headingEl.textContent ? headingEl.textContent.trim() : "";
        const sessionTitle = [sessionLabel, sessionHeading].filter(Boolean).join(" - ");
        const sessionPrefix = sessionTitle ? `${sessionTitle}. ` : "";
        const header = document.querySelector("header");
        const progressBar = byId("progress-bar");
        const progressText = byId("progress-text");
        const prevBtn = byId("prev-card");
        const nextBtn = byId("next-card");
        const settingsBtn = byId("settings-btn");
        const panel = byId("settings-panel");
        const modeInputs = Array.from(document.querySelectorAll("input[name='view-mode']"));
        let index = 0;
        const total = cards.length;

        function updateSplitPaneHeight() {
          if (!document.body.classList.contains("view-mode-single")) return;
          const topbar = document.querySelector(".topbar");
          const topbarH = topbar ? topbar.getBoundingClientRect().height : 0;
          const h = Math.max(320, window.innerHeight - topbarH - 140);
          document.documentElement.style.setProperty("--split-pane-height", `${h}px`);
        }

        function setMode(mode) {
          localStorage.setItem("viewMode", mode);
          modeInputs.forEach((input) => {
            input.checked = input.value === mode;
          });
          document.body.classList.toggle("view-mode-single", mode === "single");
          document.body.classList.toggle("view-mode-all", mode === "all");
          updateSplitPaneHeight();
          update();
        }

        function update() {
          const checkedInput = modeInputs.find((input) => input.checked);
          const mode = checkedInput ? checkedInput.value : "all";
          cards.forEach((card, i) => {
            const visible = mode === "all" || i === index;
            card.style.display = visible ? "" : "none";
          });
          prevBtn.disabled = mode === "all" || index === 0;
          nextBtn.disabled = mode === "all" || index === total - 1;
          const progress = mode === "all" ? 100 : ((index + 1) / total) * 100;
          progressBar.style.width = `${progress}%`;
          progressText.textContent =
            mode === "all"
              ? `${sessionPrefix}All cards (${total})`
              : `${sessionPrefix}Card ${index + 1} of ${total}`;
          if (header) {
            header.style.display = mode === "all" || index === 0 ? "" : "none";
          }
          updateSplitPaneHeight();
        }

        prevBtn.addEventListener("click", () => {
          index = Math.max(0, index - 1);
          update();
        });
        nextBtn.addEventListener("click", () => {
          index = Math.min(total - 1, index + 1);
          update();
        });
        settingsBtn.addEventListener("click", () => {
          panel.classList.toggle("open");
        });
        document.addEventListener("click", (event) => {
          if (!panel.contains(event.target) && event.target !== settingsBtn) {
            panel.classList.remove("open");
          }
        });
        modeInputs.forEach((input) => input.addEventListener("change", () => setMode(input.value)));
        window.addEventListener("resize", updateSplitPaneHeight);

        const savedMode = localStorage.getItem("viewMode") || "all";
        setMode(savedMode);
      }

      function reorderSections() {
        const main = document.querySelector("main");
        const quick = byId("quick-check");
        const caseCard = buildCaseStudyCard();
        if (caseCard) main.appendChild(caseCard);
        if (quick) main.appendChild(quick);
      }

      function buildCaseStudyCard() {
        const caseSection = byId("case-study");
        const rSection = byId("r-section");
        if (!caseSection || !rSection) return null;
        const card = document.createElement("section");
        card.className = "section card";
        card.id = "case-study-card";
        const grid = document.createElement("div");
        grid.className = "card-grid";
        const left = document.createElement("div");
        left.className = "card-left";
        const right = document.createElement("div");
        right.className = "card-right";

        const title = caseSection.querySelector("h3");
        if (title) left.appendChild(title);
        Array.from(caseSection.children).forEach((child) => {
          if (child !== title) left.appendChild(child);
        });

        const intro = document.createElement("p");
        intro.className = "exercise-intro";
        intro.textContent = "How to use: adjust parameters, update the R code, then run it to see outputs.";
        right.appendChild(intro);
        Array.from(rSection.children).forEach((child) => {
          if (child.tagName !== "H3") right.appendChild(child);
        });

        grid.appendChild(left);
        grid.appendChild(right);
        card.appendChild(grid);
        caseSection.remove();
        rSection.remove();
        return card;
      }

      function setupTheoryCards() {
        const list = document.querySelector(".topic-list");
        if (!list) return;
        const section = list.closest("section");
        if (section) {
          const heading = section.querySelector("h3");
          const note = section.querySelector(":scope > p.small");
          if (heading) heading.remove();
          if (note) note.remove();
          section.classList.remove("card");
        }

        const theory = [
          "A straight line can miss important patterns. You can model curvature by adding terms like \\(x^2\\) (polynomials) or by transforming variables (e.g., \\(\\log(x)\\) for diminishing returns). The key question is whether the added flexibility captures real structure rather than noise.",
          "Comparing models is about <em>bias vs variance</em>. A too-simple model can be systematically wrong (misspecification bias); a too-flexible model can overfit. Compare fitted curves and residual patternsand prefer models that generalize (not just ones with the biggest in-sample fit).",
          "Binary variables (0/1) represent indicators (e.g., treatment vs control). In a linear model, the coefficient on a binary predictor is the difference in predicted means between the two groups (holding other variables fixed).",
          "The linear probability model (LPM) treats a binary outcome with OLS: \\(P(Y=1\\mid X)=b_0+b_1X\\). It is easy to interpret but can predict probabilities below 0 or above 1, and it is inherently heteroskedastic (so you should use robust standard errors).",
          "Logistic regression forces predictions into \\([0,1]\\): \\(p=\\frac{1}{1+e^{-(b_0+b_1X)}}\\). The curve is S-shaped: changes in \\(X\\) have the biggest impact on \\(p\\) around the middle (near 0.5) and smaller impact near 0 or 1.",
          "The logit link is \\(\\log\\left(\\frac{p}{1-p}\\right)=b_0+b_1X\\). This means \(b_1\) is a constant effect on <em>log-odds</em>, while the effect on probability depends on the current value of \\(X\\) (marginal effects vary).",
          "Logit is estimated by maximum likelihood. Exponentiating a coefficient gives an odds ratio: \\(e^{b_1}\\) multiplies the odds for a 1-unit increase in \\(X\\) (holding other predictors constant). For substantive interpretation, predicted probabilities at meaningful \\(X\\) values are often clearer than odds ratios.",
          "Probit uses the standard normal CDF instead of the logistic: \\(p=\\Phi(b_0+b_1X)\\). Probit and logit often yield similar fitted probabilities; coefficients differ mainly by a scale factor.",
          "All three approaches (LPM, logit, probit) aim to model \\(P(Y=1\\mid X)\\), but they make different assumptions and have different interpretation habits. Choose based on plausibility, communication needs, and diagnosticsnot just convenience.",
          "Poisson regression is for counts: \\(E[Y\\mid X]=\\exp(b_0+b_1X)\\). A 1-unit increase in \\(X\\) multiplies the expected count by \\(e^{b_1}\\). A common issue is overdispersion (variance > mean); if present, consider robust SEs or a negative binomial model.",
          "Panel data track the same units over time: \\(y_{it}=b_0+b_1x_{it}+u_i+e_{it}\\). A core challenge is unobserved unit characteristics \\(u_i\\) that may be correlated with predictors. Distinguish <em>within-unit</em> changes (over time) from <em>between-unit</em> differences.",
          "Model choices reflect assumptions about \\(u_i\\): pooled OLS ignores it; fixed effects remove time-invariant \\(u_i\\) using demeaning; first differences use changes \\(\\Delta y\\) and \\(\\Delta x\\); random effects assumes \\(u_i\\) is uncorrelated with predictors. If that RE assumption fails, RE can be biased; FE remains consistent for time-varying predictors."
        ];
        const intros = [
          "How to use: choose a shape and adjust coefficients to see curvature.",
          "How to use: resample data and compare linear vs nonlinear fits.",
          "How to use: select which variables are truly 0/1.",
          "How to use: move slope/intercept and see out-of-bounds regions.",
          "How to use: adjust coefficients and observe probability changes.",
          "How to use: move X and see how logit and probability relate.",
          "How to use: resimulate and interpret coefficients as odds ratios.",
          "How to use: resimulate and compare probit probabilities.",
          "How to use: compare three curves at the same X value.",
          "How to use: adjust coefficients and see expected count changes.",
          "How to use: toggle time-varying vs invariant variables and inspect within/between variation.",
          "How to use: switch models and compare coefficient patterns."
        ];

        function stripInteractivePrefix(text) {
          const trimmed = text.trim();
          const lower = trimmed.toLowerCase();
          const prefix = "interactive";
          if (lower.indexOf(prefix) === 0) {
            return trimmed.slice(prefix.length).trim();
          }
          return trimmed;
        }

        function stripLeadingNumbering(text) {
          let s = text.trim();
          let changed = true;
          while (changed) {
            changed = false;
            let i = 0;
            while (i < s.length && s[i] >= "0" && s[i] <= "9") i += 1;
            if (i === 0) break;
            while (i < s.length && (s[i] === " " || s[i] === "\t")) i += 1;
            while (i < s.length && (s[i] === "." || s[i] === "-" || s[i] === ":")) {
              i += 1;
              while (i < s.length && (s[i] === " " || s[i] === "\t")) i += 1;
            }
            s = s.slice(i).trim();
            changed = true;
          }
          while (
            s.length &&
            (s[0] === "." || s[0] === "-" || s[0] === ":" || s[0] === " " || s[0] === "\t")
          ) {
            s = s.slice(1).trim();
          }
          return s;
        }

        const cards = Array.from(list.querySelectorAll(".topic-card"));
        cards.forEach((card, i) => {
          const title = card.querySelector("h4");
          if (!title) return;
          const originalTitle = title.textContent.trim();
          let displayNumber = "";
          for (let k = 0; k < originalTitle.length; k += 1) {
            const ch = originalTitle[k];
            if (ch >= "0" && ch <= "9") displayNumber += ch;
            else if (!displayNumber && (ch === " " || ch === "\t")) continue;
            else break;
          }
          if (!displayNumber) displayNumber = String(i + 1);
          let cleanTitle = stripInteractivePrefix(originalTitle);
          cleanTitle = stripLeadingNumbering(cleanTitle);
          title.textContent = `${displayNumber}. ${cleanTitle}`;
          card.dataset.cardNumber = displayNumber;
          card.dataset.cardTitle = cleanTitle;
          const content = Array.from(card.children).filter((el) => el !== title);
          const grid = document.createElement("div");
          grid.className = "card-grid";
          const left = document.createElement("div");
          left.className = "card-left";
          const right = document.createElement("div");
          right.className = "card-right";
          const theoryEl = document.createElement("div");
          theoryEl.className = "theory";
          theoryEl.innerHTML = theory[i] || "";
          const introEl = document.createElement("p");
          introEl.className = "exercise-intro";
          introEl.innerHTML = intros[i] || "";

          left.appendChild(title);
          left.appendChild(theoryEl);
          right.appendChild(introEl);
          content.forEach((el) => right.appendChild(el));
          grid.appendChild(left);
          grid.appendChild(right);
          card.innerHTML = "";
          card.appendChild(grid);
        });

        // Merge topics that share the same data source (requested pairing).
        const mergeByNumber = (keepNum, mergeNum) => {
          const keep = list.querySelector(`.topic-card[data-card-number="${keepNum}"]`);
          const merge = list.querySelector(`.topic-card[data-card-number="${mergeNum}"]`);
          if (!keep || !merge) return;

          const keepLeft = keep.querySelector(".card-left");
          const keepRight = keep.querySelector(".card-right");
          const mergeLeft = merge.querySelector(".card-left");
          const mergeRight = merge.querySelector(".card-right");
          if (!keepLeft || !keepRight || !mergeLeft || !mergeRight) return;

          const keepTitle = keep.dataset.cardTitle || "";
          const mergeTitle = merge.dataset.cardTitle || "";
          const titleEl = keepLeft.querySelector("h4");
          if (titleEl) {
            titleEl.textContent = "";
            titleEl.appendChild(document.createTextNode(`${keepNum}. `));
            const strongA = document.createElement("strong");
            strongA.textContent = keepTitle;
            titleEl.appendChild(strongA);
          }

          const mergeTheory = mergeLeft.querySelector(".theory");
          if (mergeTheory) {
            const theoryBlock = document.createElement("div");
            theoryBlock.className = "theory";
            const strong = document.createElement("strong");
            strong.textContent = mergeTitle;
            theoryBlock.appendChild(strong);
            theoryBlock.appendChild(document.createElement("br"));
            const tmp = document.createElement("div");
            tmp.innerHTML = mergeTheory.innerHTML;
            Array.from(tmp.childNodes).forEach((node) => theoryBlock.appendChild(node));
            keepLeft.appendChild(theoryBlock);
          }

          const practiceHeading = document.createElement("p");
          practiceHeading.className = "exercise-intro";
          const practiceStrong = document.createElement("strong");
          practiceStrong.textContent = mergeTitle;
          practiceHeading.appendChild(practiceStrong);
          keepRight.appendChild(practiceHeading);
          Array.from(mergeRight.children).forEach((child) => keepRight.appendChild(child));

          const quizzes = keepRight.querySelectorAll(".mini-check, .quiz");
          quizzes.forEach((q) => keepRight.appendChild(q));

          merge.remove();
        };

        mergeByNumber("11", "12");

        typesetMath(list);
      }

      function logistic(x) {
        return 1 / (1 + Math.exp(-x));
      }

      function normalSample(mu, sigma) {
        const u1 = Math.random();
        const u2 = Math.random();
        const z = Math.sqrt(-2 * Math.log(u1)) * Math.cos(2 * Math.PI * u2);
        return mu + sigma * z;
      }

      function erf(x) {
        const sign = x >= 0 ? 1 : -1;
        const absX = Math.abs(x);
        const a1 = 0.254829592;
        const a2 = -0.284496736;
        const a3 = 1.421413741;
        const a4 = -1.453152027;
        const a5 = 1.061405429;
        const p = 0.3275911;
        const t = 1 / (1 + p * absX);
        const y =
          1 -
          (((((a5 * t + a4) * t + a3) * t + a2) * t + a1) * t) *
            Math.exp(-absX * absX);
        return sign * y;
      }

      function normalCDF(x, mu, sigma) {
        const z = (x - mu) / (sigma * Math.sqrt(2));
        return 0.5 * (1 + erf(z));
      }

      function normalPDF(x, mu = 0, sigma = 1) {
        const z = (x - mu) / sigma;
        return (1 / (Math.sqrt(2 * Math.PI) * sigma)) * Math.exp(-0.5 * z * z);
      }

      function drawAxes(ctx, width, height, padding) {
        ctx.strokeStyle = "#cbd5f6";
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(padding, height - padding);
        ctx.lineTo(width - padding, height - padding);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(padding, padding);
        ctx.lineTo(padding, height - padding);
        ctx.stroke();
      }

      function mean(arr) {
        return arr.reduce((s, v) => s + v, 0) / arr.length;
      }

      function solveLinearSystem(A, b) {
        const n = A.length;
        const M = A.map((row, i) => row.concat(b[i]));
        for (let i = 0; i < n; i += 1) {
          let maxRow = i;
          for (let k = i + 1; k < n; k += 1) {
            if (Math.abs(M[k][i]) > Math.abs(M[maxRow][i])) maxRow = k;
          }
          if (maxRow !== i) {
            const tmp = M[i];
            M[i] = M[maxRow];
            M[maxRow] = tmp;
          }
          const pivot = M[i][i] || 1e-12;
          for (let j = i; j <= n; j += 1) {
            M[i][j] /= pivot;
          }
          for (let k = 0; k < n; k += 1) {
            if (k === i) continue;
            const factor = M[k][i];
            for (let j = i; j <= n; j += 1) {
              M[k][j] -= factor * M[i][j];
            }
          }
        }
        return M.map((row) => row[n]);
      }

      function polyFit(xs, ys, degree) {
        const n = degree + 1;
        const A = Array.from({ length: n }, () => Array.from({ length: n }, () => 0));
        const B = Array.from({ length: n }, () => 0);
        for (let i = 0; i < n; i += 1) {
          for (let j = 0; j < n; j += 1) {
            A[i][j] = xs.reduce((s, x) => s + x ** (i + j), 0);
          }
          B[i] = xs.reduce((s, x, idx) => s + ys[idx] * x ** i, 0);
        }
        return solveLinearSystem(A, B);
      }

      function logFit(xs, ys) {
        const xlog = xs.map((x) => Math.log(x));
        return polyFit(xlog, ys, 1);
      }

      function predictPoly(coeffs, x) {
        return coeffs.reduce((s, c, i) => s + c * x ** i, 0);
      }

      function weightedRegression(xs, ys, ws) {
        let sw = 0;
        let sx = 0;
        let sy = 0;
        let sxx = 0;
        let sxy = 0;
        xs.forEach((x, i) => {
          const w = ws[i];
          sw += w;
          sx += w * x;
          sy += w * ys[i];
          sxx += w * x * x;
          sxy += w * x * ys[i];
        });
        const denom = sw * sxx - sx * sx || 1e-12;
        const b1 = (sw * sxy - sx * sy) / denom;
        const b0 = (sy - b1 * sx) / sw;
        return { b0, b1, sw, sx, sxx, denom };
      }

      function fitLogit(xs, ys, iterations = 8) {
        let b0 = 0;
        let b1 = 0;
        let w = xs.map(() => 1);
        for (let iter = 0; iter < iterations; iter += 1) {
          const z = xs.map((x) => b0 + b1 * x);
          const p = z.map((zi) => logistic(zi));
          w = p.map((pi) => Math.max(pi * (1 - pi), 1e-6));
          const zAdj = z.map((zi, i) => zi + (ys[i] - p[i]) / w[i]);
          const fit = weightedRegression(xs, zAdj, w);
          b0 = fit.b0;
          b1 = fit.b1;
        }
        const stats = weightedRegression(xs, xs.map(() => 0), w);
        const inv00 = stats.sxx / stats.denom;
        const inv11 = stats.sw / stats.denom;
        return { b0, b1, se0: Math.sqrt(inv00), se1: Math.sqrt(inv11) };
      }

      function fitProbit(xs, ys, iterations = 8) {
        let b0 = 0;
        let b1 = 0;
        let w = xs.map(() => 1);
        for (let iter = 0; iter < iterations; iter += 1) {
          const z = xs.map((x) => b0 + b1 * x);
          const p = z.map((zi) => Math.min(Math.max(normalCDF(zi, 0, 1), 1e-6), 1 - 1e-6));
          const phi = z.map((zi) => Math.max(normalPDF(zi, 0, 1), 1e-6));
          w = p.map((pi, i) => (phi[i] * phi[i]) / Math.max(pi * (1 - pi), 1e-6));
          const zAdj = z.map((zi, i) => zi + (ys[i] - p[i]) / phi[i]);
          const fit = weightedRegression(xs, zAdj, w);
          b0 = fit.b0;
          b1 = fit.b1;
        }
        const stats = weightedRegression(xs, xs.map(() => 0), w);
        const inv00 = stats.sxx / stats.denom;
        const inv11 = stats.sw / stats.denom;
        return { b0, b1, se0: Math.sqrt(inv00), se1: Math.sqrt(inv11) };
      }

      function poissonSample(lambda) {
        const L = Math.exp(-lambda);
        let k = 0;
        let p = 1;
        while (p > L) {
          k += 1;
          p *= Math.random();
        }
        return k - 1;
      }

      function setupNonlinear() {
        const typeInput = byId("nl-type");
        const b0Input = byId("nl-b0");
        const b1Input = byId("nl-b1");
        const b2Input = byId("nl-b2");
        const b3Input = byId("nl-b3");
        const canvas = byId("nl-canvas");
        const ctx = canvas.getContext("2d");
        const shapeOut = byId("nl-shape");
        const noteOut = byId("nl-note");

        function computeY(x, b0Override) {
          const b0 =
            typeof b0Override === "number" ? b0Override : Number(b0Input.value);
          const b1 = Number(b1Input.value);
          const b2 = Number(b2Input.value);
          const b3 = Number(b3Input.value);
          const type = typeInput.value;
          if (type === "linear") return b0 + b1 * x;
          if (type === "quadratic") return b0 + b1 * x + b2 * x * x;
          if (type === "cubic") return b0 + b1 * x + b2 * x * x + b3 * x * x * x;
          return b0 + b1 * Math.log(x);
        }

        function draw() {
          const padding = 40;
          const minX = 0.5;
          const maxX = 10;
          const xs = [];
          const ys = [];
          const baseYs = [];
          const b0Range = Math.max(
            Math.abs(Number(b0Input.min) || 0),
            Math.abs(Number(b0Input.max) || 0),
            1
          );
          for (let i = 0; i <= 80; i += 1) {
            const x = minX + (i / 80) * (maxX - minX);
            xs.push(x);
            ys.push(computeY(x));
            baseYs.push(computeY(x, 0));
          }
          let minY = Math.min(...baseYs) - b0Range - 1;
          let maxY = Math.max(...baseYs) + b0Range + 1;
          if (Math.abs(maxY - minY) < 1e-6) {
            minY -= 1;
            maxY += 1;
          }
          const scaleX = (x) =>
            padding + ((x - minX) / (maxX - minX)) * (canvas.width - 2 * padding);
          const scaleY = (y) =>
            canvas.height - padding - ((y - minY) / (maxY - minY)) * (canvas.height - 2 * padding);

          ctx.clearRect(0, 0, canvas.width, canvas.height);
          drawAxes(ctx, canvas.width, canvas.height, padding);

          ctx.strokeStyle = "#2563eb";
          ctx.lineWidth = 3;
          ctx.beginPath();
          xs.forEach((x, i) => {
            const y = ys[i];
            if (i === 0) ctx.moveTo(scaleX(x), scaleY(y));
            else ctx.lineTo(scaleX(x), scaleY(y));
          });
          ctx.stroke();

          ctx.fillStyle = "#0f172a";
          ctx.font = "12px system-ui, sans-serif";
          ctx.fillText("Ad spend (X)", canvas.width - 140, canvas.height - 12);
          ctx.fillText("Sales (Y)", 10, 18);

          const type = typeInput.value;
          if (type === "linear") {
            shapeOut.textContent = "Linear";
            noteOut.textContent = "Straight-line relationship.";
          } else if (type === "quadratic") {
            const b2 = Number(b2Input.value);
            shapeOut.textContent = b2 > 0 ? "U-shape" : "Inverted U";
            noteOut.textContent = "Quadratic curvature.";
          } else if (type === "cubic") {
            shapeOut.textContent = "Cubic";
            noteOut.textContent = "S-shape or changing slope.";
          } else {
            shapeOut.textContent = "Log";
            noteOut.textContent = "Diminishing returns.";
          }
        }

        [typeInput, b0Input, b1Input, b2Input, b3Input].forEach((input) =>
          input.addEventListener("input", draw)
        );
        draw();
      }

      function setupFitComparison() {
        const typeInput = byId("fit-type");
        const runBtn = byId("fit-run");
        const canvas = byId("fit-model-canvas");
        const ctx = canvas.getContext("2d");
        const linOut = {
          b0: byId("fit-lin-b0"),
          b1: byId("fit-lin-b1"),
          b2: byId("fit-lin-b2"),
          b3: byId("fit-lin-b3")
        };
        const nlOut = {
          b0: byId("fit-nl-b0"),
          b1: byId("fit-nl-b1"),
          b2: byId("fit-nl-b2"),
          b3: byId("fit-nl-b3")
        };
        let xs = [];
        let ys = [];

        function generateData() {
          const type = typeInput.value;
          const n = 120;
          xs = Array.from({ length: n }, () => 0.5 + Math.random() * 9.5);
          ys = xs.map((x) => {
            if (type === "linear") return 1 + 0.6 * x + normalSample(0, 0.6);
            if (type === "quadratic") return 1 + 0.8 * x - 0.08 * x * x + normalSample(0, 0.6);
            if (type === "cubic") {
              return 1 + 0.6 * x - 0.05 * x * x + 0.004 * x * x * x + normalSample(0, 0.6);
            }
            return 1 + 1.2 * Math.log(x) + normalSample(0, 0.6);
          });
        }

        function setCell(el, value) {
          el.textContent = value === null ? "-" : fmt(value, 2);
        }

        function draw() {
          const type = typeInput.value;
          const linCoeff = polyFit(xs, ys, 1);
          let nlCoeff = [];
          if (type === "linear") nlCoeff = linCoeff;
          else if (type === "quadratic") nlCoeff = polyFit(xs, ys, 2);
          else if (type === "cubic") nlCoeff = polyFit(xs, ys, 3);
          else nlCoeff = logFit(xs, ys);

          setCell(linOut.b0, linCoeff[0]);
          setCell(linOut.b1, linCoeff[1]);
          setCell(linOut.b2, null);
          setCell(linOut.b3, null);

          setCell(nlOut.b0, nlCoeff[0]);
          setCell(nlOut.b1, nlCoeff[1]);
          setCell(nlOut.b2, nlCoeff.length > 2 ? nlCoeff[2] : null);
          setCell(nlOut.b3, nlCoeff.length > 3 ? nlCoeff[3] : null);

          const padding = 40;
          const minX = Math.min(...xs);
          const maxX = Math.max(...xs);
          const minY = Math.min(...ys);
          const maxY = Math.max(...ys);
          const scaleX = (x) =>
            padding + ((x - minX) / (maxX - minX)) * (canvas.width - 2 * padding);
          const scaleY = (y) =>
            canvas.height - padding - ((y - minY) / (maxY - minY)) * (canvas.height - 2 * padding);

          ctx.clearRect(0, 0, canvas.width, canvas.height);
          drawAxes(ctx, canvas.width, canvas.height, padding);

          ctx.fillStyle = "rgba(43, 109, 233, 0.6)";
          xs.forEach((x, i) => {
            ctx.beginPath();
            ctx.arc(scaleX(x), scaleY(ys[i]), 3, 0, Math.PI * 2);
            ctx.fill();
          });

          ctx.strokeStyle = "#f97316";
          ctx.lineWidth = 2.5;
          ctx.beginPath();
          ctx.moveTo(scaleX(minX), scaleY(linCoeff[0] + linCoeff[1] * minX));
          ctx.lineTo(scaleX(maxX), scaleY(linCoeff[0] + linCoeff[1] * maxX));
          ctx.stroke();

          ctx.strokeStyle = "#22c55e";
          ctx.lineWidth = 2.5;
          ctx.beginPath();
          for (let i = 0; i <= 80; i += 1) {
            const x = minX + (i / 80) * (maxX - minX);
            let y;
            if (type === "log") y = nlCoeff[0] + nlCoeff[1] * Math.log(x);
            else y = predictPoly(nlCoeff, x);
            if (i === 0) ctx.moveTo(scaleX(x), scaleY(y));
            else ctx.lineTo(scaleX(x), scaleY(y));
          }
          ctx.stroke();

          ctx.fillStyle = "#0f172a";
          ctx.font = "12px system-ui, sans-serif";
          ctx.fillText("Ad spend (X)", canvas.width - 140, canvas.height - 12);
          ctx.fillText("Sales (Y)", 10, 18);
        }

        function resample() {
          generateData();
          draw();
        }

        runBtn.addEventListener("click", resample);
        typeInput.addEventListener("change", resample);
        resample();
      }

      function setupBinaryCheck() {
        const options = byId("binary-options");
        const checkBtn = byId("binary-check");
        const scoreOut = byId("binary-score");
        const feedbackOut = byId("binary-feedback");

        checkBtn.addEventListener("click", () => {
          const checks = Array.from(options.querySelectorAll("input[type='checkbox']"));
          let correct = 0;
          let total = 0;
          checks.forEach((box) => {
            const isCorrect = box.dataset.correct === "true";
            if (isCorrect) total += 1;
            if (box.checked && isCorrect) correct += 1;
            if (box.checked && !isCorrect) correct -= 0.2;
          });
          correct = Math.max(0, Math.round(correct * 10) / 10);
          scoreOut.textContent = `${correct} / ${total}`;
          feedbackOut.textContent = correct === total ? "Perfect." : "Review the labels and try again.";
        });
      }

      function setupLPM() {
        const b0Input = byId("lpm-b0");
        const b1Input = byId("lpm-b1");
        const canvas = byId("lpm-canvas");
        const ctx = canvas.getContext("2d");
        const oobOut = byId("lpm-oob");

        function draw() {
          const b0 = Number(b0Input.value);
          const b1 = Number(b1Input.value);
          const padding = 40;
          const minX = 0;
          const maxX = 10;
          const xs = [];
          const ys = [];
          for (let i = 0; i <= 80; i += 1) {
            const x = minX + (i / 80) * (maxX - minX);
            xs.push(x);
            ys.push(b0 + b1 * x);
          }
          const minY = Math.min(...ys, -0.2);
          const maxY = Math.max(...ys, 1.2);
          const scaleX = (x) =>
            padding + ((x - minX) / (maxX - minX)) * (canvas.width - 2 * padding);
          const scaleY = (y) =>
            canvas.height - padding - ((y - minY) / (maxY - minY)) * (canvas.height - 2 * padding);

          ctx.clearRect(0, 0, canvas.width, canvas.height);
          drawAxes(ctx, canvas.width, canvas.height, padding);

          ctx.strokeStyle = "#cbd5f6";
          ctx.setLineDash([4, 4]);
          ctx.beginPath();
          ctx.moveTo(scaleX(minX), scaleY(0));
          ctx.lineTo(scaleX(maxX), scaleY(0));
          ctx.stroke();
          ctx.beginPath();
          ctx.moveTo(scaleX(minX), scaleY(1));
          ctx.lineTo(scaleX(maxX), scaleY(1));
          ctx.stroke();
          ctx.setLineDash([]);
          ctx.fillStyle = "#0f172a";
          ctx.font = "12px system-ui, sans-serif";
          ctx.fillText("1", padding - 18, scaleY(1) + 4);
          ctx.fillText("0", padding - 18, scaleY(0) + 4);

          let oob = 0;
          for (let i = 0; i < xs.length - 1; i += 1) {
            const y1 = ys[i];
            const y2 = ys[i + 1];
            const out = y1 < 0 || y1 > 1 || y2 < 0 || y2 > 1;
            if (out) oob += 1;
            ctx.strokeStyle = out ? "#ef4444" : "#2563eb";
            ctx.lineWidth = 2.5;
            ctx.beginPath();
            ctx.moveTo(scaleX(xs[i]), scaleY(y1));
            ctx.lineTo(scaleX(xs[i + 1]), scaleY(y2));
            ctx.stroke();
          }
          oobOut.textContent = `${Math.round((oob / xs.length) * 100)}% of range`;

          ctx.fillStyle = "#0f172a";
          ctx.font = "12px system-ui, sans-serif";
          ctx.fillText("Price (X)", canvas.width - 120, canvas.height - 12);
          ctx.fillText("Pr(Churn=1)", 10, 18);
        }

        b0Input.addEventListener("input", draw);
        b1Input.addEventListener("input", draw);
        draw();
      }

      function setupLogisticCurve() {
        const b0Input = byId("logistic-b0");
        const b1Input = byId("logistic-b1");
        const xInput = byId("logistic-x");
        const canvas = byId("logistic-canvas");
        const ctx = canvas.getContext("2d");
        const probOut = byId("logistic-prob");
        const cdfOut = byId("logistic-cdf");

        function draw() {
          const b0 = Number(b0Input.value);
          const b1 = Number(b1Input.value);
          const x = Number(xInput.value);
          const padding = 40;
          const minX = -3;
          const maxX = 3;
          const xs = [];
          const ys = [];
          for (let i = 0; i <= 80; i += 1) {
            const xi = minX + (i / 80) * (maxX - minX);
            xs.push(xi);
            ys.push(logistic(b0 + b1 * xi));
          }
          const scaleX = (xv) =>
            padding + ((xv - minX) / (maxX - minX)) * (canvas.width - 2 * padding);
          const scaleY = (yv) =>
            canvas.height - padding - yv * (canvas.height - 2 * padding);

          ctx.clearRect(0, 0, canvas.width, canvas.height);
          drawAxes(ctx, canvas.width, canvas.height, padding);

          ctx.strokeStyle = "#cbd5f6";
          ctx.setLineDash([4, 4]);
          ctx.beginPath();
          ctx.moveTo(scaleX(minX), scaleY(0));
          ctx.lineTo(scaleX(maxX), scaleY(0));
          ctx.stroke();
          ctx.beginPath();
          ctx.moveTo(scaleX(minX), scaleY(1));
          ctx.lineTo(scaleX(maxX), scaleY(1));
          ctx.stroke();
          ctx.setLineDash([]);

          const xClip = Math.min(Math.max(x, minX), maxX);
          if (xClip > minX) {
            ctx.fillStyle = "rgba(37, 99, 235, 0.15)";
            ctx.beginPath();
            ctx.moveTo(scaleX(minX), scaleY(0));
            for (let i = 0; i <= 80; i += 1) {
              const xi = minX + (i / 80) * (maxX - minX);
              if (xi <= xClip) {
                ctx.lineTo(scaleX(xi), scaleY(logistic(b0 + b1 * xi)));
              }
            }
            ctx.lineTo(scaleX(xClip), scaleY(logistic(b0 + b1 * xClip)));
            ctx.lineTo(scaleX(xClip), scaleY(0));
            ctx.closePath();
            ctx.fill();
          }

          ctx.strokeStyle = "#2563eb";
          ctx.lineWidth = 3;
          ctx.beginPath();
          xs.forEach((xi, i) => {
            const y = ys[i];
            if (i === 0) ctx.moveTo(scaleX(xi), scaleY(y));
            else ctx.lineTo(scaleX(xi), scaleY(y));
          });
          ctx.stroke();

          const p = logistic(b0 + b1 * x);
          ctx.fillStyle = "#f97316";
          ctx.beginPath();
          ctx.arc(scaleX(x), scaleY(p), 4, 0, Math.PI * 2);
          ctx.fill();

          probOut.textContent = fmt(p, 3);
          cdfOut.textContent = `CDF(z=${fmt(b0 + b1 * x, 2)})`;

          ctx.fillStyle = "#0f172a";
          ctx.font = "12px system-ui, sans-serif";
          ctx.fillText("Price (X)", canvas.width - 120, canvas.height - 12);
          ctx.fillText("Pr(Churn=1)", 10, 18);
        }

        [b0Input, b1Input, xInput].forEach((input) => input.addEventListener("input", draw));
        draw();
      }

      function setupLogitMapping() {
        const b0Input = byId("map-b0");
        const b1Input = byId("map-b1");
        const xInput = byId("map-x");
        const canvas = byId("map-canvas");
        const ctx = canvas.getContext("2d");
        const probOut = byId("map-prob");
        const logitOut = byId("map-logit");
        const oddsOut = byId("map-odds");
        const logitEq = byId("map-eq-logit");
        const probEq = byId("map-eq-prob");

        function draw() {
          const b0 = Number(b0Input.value);
          const b1 = Number(b1Input.value);
          const x = Number(xInput.value);
          const padding = 40;
          const minX = -3;
          const maxX = 3;
          const xs = [];
          const ps = [];
          const zs = [];
          for (let i = 0; i <= 80; i += 1) {
            const xi = minX + (i / 80) * (maxX - minX);
            xs.push(xi);
            const z = b0 + b1 * xi;
            zs.push(z);
            ps.push(logistic(z));
          }
          const zMin = Math.min(...zs);
          const zMax = Math.max(...zs);
          const zScaled = zs.map((z) => (z - zMin) / (zMax - zMin));
          const scaleX = (xv) =>
            padding + ((xv - minX) / (maxX - minX)) * (canvas.width - 2 * padding);
          const scaleY = (yv) =>
            canvas.height - padding - yv * (canvas.height - 2 * padding);

          ctx.clearRect(0, 0, canvas.width, canvas.height);
          drawAxes(ctx, canvas.width, canvas.height, padding);

          ctx.strokeStyle = "#2563eb";
          ctx.lineWidth = 3;
          ctx.beginPath();
          xs.forEach((xi, i) => {
            const y = ps[i];
            if (i === 0) ctx.moveTo(scaleX(xi), scaleY(y));
            else ctx.lineTo(scaleX(xi), scaleY(y));
          });
          ctx.stroke();

          ctx.strokeStyle = "#94a3b8";
          ctx.lineWidth = 2;
          ctx.beginPath();
          xs.forEach((xi, i) => {
            const y = zScaled[i];
            if (i === 0) ctx.moveTo(scaleX(xi), scaleY(y));
            else ctx.lineTo(scaleX(xi), scaleY(y));
          });
          ctx.stroke();

          const z = b0 + b1 * x;
          const p = logistic(z);
          const zNorm = (z - zMin) / (zMax - zMin);
          ctx.fillStyle = "#2563eb";
          ctx.beginPath();
          ctx.arc(scaleX(x), scaleY(p), 4, 0, Math.PI * 2);
          ctx.fill();
          ctx.fillStyle = "#94a3b8";
          ctx.beginPath();
          ctx.arc(scaleX(x), scaleY(zNorm), 4, 0, Math.PI * 2);
          ctx.fill();

          probOut.textContent = fmt(p, 3);
          logitOut.textContent = fmt(z, 2);
          oddsOut.textContent = fmt(Math.exp(b1), 2);
          logitEq.innerHTML =
            `\\(\\text{logit}(p)=b_0+b_1 X=${fmt(b0, 2)}+${fmt(b1, 2)}\\cdot${fmt(x, 2)}=${fmt(z, 2)}\\)`;
          probEq.innerHTML =
            `\\(p=\\frac{1}{1+\\exp(-${fmt(z, 2)})}=${fmt(p, 3)}\\)`;
          typesetMath(logitEq);
          typesetMath(probEq);

          ctx.fillStyle = "#0f172a";
          ctx.font = "12px system-ui, sans-serif";
          ctx.fillText("X", canvas.width - 60, canvas.height - 12);
          ctx.fillText("Probability / scaled logit", 10, 18);
        }

        [b0Input, b1Input, xInput].forEach((input) => input.addEventListener("input", draw));
        draw();
      }

      function setupLogitFit() {
        const nInput = byId("logit-n");
        const runBtn = byId("logit-run");
        const canvas = byId("logit-fit-canvas");
        const ctx = canvas.getContext("2d");
        const b0Out = byId("logit-b0");
        const b1Out = byId("logit-b1");
        const se0Out = byId("logit-se0");
        const se1Out = byId("logit-se1");
        const or0Out = byId("logit-or0");
        const or1Out = byId("logit-or1");
        const explainOut = byId("logit-explain");
        let xs = [];
        let ys = [];

        function simulate() {
          const n = Number(nInput.value);
          const trueB0 = -0.4;
          const trueB1 = 1.1;
          xs = Array.from({ length: n }, () => -3 + Math.random() * 6);
          ys = xs.map((x) => (Math.random() < logistic(trueB0 + trueB1 * x) ? 1 : 0));
          const fit = fitLogit(xs, ys);

          b0Out.textContent = fmt(fit.b0, 2);
          b1Out.textContent = fmt(fit.b1, 2);
          se0Out.textContent = fmt(fit.se0, 2);
          se1Out.textContent = fmt(fit.se1, 2);
          or0Out.textContent = fmt(Math.exp(fit.b0), 2);
          or1Out.textContent = fmt(Math.exp(fit.b1), 2);

          const meanX = mean(xs);
          const probAtMean = logistic(fit.b0 + fit.b1 * meanX);
          explainOut.textContent =
            `A one-unit increase in Price multiplies odds by ${fmt(Math.exp(fit.b1), 2)}. ` +
            `At the average price, predicted churn is ${fmt(probAtMean, 2)}.`;

          draw(fit);
        }

        function draw(fit) {
          const padding = 40;
          const minX = Math.min(...xs);
          const maxX = Math.max(...xs);
          const scaleX = (x) =>
            padding + ((x - minX) / (maxX - minX)) * (canvas.width - 2 * padding);
          const scaleY = (y) =>
            canvas.height - padding - y * (canvas.height - 2 * padding);

          ctx.clearRect(0, 0, canvas.width, canvas.height);
          drawAxes(ctx, canvas.width, canvas.height, padding);

          ctx.strokeStyle = "#cbd5f6";
          ctx.setLineDash([4, 4]);
          ctx.beginPath();
          ctx.moveTo(scaleX(minX), scaleY(0));
          ctx.lineTo(scaleX(maxX), scaleY(0));
          ctx.stroke();
          ctx.beginPath();
          ctx.moveTo(scaleX(minX), scaleY(1));
          ctx.lineTo(scaleX(maxX), scaleY(1));
          ctx.stroke();
          ctx.setLineDash([]);

          ctx.fillStyle = "rgba(43, 109, 233, 0.6)";
          xs.forEach((x, i) => {
            const y = ys[i] + (Math.random() - 0.5) * 0.08;
            ctx.beginPath();
            ctx.arc(scaleX(x), scaleY(Math.min(Math.max(y, 0), 1)), 3, 0, Math.PI * 2);
            ctx.fill();
          });

          ctx.strokeStyle = "#2563eb";
          ctx.lineWidth = 2.5;
          ctx.beginPath();
          for (let i = 0; i <= 80; i += 1) {
            const x = minX + (i / 80) * (maxX - minX);
            const y = logistic(fit.b0 + fit.b1 * x);
            if (i === 0) ctx.moveTo(scaleX(x), scaleY(y));
            else ctx.lineTo(scaleX(x), scaleY(y));
          }
          ctx.stroke();

          ctx.fillStyle = "#0f172a";
          ctx.font = "12px system-ui, sans-serif";
          ctx.fillText("Price (X)", canvas.width - 120, canvas.height - 12);
          ctx.fillText("Churn (0/1)", 10, 18);
        }

        runBtn.addEventListener("click", simulate);
        nInput.addEventListener("change", simulate);
        simulate();
      }

      function setupProbitFit() {
        const nInput = byId("probit-n");
        const runBtn = byId("probit-run");
        const canvas = byId("probit-fit-canvas");
        const ctx = canvas.getContext("2d");
        const b0Out = byId("probit-b0");
        const b1Out = byId("probit-b1");
        const se0Out = byId("probit-se0");
        const se1Out = byId("probit-se1");
        const explainOut = byId("probit-explain");
        let xs = [];
        let ys = [];

        function simulate() {
          const n = Number(nInput.value);
          const trueB0 = -0.2;
          const trueB1 = 0.9;
          xs = Array.from({ length: n }, () => -3 + Math.random() * 6);
          ys = xs.map((x) => (Math.random() < normalCDF(trueB0 + trueB1 * x, 0, 1) ? 1 : 0));
          const fit = fitProbit(xs, ys);

          b0Out.textContent = fmt(fit.b0, 2);
          b1Out.textContent = fmt(fit.b1, 2);
          se0Out.textContent = fmt(fit.se0, 2);
          se1Out.textContent = fmt(fit.se1, 2);

          const meanX = mean(xs);
          const probAtMean = normalCDF(fit.b0 + fit.b1 * meanX, 0, 1);
          explainOut.textContent =
            `At the average price, predicted churn is ${fmt(probAtMean, 2)} using the normal CDF.`;

          draw(fit);
        }

        function draw(fit) {
          const padding = 40;
          const minX = Math.min(...xs);
          const maxX = Math.max(...xs);
          const scaleX = (x) =>
            padding + ((x - minX) / (maxX - minX)) * (canvas.width - 2 * padding);
          const scaleY = (y) =>
            canvas.height - padding - y * (canvas.height - 2 * padding);

          ctx.clearRect(0, 0, canvas.width, canvas.height);
          drawAxes(ctx, canvas.width, canvas.height, padding);

          ctx.strokeStyle = "#cbd5f6";
          ctx.setLineDash([4, 4]);
          ctx.beginPath();
          ctx.moveTo(scaleX(minX), scaleY(0));
          ctx.lineTo(scaleX(maxX), scaleY(0));
          ctx.stroke();
          ctx.beginPath();
          ctx.moveTo(scaleX(minX), scaleY(1));
          ctx.lineTo(scaleX(maxX), scaleY(1));
          ctx.stroke();
          ctx.setLineDash([]);

          ctx.fillStyle = "rgba(16, 185, 129, 0.6)";
          xs.forEach((x, i) => {
            const y = ys[i] + (Math.random() - 0.5) * 0.08;
            ctx.beginPath();
            ctx.arc(scaleX(x), scaleY(Math.min(Math.max(y, 0), 1)), 3, 0, Math.PI * 2);
            ctx.fill();
          });

          ctx.strokeStyle = "#10b981";
          ctx.lineWidth = 2.5;
          ctx.beginPath();
          for (let i = 0; i <= 80; i += 1) {
            const x = minX + (i / 80) * (maxX - minX);
            const y = normalCDF(fit.b0 + fit.b1 * x, 0, 1);
            if (i === 0) ctx.moveTo(scaleX(x), scaleY(y));
            else ctx.lineTo(scaleX(x), scaleY(y));
          }
          ctx.stroke();

          ctx.fillStyle = "#0f172a";
          ctx.font = "12px system-ui, sans-serif";
          ctx.fillText("Price (X)", canvas.width - 120, canvas.height - 12);
          ctx.fillText("Churn (0/1)", 10, 18);
        }

        runBtn.addEventListener("click", simulate);
        nInput.addEventListener("change", simulate);
        simulate();
      }

      function setupCompareModels() {
        const xInput = byId("compare-x");
        const b1Input = byId("compare-b1");
        const canvas = byId("compare-canvas");
        const ctx = canvas.getContext("2d");
        const lpmOut = byId("compare-lpm");
        const logitOut = byId("compare-logit");
        const probitOut = byId("compare-probit");
        const oddsOut = byId("compare-odds");

        function draw() {
          const x = Number(xInput.value);
          const b1 = Number(b1Input.value);
          const padding = 40;
          const minX = -3;
          const maxX = 3;
          const xs = [];
          const ysLogit = [];
          const ysLinear = [];
          const ysProbit = [];
          for (let i = 0; i <= 80; i += 1) {
            const xi = minX + (i / 80) * (maxX - minX);
            xs.push(xi);
            ysLogit.push(logistic(b1 * xi));
            ysLinear.push(0.5 + 0.2 * b1 * xi);
            ysProbit.push(normalCDF(b1 * xi, 0, 1));
          }
          const scaleX = (xv) =>
            padding + ((xv - minX) / (maxX - minX)) * (canvas.width - 2 * padding);
          const scaleY = (yv) =>
            canvas.height - padding - yv * (canvas.height - 2 * padding);

          ctx.clearRect(0, 0, canvas.width, canvas.height);
          drawAxes(ctx, canvas.width, canvas.height, padding);

          ctx.strokeStyle = "#cbd5f6";
          ctx.setLineDash([4, 4]);
          ctx.beginPath();
          ctx.moveTo(scaleX(minX), scaleY(0));
          ctx.lineTo(scaleX(maxX), scaleY(0));
          ctx.stroke();
          ctx.beginPath();
          ctx.moveTo(scaleX(minX), scaleY(1));
          ctx.lineTo(scaleX(maxX), scaleY(1));
          ctx.stroke();
          ctx.setLineDash([]);

          ctx.strokeStyle = "#f97316";
          ctx.lineWidth = 2;
          ctx.beginPath();
          xs.forEach((xi, i) => {
            const y = ysLinear[i];
            if (i === 0) ctx.moveTo(scaleX(xi), scaleY(y));
            else ctx.lineTo(scaleX(xi), scaleY(y));
          });
          ctx.stroke();

          ctx.strokeStyle = "#2563eb";
          ctx.lineWidth = 2.5;
          ctx.beginPath();
          xs.forEach((xi, i) => {
            const y = ysLogit[i];
            if (i === 0) ctx.moveTo(scaleX(xi), scaleY(y));
            else ctx.lineTo(scaleX(xi), scaleY(y));
          });
          ctx.stroke();

          ctx.strokeStyle = "#10b981";
          ctx.lineWidth = 2.5;
          ctx.beginPath();
          xs.forEach((xi, i) => {
            const y = ysProbit[i];
            if (i === 0) ctx.moveTo(scaleX(xi), scaleY(y));
            else ctx.lineTo(scaleX(xi), scaleY(y));
          });
          ctx.stroke();

          const linearProb = 0.5 + 0.2 * b1 * x;
          const logitProb = logistic(b1 * x);
          const probitProb = normalCDF(b1 * x, 0, 1);

          lpmOut.textContent = fmt(linearProb, 2);
          logitOut.textContent = fmt(logitProb, 2);
          probitOut.textContent = fmt(probitProb, 2);
          oddsOut.textContent = fmt(Math.exp(b1), 2);

          ctx.fillStyle = "#f97316";
          ctx.beginPath();
          ctx.arc(scaleX(x), scaleY(Math.min(Math.max(linearProb, 0), 1)), 4, 0, Math.PI * 2);
          ctx.fill();
          ctx.fillStyle = "#2563eb";
          ctx.beginPath();
          ctx.arc(scaleX(x), scaleY(logitProb), 4, 0, Math.PI * 2);
          ctx.fill();
          ctx.fillStyle = "#10b981";
          ctx.beginPath();
          ctx.arc(scaleX(x), scaleY(probitProb), 4, 0, Math.PI * 2);
          ctx.fill();
        }

        xInput.addEventListener("input", draw);
        b1Input.addEventListener("input", draw);
        draw();
      }

      function setupPoisson() {
        const b0Input = byId("pois-b0");
        const b1Input = byId("pois-b1");
        const runBtn = byId("pois-run");
        const canvas = byId("pois-canvas");
        const ctx = canvas.getContext("2d");
        const expOut = byId("pois-exp");
        const meaningOut = byId("pois-meaning");
        let xs = [];
        let ys = [];
        const xMin = 0;
        const xMax = 5;
        const safeNum = (value, fallback) =>
          Number.isFinite(value) ? value : fallback;
        const b0Min = safeNum(Number(b0Input.min), -0.5);
        const b0Max = safeNum(Number(b0Input.max), 1.5);
        const b1Min = safeNum(Number(b1Input.min), -0.5);
        const b1Max = safeNum(Number(b1Input.max), 0.8);
        const xScaleMax = 2;
        const maxLambda = Math.max(
          Math.exp(b0Min + b1Min * xScaleMax),
          Math.exp(b0Min + b1Max * xScaleMax),
          Math.exp(b0Max + b1Min * xScaleMax),
          Math.exp(b0Max + b1Max * xScaleMax)
        );
        const fixedMinY = 0;
        const fixedMaxY = Math.max(15, maxLambda * 1.2);

        function simulate() {
          const b0 = Number(b0Input.value);
          const b1 = Number(b1Input.value);
          xs = Array.from({ length: 120 }, () => Math.random() * 5);
          ys = xs.map((x) => poissonSample(Math.exp(b0 + b1 * x)));
          draw(b0, b1);
        }

        function draw(b0, b1) {
          const padding = 40;
          const minX = xMin;
          const maxX = xMax;
          const minY = fixedMinY;
          const maxY = fixedMaxY;
          const scaleX = (x) =>
            padding + ((x - minX) / (maxX - minX)) * (canvas.width - 2 * padding);
          const scaleY = (y) =>
            canvas.height - padding - ((y - minY) / (maxY - minY)) * (canvas.height - 2 * padding);

          ctx.clearRect(0, 0, canvas.width, canvas.height);
          drawAxes(ctx, canvas.width, canvas.height, padding);

          ctx.fillStyle = "rgba(59, 130, 246, 0.6)";
          xs.forEach((x, i) => {
            ctx.beginPath();
            ctx.arc(scaleX(x), scaleY(ys[i]), 3, 0, Math.PI * 2);
            ctx.fill();
          });

          ctx.strokeStyle = "#f97316";
          ctx.lineWidth = 2.5;
          ctx.beginPath();
          for (let i = 0; i <= 80; i += 1) {
            const x = minX + (i / 80) * (maxX - minX);
            const y = Math.exp(b0 + b1 * x);
            if (i === 0) ctx.moveTo(scaleX(x), scaleY(y));
            else ctx.lineTo(scaleX(x), scaleY(y));
          }
          ctx.stroke();

          const expB1 = Math.exp(b1);
          expOut.textContent = fmt(expB1, 2);
          meaningOut.textContent = `A +1 change multiplies expected count by ${fmt(expB1, 2)}.`;

          ctx.fillStyle = "#0f172a";
          ctx.font = "12px system-ui, sans-serif";
          ctx.fillText("Marketing (X)", canvas.width - 140, canvas.height - 12);
          ctx.fillText("Visits (count)", 10, 18);
        }

        runBtn.addEventListener("click", simulate);
        [b0Input, b1Input].forEach((input) => input.addEventListener("input", simulate));
        simulate();
      }

      let panelState = null;

      function setupPanelDataset() {
        const nInput = byId("panel-n");
        const tInput = byId("panel-t");
        const showY = byId("panel-show-y");
        const showX = byId("panel-show-x");
        const showZ = byId("panel-show-z");
        const focusInput = byId("panel-focus");
        const canvas = byId("panel-canvas");
        const ctx = canvas.getContext("2d");
        const withinOut = byId("panel-within");
        const betweenOut = byId("panel-between");
        const table = byId("panel-table");

        function generateData() {
          const n = Number(nInput.value);
          const t = Number(tInput.value);
          const data = [];
          const segments = Array.from({ length: n }, () => (Math.random() < 0.5 ? 0 : 1));
          const base = Array.from({ length: n }, () => normalSample(0, 0.8));
          for (let i = 0; i < n; i += 1) {
            for (let tt = 0; tt < t; tt += 1) {
              const x = 2 + 0.4 * tt + normalSample(0, 0.6);
              const y = 5 + 0.8 * x + 1.2 * segments[i] + base[i] + 0.2 * tt + normalSample(0, 0.6);
              data.push({ id: i + 1, t: tt + 1, x, z: segments[i], y });
            }
          }
          panelState = { n, t, data };
        }

        function updateFocusOptions() {
          focusInput.innerHTML = "";
          const optAll = document.createElement("option");
          optAll.value = "all";
          optAll.textContent = "All";
          focusInput.appendChild(optAll);
          for (let i = 1; i <= panelState.n; i += 1) {
            const opt = document.createElement("option");
            opt.value = String(i);
            opt.textContent = `Unit ${i}`;
            focusInput.appendChild(opt);
          }
        }

        function draw() {
          const padding = 40;
          ctx.clearRect(0, 0, canvas.width, canvas.height);
          drawAxes(ctx, canvas.width, canvas.height, padding);

          const focus = focusInput.value;
          const data = panelState.data;
          const tMax = panelState.t;
          const xs = data.map((d) => d.t);
          const yVals = data.map((d) => d.y);
          const xVals = data.map((d) => d.x);
          const zVals = data.map((d) => d.z);
          const minY = Math.min(...yVals, ...xVals);
          const maxY = Math.max(...yVals, ...xVals, 1);
          const scaleX = (t) =>
            padding + ((t - 1) / (tMax - 1)) * (canvas.width - 2 * padding);
          const scaleY = (v) =>
            canvas.height - padding - ((v - minY) / (maxY - minY)) * (canvas.height - 2 * padding);

          const drawLine = (points, color, label) => {
            if (points.length === 0) return;
            ctx.strokeStyle = color;
            ctx.lineWidth = 2;
            ctx.beginPath();
            points.forEach((p, idx) => {
              const cx = scaleX(p.t);
              const cy = scaleY(p.v);
              if (idx === 0) ctx.moveTo(cx, cy);
              else ctx.lineTo(cx, cy);
            });
            ctx.stroke();
            if (label) {
              const last = points[points.length - 1];
              ctx.fillStyle = color;
              ctx.font = "12px system-ui, sans-serif";
              ctx.fillText(label, scaleX(last.t) + 6, scaleY(last.v));
            }
          };

          if (focus === "all") {
            const avgByT = Array.from({ length: tMax }, (_, i) => {
              const subset = data.filter((d) => d.t === i + 1);
              return {
                t: i + 1,
                y: mean(subset.map((d) => d.y)),
                x: mean(subset.map((d) => d.x)),
                z: mean(subset.map((d) => d.z))
              };
            });
            if (showY.checked) drawLine(avgByT.map((d) => ({ t: d.t, v: d.y })), "#2563eb", "Avg Y");
            if (showX.checked) drawLine(avgByT.map((d) => ({ t: d.t, v: d.x })), "#10b981", "Avg X");
            if (showZ.checked) drawLine(avgByT.map((d) => ({ t: d.t, v: d.z })), "#a855f7", "Avg Z");
          } else {
            const id = Number(focus);
            const subset = data.filter((d) => d.id === id);
            if (showY.checked) drawLine(subset.map((d) => ({ t: d.t, v: d.y })), "#2563eb", "Y");
            if (showX.checked) drawLine(subset.map((d) => ({ t: d.t, v: d.x })), "#10b981", "X");
            if (showZ.checked) {
              drawLine(subset.map((d) => ({ t: d.t, v: d.z })), "#a855f7", "Z");
            }
          }

          ctx.fillStyle = "#0f172a";
          ctx.font = "12px system-ui, sans-serif";
          ctx.fillText("Time", canvas.width - 80, canvas.height - 12);
          ctx.fillText("Value", 10, 18);

          const yById = Array.from({ length: panelState.n }, () => []);
          data.forEach((d) => yById[d.id - 1].push(d.y));
          const within = mean(yById.map((arr) => {
            const m = mean(arr);
            return mean(arr.map((v) => (v - m) ** 2));
          }));
          const between = (() => {
            const means = yById.map((arr) => mean(arr));
            const m = mean(means);
            return mean(means.map((v) => (v - m) ** 2));
          })();
          withinOut.textContent = fmt(within, 2);
          betweenOut.textContent = fmt(between, 2);

          const rows = data.slice(0, 10);
          table.innerHTML = `
            <thead>
              <tr><th>ID</th><th>Time</th><th>Sales (Y)</th><th>Engagement (X)</th><th>Segment (Z)</th></tr>
            </thead>
            <tbody>
              ${rows.map((r) =>
                `<tr><td>${r.id}</td><td>${r.t}</td><td>${fmt(r.y, 2)}</td><td>${fmt(r.x, 2)}</td><td>${r.z}</td></tr>`
              ).join("")}
            </tbody>
          `;
        }

        function regenerate() {
          generateData();
          updateFocusOptions();
          draw();
          if (window.panelModelRender) {
            window.panelModelRender("pooled");
          }
        }

        [nInput, tInput].forEach((input) => input.addEventListener("input", regenerate));
        [showY, showX, showZ, focusInput].forEach((input) => input.addEventListener("change", draw));
        regenerate();
      }

      function setupPanelModels() {
        const buttons = Array.from(byId("panel-models").querySelectorAll("button"));
        const tbody = byId("panel-coefs");
        const summary = byId("panel-summary");

        function computeModels() {
          const data = panelState.data;
          const n = panelState.n;
          const t = panelState.t;
          const xs = data.map((d) => d.x);
          const zs = data.map((d) => d.z);
          const ys = data.map((d) => d.y);
          const A = [
            [data.length, xs.reduce((s, v) => s + v, 0), zs.reduce((s, v) => s + v, 0)],
            [xs.reduce((s, v) => s + v, 0), xs.reduce((s, v) => s + v * v, 0), xs.reduce((s, v, i) => s + v * zs[i], 0)],
            [zs.reduce((s, v) => s + v, 0), xs.reduce((s, v, i) => s + v * zs[i], 0), zs.reduce((s, v) => s + v * v, 0)]
          ];
          const B = [
            ys.reduce((s, v) => s + v, 0),
            xs.reduce((s, v, i) => s + v * ys[i], 0),
            zs.reduce((s, v, i) => s + v * ys[i], 0)
          ];
          const pooled = solveLinearSystem(A, B);

          const xBar = Array.from({ length: n }, () => 0);
          const yBar = Array.from({ length: n }, () => 0);
          const zBar = Array.from({ length: n }, () => 0);
          const counts = Array.from({ length: n }, () => 0);
          data.forEach((d) => {
            const id = d.id - 1;
            xBar[id] += d.x;
            yBar[id] += d.y;
            zBar[id] += d.z;
            counts[id] += 1;
          });
          for (let i = 0; i < n; i += 1) {
            xBar[i] /= counts[i];
            yBar[i] /= counts[i];
            zBar[i] /= counts[i];
          }
          let num = 0;
          let den = 0;
          data.forEach((d) => {
            const id = d.id - 1;
            const xw = d.x - xBar[id];
            const yw = d.y - yBar[id];
            num += xw * yw;
            den += xw * xw;
          });
          const feSlope = num / den;

          const fdXs = [];
          const fdYs = [];
          for (let id = 1; id <= n; id += 1) {
            for (let tt = 2; tt <= t; tt += 1) {
              const cur = data.find((d) => d.id === id && d.t === tt);
              const prev = data.find((d) => d.id === id && d.t === tt - 1);
              fdXs.push(cur.x - prev.x);
              fdYs.push(cur.y - prev.y);
            }
          }
          const fdSlope = fdXs.reduce((s, v, i) => s + v * fdYs[i], 0) /
            fdXs.reduce((s, v) => s + v * v, 0);

          const yById = Array.from({ length: n }, () => []);
          data.forEach((d) => yById[d.id - 1].push(d.y));
          const withinVar = mean(yById.map((arr) => {
            const m = mean(arr);
            return mean(arr.map((v) => (v - m) ** 2));
          }));
          const betweenVar = (() => {
            const means = yById.map((arr) => mean(arr));
            const m = mean(means);
            return mean(means.map((v) => (v - m) ** 2));
          })();
          const theta = 1 - Math.sqrt(withinVar / (withinVar + t * betweenVar + 1e-6));
          const xTilde = [];
          const yTilde = [];
          const zTilde = [];
          data.forEach((d) => {
            const id = d.id - 1;
            xTilde.push(d.x - theta * xBar[id]);
            yTilde.push(d.y - theta * yBar[id]);
            zTilde.push(d.z - theta * zBar[id]);
          });
          const ARe = [
            [yTilde.length, xTilde.reduce((s, v) => s + v, 0), zTilde.reduce((s, v) => s + v, 0)],
            [xTilde.reduce((s, v) => s + v, 0), xTilde.reduce((s, v) => s + v * v, 0), xTilde.reduce((s, v, i) => s + v * zTilde[i], 0)],
            [zTilde.reduce((s, v) => s + v, 0), xTilde.reduce((s, v, i) => s + v * zTilde[i], 0), zTilde.reduce((s, v) => s + v * v, 0)]
          ];
          const BRe = [
            yTilde.reduce((s, v) => s + v, 0),
            xTilde.reduce((s, v, i) => s + v * yTilde[i], 0),
            zTilde.reduce((s, v, i) => s + v * yTilde[i], 0)
          ];
          const re = solveLinearSystem(ARe, BRe);

          return {
            pooled: { b0: pooled[0], b1: pooled[1], b2: pooled[2] },
            fe: { b0: null, b1: feSlope, b2: null },
            lsdv: { b0: null, b1: feSlope, b2: null },
            fd: { b0: null, b1: fdSlope, b2: null },
            re: { b0: re[0], b1: re[1], b2: re[2] }
          };
        }

        function render(modelKey) {
          const models = computeModels();
          const model = models[modelKey];
          const rows = [
            { term: "Intercept", val: model.b0 },
            { term: "Engagement (X)", val: model.b1 },
            { term: "Segment (Z)", val: model.b2 }
          ];
          tbody.innerHTML = rows.map((row) => `
            <tr>
              <td>${row.term}</td>
              <td>${row.val === null ? "NA" : fmt(row.val, 2)}</td>
              <td>${row.val === null ? "Not identified" : "Estimate"}</td>
            </tr>`).join("");

          const summaries = {
            pooled: "Pooled OLS blends within and between variation.",
            fe: "Fixed effects uses within-unit changes only.",
            lsdv: "LSDV is equivalent to fixed effects with unit dummies.",
            fd: "First differences remove time-invariant effects.",
            re: "Random effects partially pools within and between variation."
          };
          summary.textContent = summaries[modelKey];
        }

        buttons.forEach((btn) => {
          btn.addEventListener("click", () => {
            buttons.forEach((b) => b.classList.remove("secondary"));
            btn.classList.add("secondary");
            render(btn.dataset.model);
          });
        });

        window.panelModelRender = render;
        render("pooled");
      }

      function setupPanelBiasEstimator() {
        const rhoInput = byId("panel-rho");
        const nInput = byId("panel-n-label-input");
        const tInput = byId("panel-t-label-input");
        const rhoLabel = byId("panel-rho-label");
        const nLabel = byId("panel-n-label");
        const tLabel = byId("panel-t-label");
        const runBtn = byId("panel-bias-run");
        const pooledOut = byId("panel-pooled");
        const feOut = byId("panel-fe");
        const noteOut = byId("panel-note");
        const canvas = byId("panel-bias-canvas");
        const ctx = canvas.getContext("2d");

        function simulate() {
          const rho = Number(rhoInput.value);
          const n = Number(nInput.value);
          const t = Number(tInput.value);
          rhoLabel.textContent = fmt(rho, 2);
          nLabel.textContent = nInput.value;
          tLabel.textContent = tInput.value;

          const betaTrue = 0.8;
          const u = Array.from({ length: n }, () => normalSample(0, 1));
          const x = [];
          const y = [];
          const ids = [];

          for (let i = 0; i < n; i += 1) {
            for (let j = 0; j < t; j += 1) {
              const xij = rho * u[i] + Math.sqrt(1 - rho * rho) * normalSample(0, 1);
              const yij = 1 + betaTrue * xij + u[i] + normalSample(0, 1);
              x.push(xij);
              y.push(yij);
              ids.push(i);
            }
          }

          const meanX = mean(x);
          const meanY = mean(y);
          const ssX = x.reduce((s, v) => s + (v - meanX) ** 2, 0);
          const cov = x.reduce((s, v, i) => s + (v - meanX) * (y[i] - meanY), 0);
          const pooledSlope = cov / ssX;

          const xBar = Array.from({ length: n }, () => 0);
          const yBar = Array.from({ length: n }, () => 0);
          const counts = Array.from({ length: n }, () => 0);
          for (let i = 0; i < x.length; i += 1) {
            const id = ids[i];
            xBar[id] += x[i];
            yBar[id] += y[i];
            counts[id] += 1;
          }
          for (let i = 0; i < n; i += 1) {
            xBar[i] /= counts[i];
            yBar[i] /= counts[i];
          }
          let num = 0;
          let den = 0;
          for (let i = 0; i < x.length; i += 1) {
            const id = ids[i];
            const xw = x[i] - xBar[id];
            const yw = y[i] - yBar[id];
            num += xw * yw;
            den += xw * xw;
          }
          const feSlope = num / den;

          pooledOut.textContent = fmt(pooledSlope, 2);
          feOut.textContent = fmt(feSlope, 2);
          noteOut.textContent = rho > 0.4 ? "Pooled biased upward" : "Bias is mild";

          const padding = 40;
          const w = canvas.width;
          const h = canvas.height;
          ctx.clearRect(0, 0, w, h);
          drawAxes(ctx, w, h, padding);

          const barWidth = 120;
          const maxVal = Math.max(pooledSlope, feSlope, betaTrue);
          const scaleY = (v) => (v / (maxVal + 0.5)) * (h - 2 * padding);

          ctx.fillStyle = "#60a5fa";
          ctx.fillRect(padding + 60, h - padding - scaleY(pooledSlope), barWidth, scaleY(pooledSlope));
          ctx.fillStyle = "#34d399";
          ctx.fillRect(padding + 220, h - padding - scaleY(feSlope), barWidth, scaleY(feSlope));
          ctx.fillStyle = "#f97316";
          ctx.fillRect(padding + 380, h - padding - scaleY(betaTrue), barWidth, scaleY(betaTrue));

          ctx.fillStyle = "#0f172a";
          ctx.font = "12px system-ui, sans-serif";
          ctx.fillText("Pooled", padding + 75, h - padding + 18);
          ctx.fillText("Fixed effects", padding + 230, h - padding + 18);
          ctx.fillText("True beta", padding + 410, h - padding + 18);
        }

        rhoInput.addEventListener("input", simulate);
        nInput.addEventListener("input", simulate);
        tInput.addEventListener("input", simulate);
        runBtn.addEventListener("click", simulate);
        simulate();
      }

      function setupFeReCompare() {
        const rhoInput = byId("fe-re-rho");
        const viewInput = byId("fe-re-view");
        const runBtn = byId("fe-re-run");
        const canvas = byId("fe-re-canvas");
        const ctx = canvas.getContext("2d");
        const feOut = byId("fe-re-fe");
        const reOut = byId("fe-re-re");

        function simulate() {
          const rho = Number(rhoInput.value);
          const n = 6;
          const t = 8;
          const betaTrue = 0.8;
          const u = Array.from({ length: n }, () => normalSample(0, 1));
          const data = [];
          for (let i = 0; i < n; i += 1) {
            for (let j = 0; j < t; j += 1) {
              const x = rho * u[i] + Math.sqrt(1 - rho * rho) * normalSample(0, 1) + normalSample(0, 0.3);
              const y = 1 + betaTrue * x + u[i] + normalSample(0, 1);
              data.push({ id: i, x, y });
            }
          }

          const meanX = mean(data.map((d) => d.x));
          const meanY = mean(data.map((d) => d.y));
          const ssX = data.reduce((s, d) => s + (d.x - meanX) ** 2, 0);
          const cov = data.reduce((s, d) => s + (d.x - meanX) * (d.y - meanY), 0);
          const pooledSlope = cov / ssX;
          const pooledIntercept = meanY - pooledSlope * meanX;

          const xBar = Array.from({ length: n }, () => 0);
          const yBar = Array.from({ length: n }, () => 0);
          const counts = Array.from({ length: n }, () => 0);
          data.forEach((d) => {
            xBar[d.id] += d.x;
            yBar[d.id] += d.y;
            counts[d.id] += 1;
          });
          for (let i = 0; i < n; i += 1) {
            xBar[i] /= counts[i];
            yBar[i] /= counts[i];
          }
          let num = 0;
          let den = 0;
          data.forEach((d) => {
            const xw = d.x - xBar[d.id];
            const yw = d.y - yBar[d.id];
            num += xw * yw;
            den += xw * xw;
          });
          const feSlope = num / den;

          const withinVar = mean(data.map((d) => (d.y - yBar[d.id]) ** 2));
          const betweenVar = mean(yBar.map((v) => (v - mean(yBar)) ** 2));
          const theta = 1 - Math.sqrt(withinVar / (withinVar + t * betweenVar + 1e-6));
          const xTilde = data.map((d) => d.x - theta * xBar[d.id]);
          const yTilde = data.map((d) => d.y - theta * yBar[d.id]);
          const meanXt = mean(xTilde);
          const meanYt = mean(yTilde);
          const ssXt = xTilde.reduce((s, v) => s + (v - meanXt) ** 2, 0);
          const covt = xTilde.reduce((s, v, i) => s + (v - meanXt) * (yTilde[i] - meanYt), 0);
          const reSlope = covt / ssXt;
          const reIntercept = meanY - reSlope * meanX;
          const feIntercepts = xBar.map((xMean, i) => yBar[i] - feSlope * xMean);
          const reIntercepts = feIntercepts.map((b0) => reIntercept + (1 - theta) * (b0 - reIntercept));

          feOut.textContent = fmt(feSlope, 2);
          reOut.textContent = fmt(reSlope, 2);

          const padding = 40;
          const w = canvas.width;
          const h = canvas.height;
          ctx.clearRect(0, 0, w, h);
          drawAxes(ctx, w, h, padding);

          const minX = Math.min(...data.map((d) => d.x));
          const maxX = Math.max(...data.map((d) => d.x));
          let minY = Math.min(...data.map((d) => d.y));
          let maxY = Math.max(...data.map((d) => d.y));

          const view = viewInput.value;
          const slope = view === "fe" ? feSlope : reSlope;
          const intercepts = view === "fe" ? feIntercepts : reIntercepts;
          intercepts.forEach((b0) => {
            minY = Math.min(minY, b0 + slope * minX, b0 + slope * maxX);
            maxY = Math.max(maxY, b0 + slope * minX, b0 + slope * maxX);
          });
          minY = Math.min(minY, pooledIntercept + pooledSlope * minX, pooledIntercept + pooledSlope * maxX);
          maxY = Math.max(maxY, pooledIntercept + pooledSlope * minX, pooledIntercept + pooledSlope * maxX);

          const scaleX = (x) =>
            padding + ((x - minX) / (maxX - minX)) * (w - 2 * padding);
          const scaleY = (y) =>
            h - padding - ((y - minY) / (maxY - minY)) * (h - 2 * padding);

          const colors = ["#ef4444", "#f59e0b", "#22c55e", "#0ea5e9", "#8b5cf6", "#ec4899"];
          const labels = ["A", "B", "C", "D", "E", "F"];

          intercepts.forEach((b0, i) => {
            const x1 = minX;
            const x2 = maxX;
            const y1 = b0 + slope * x1;
            const y2 = b0 + slope * x2;
            ctx.strokeStyle = colors[i % colors.length];
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(scaleX(x1), scaleY(y1));
            ctx.lineTo(scaleX(x2), scaleY(y2));
            ctx.stroke();

            ctx.fillStyle = colors[i % colors.length];
            ctx.beginPath();
            ctx.arc(scaleX(xBar[i]), scaleY(yBar[i]), 3, 0, Math.PI * 2);
            ctx.fill();
            ctx.font = "11px system-ui, sans-serif";
            ctx.fillText(labels[i], scaleX(x2) + 4, scaleY(y2));
          });

          ctx.strokeStyle = "#111827";
          ctx.lineWidth = 3;
          ctx.beginPath();
          ctx.moveTo(scaleX(minX), scaleY(pooledIntercept + pooledSlope * minX));
          ctx.lineTo(scaleX(maxX), scaleY(pooledIntercept + pooledSlope * maxX));
          ctx.stroke();

          ctx.fillStyle = "#0f172a";
          ctx.font = "12px system-ui, sans-serif";
          ctx.fillText("Engagement (X)", w - 160, h - 12);
          ctx.fillText("Sales (Y)", 10, 18);
        }

        rhoInput.addEventListener("input", simulate);
        viewInput.addEventListener("change", simulate);
        runBtn.addEventListener("click", simulate);
        simulate();
      }

      function setupQuizzes() {
        document.querySelectorAll(".quiz").forEach((quiz) => {
          const correct = quiz.dataset.answer;
          const button = quiz.querySelector(".check-btn");
          const feedback = quiz.querySelector(".feedback");

          button.addEventListener("click", () => {
            const selected = quiz.querySelector("input:checked");
            if (!selected) {
              feedback.textContent = "Select an answer first.";
              feedback.className = "feedback";
              return;
            }
            if (selected.value === correct) {
              feedback.textContent = "Correct. Nice work.";
              feedback.className = "feedback correct";
            } else {
              feedback.textContent = "Not quite. Review the concept and try again.";
              feedback.className = "feedback wrong";
            }
          });
        });
      }

      function setupMiniChecks() {
        document.querySelectorAll(".mini-check").forEach((check) => {
          const correct = check.dataset.answer;
          const button = check.querySelector(".check-btn");
          const select = check.querySelector("select");
          const feedback = check.querySelector(".feedback");

          button.addEventListener("click", () => {
            if (!select.value) {
              feedback.textContent = "Select an option first.";
              feedback.className = "feedback";
              return;
            }
            if (select.value === correct) {
              feedback.textContent = "Correct.";
              feedback.className = "feedback correct";
            } else {
              feedback.textContent = "Not quite. Try again.";
              feedback.className = "feedback wrong";
            }
          });
        });
      }

      async function setupWebRBench() {
        const output = byId("r-output");
        const runBtn = byId("r-run");
        const resetBtn = byId("r-reset");
        const buildBtn = byId("r-build");
        const codeArea = byId("r-code");
        const canvas = byId("r-plot");
        const ctx = canvas.getContext("2d");

        const nInput = byId("r-n");
        const betaInput = byId("r-beta");
        const idsInput = byId("r-ids");
        const tInput = byId("r-t");
        const bpanelInput = byId("r-bpanel");
        const usdInput = byId("r-usd");

        const defaultParams = {
          n: 500,
          beta: 1.1,
          ids: 120,
          t: 6,
          bpanel: 0.8,
          usd: 0.8
        };

        function buildCode() {
          const n = Number(nInput.value);
          const beta = Number(betaInput.value);
          const ids = Number(idsInput.value);
          const t = Number(tInput.value);
          const bpanel = Number(bpanelInput.value);
          const usd = Number(usdInput.value);
          return `set.seed(77)
n <- ${n}
beta <- ${beta}
x <- rnorm(n)
linpred <- beta * x
p <- 1 / (1 + exp(-linpred))
y <- rbinom(n, 1, p)
df_logit <- data.frame(y, x)

cat("Logit model\\n")
fit_logit <- glm(y ~ x, data = df_logit, family = binomial)
print(summary(fit_logit))
cat("\\nOdds ratio for x:", exp(coef(fit_logit)["x"]), "\\n")

ids <- ${ids}
t <- ${t}
beta_panel <- ${bpanel}
u_sd <- ${usd}
id <- rep(1:ids, each = t)
time <- rep(1:t, times = ids)
u <- rnorm(ids, 0, u_sd)
u_i <- u[id]
x_panel <- rnorm(ids * t)
y_panel <- 1 + beta_panel * x_panel + u_i + rnorm(ids * t, 0, 1)
df_panel <- data.frame(id = id, time = time, y = y_panel, x = x_panel)

cat("\\nPooled OLS\\n")
print(summary(lm(y ~ x, df_panel)))
cat("\\nFixed effects (LSDV)\\n")
print(summary(lm(y ~ x + factor(id), df_panel)))

par(mfrow = c(1, 2))
plot(df_panel$time, df_panel$y, pch = 16, col = "#60a5fa",
     main = "Panel outcomes over time", xlab = "Time", ylab = "Y")
plot(fitted(fit_logit), resid(fit_logit), pch = 16, col = "#f87171",
     main = "Logit residuals", xlab = "Fitted", ylab = "Residuals")`;
        }

        function reset() {
          nInput.value = defaultParams.n;
          betaInput.value = defaultParams.beta;
          idsInput.value = defaultParams.ids;
          tInput.value = defaultParams.t;
          bpanelInput.value = defaultParams.bpanel;
          usdInput.value = defaultParams.usd;
          codeArea.value = buildCode();
        }

        function clearOutput() {
          output.textContent = "";
          ctx.clearRect(0, 0, canvas.width, canvas.height);
        }

        let webRConsole = null;
        try {
          const { Console } = await import("https://webr.r-wasm.org/latest/webr.mjs");
          webRConsole = new Console({
            stdout: (line) => {
              output.textContent += `${line}\n`;
            },
            stderr: (line) => {
              output.textContent += `${line}\n`;
            },
            prompt: (line) => {
              output.textContent += line;
            },
            canvasImage: (img) => {
              ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
            },
            canvasNewPage: () => {
              ctx.clearRect(0, 0, canvas.width, canvas.height);
            }
          });
          await webRConsole.run();
          await webRConsole.stdin("options(device=webr::canvas(450, 260))");
          output.textContent = "webR is ready. Update parameters and run the code.";
          runBtn.disabled = false;
        } catch (err) {
          output.textContent = `webR failed to load: ${err.message}`;
        }

        buildBtn.addEventListener("click", () => {
          codeArea.value = buildCode();
        });

        resetBtn.addEventListener("click", () => {
          reset();
          clearOutput();
          output.textContent = "Reset to defaults. Click Run R to execute.";
        });

        runBtn.addEventListener("click", async () => {
          if (!webRConsole) return;
          clearOutput();
          await webRConsole.stdin(codeArea.value);
        });

        reset();
      }

      reorderSections();
      setupTheoryCards();
      setupViewSettings();
      setupNonlinear();
      setupFitComparison();
      setupBinaryCheck();
      setupLPM();
      setupLogisticCurve();
      setupLogitMapping();
      setupLogitFit();
      setupProbitFit();
      setupCompareModels();
      setupPoisson();
      setupPanelDataset();
      setupPanelModels();
      setupPanelBiasEstimator();
      setupFeReCompare();
      setupQuizzes();
      setupMiniChecks();
      setupWebRBench();
    </script>
  </body>
  </html>
